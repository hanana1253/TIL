# React

## useRoutes
- React Router DOM에서 제공하는 useRoutes 훅을 통해 객체 형태로 각 Route를 렌더링할 수 있다.
```js
// App.js before (BrowserRouter로 감싸주는 것은 index.js에서 해주고 있다.)
import { Routes, Route, Navigate } from 'react-router-dom';

export default function App(){
    return <Routes>
        <Route element={<Layout offset={120} />}>
            <Route path="/" element={<Home />}>
            <Route path="signin" element={<SignIn id="sign-in" />} />
            <Route path="signup" element={<SignUp id="sign-up" />} />
            <Route path="page-not-found" element={<PageNotFound />} />
            <Route path="*" element={<Navigate to="page-not-found" replace />} />
        </Route>
    </Routes>
};

// App.js after
import { useRoutes, Navigate } from 'react-router-dom';

export default function App() {
    const routesElement = useRoutes([{
        element: <Layout offset={120} />, 
        children: [
            { path: "/", element: <Home />},
            { path: "signin", element: <SignIn id="sign-in" />},
            { path: "signup", element: <SignUp id="sign-up" />},
            { path: "page-not-found", element: <PageNotFound />},
            { path: "*", element: <Navigate to="page-not-found" replace />}
        ]
    }]);
    return routesElement;
}

```

## useLayoutEffect
- Layout에서 header의 높이를 계산해서 적절한 padding-top을 주려고 하는데, 이 때 dom에 반영된 요소의 높이를 계산해야 한다. 
- virtual dom일 땐 높이를 계산할 수 없으므로 useLayoutEffect를 통해 실제 DOM에 mount된 이후 headerRef의 높이를 가져온 후 Layout에 들어가는 요소의 paddingtop에 계산해넣는다.
```js
import 'styled-components/macro';

export default function Layout({offset}) {
    const headerRef = useRef(null);
    let [ headerHeight, setHeaderHeight ] = useState(0);

    useLayoutEffect(()=> {
        let { height } = headerRef.current.getBoundingClientRect();
        setHeaderHeight(height);
    }, [offset]);

    return <Container>
        <Header ref={headerRef} blur />
        <Wrapper 
          as="main" 
          css={`
            min-height: 100vh;
            padding-top: ${headerHeight};
          `}>
          <Outlet />
        </Wrapper>
    </Container>
}
```
- 여기서 주는 css 프롭은 styled-components/macro 패키지를 import하면 사용할 수 있는 prop으로, 여기에 벡틱으로 전달된 css 코드가 Wrapper의 styled-components에 적용된다.

## React.lazy와 Loading component

### lazy 함수와 비동기 import함수
- 최적화를 위해 각 컴포넌트가 호출될 때 해당 코드를 가져오는 lazy 함수
- 동기 import문로 가져와 컴포넌트에 넣지 말고 lazy 함수에 넣는 콜백함수 안에서 비동기 import 함수를 통해 필요한 컴포넌트를 chunk로 가져와 컴포넌트 이름에 넣을 변수에 할당한다.
- 이 때 비동기 함수 import로 불러올 컴포넌트는 **꼭 default export**로 내보내야 한다.
- 가져오는 동안 대체 컴포넌트를 렌더링할 수 있는데 이는 Suspense라는 컴포넌트를 통해 감싸준 후 fallback 프롭으로 Loading spinner 컴포넌트를 넣어주면 된다.
```js
import { lazy, Suspense } from 'react';

const Home = lazy(() => import('./pages/Home/Home'));
const Layout = lazy(() => import('./pages/Layout/Layout'));
// ...

export default function App() {
    const routesElement = useRoutes([
        {
            element: <Layout offset={120} />, 
            children : [ ... ]
        }
    ]);
    return <Suspense fallback={<Loading />}> routesElement </Suspense>;
}
```
- lazy로 Routes 할 애들을 Suspense 컴포넌트로 감싸고, lazy로 호출한 애들이 아직 렌더링트리에 반영되지 않은 경우 Suspense의 fallback 프롭에 준 컴포넌트가 렌더링된다. 
  - 이 때 fallback으로 준 컴포넌트에서 useEffect를 사용하여 로딩 정보를 나타내는 접근성 처리를 해줄 수 있다.

### React Loading Icons
- 코드 스플릿 해주면서 각 페이지 컴포넌트를 불러올 때 시간이 걸린다. 이 때 띄워줄 loading 컴포넌트를 라이브러리로 가져와보자.
- `react-loading-icons`라는 패키지를 설치하고 `import { Bars } from 'react-loading-icons'`로 꺼내온다.
- prop으로 넣을 수 있는 custom 항목들을 공식문서에서 확인하여 전달한다. (크기, 색깔 등)
- useEffect로 접근성 처리를 해준다.

## Form을 위한 Compound Component 패턴
- 로그인과 회원가입 등 많은 요소들이 연관되어 있는 경우 Compound Component로 만들어두고 가져다 쓰자.
- Form.Container는 가장 상위의 컴포넌트로, `<Container {... props}>`를 반환한다.
- Form.Headline은 form에 대한 제목 및 id나 label 등을 갖는다.
- Form.Input은 label, type, id, children 등을 받아 label 태그와 input 태그에 넣어주고 placeholder에 children을 넣는다.
- Form.Button은 callToAction이라는 커스텀 prop을 통해 버튼 disable 상태를 조절한다. 
- Form.Info는 관련 설명을 넣어주고 싶을 때 사용한다.
- 아래와 같이 사용할 수 있다.
```js
<Form.Container>
    <Form.Headline id={id}>로그인 폼</Form.Headline>
    <Form aria-labelledby={id} onSubmit={handleSubmit} ref={formRef}>
        <Form.Input
            type="email"
            id="userMail"
            label="이메일"
            autoComplete="user-name"
            name="email"
            value={email}
            error={emailError}
            success={emailSuccess}
            onChange={handleChange}
        >
            계정 이메일 주소를 올바르게 입력하세요.
        </Form.Input>
        <Form.Input
            type="password"
            id="userPass"
            label="패스워드"
            autoComplete="current-password"
            name="password"
            value={password}
            error={passwordError}
            success={passwordSuccess}
            onChange={handleChange}
        >
            계정 비밀번호를 입력하세요.
        </Form.Input>
        <Form.Button callToAction type="submit" disabled={!isAllInputed}>
            로그인
        </Form.Button>
        <Form.Button type="reset" onClick={handleReset}>
            초기화
        </Form.Button>
    </Form>

    <Form.Info>
        회원가입한 적이 없다면? <Link to="/signup">회원가입</Link> 페이지로
        이동해 가입하세요.
    </Form.Info>
</Form.Container>
```

## Form 

## Context API
- 리액트가 제공하는 Context API로 간단한 어플리케이션은 한 곳에서 데이터를 공급하고 관리해줄 수 있다.
- 여러 컴포넌트에서 하나의 상태를 받아 쓰거나 조작할 일이 있을 때, props로 계속 내려주는 것은 비효율적이기 때문에, 이를 보다 편리하게 가져다 쓸 수 있도록 context를 만들어 두고, 필요한 컴포넌트에서는 이를 받아 쓴다.

### 회원가입
- input 컴포넌트는 presentational component로 하고, 전체 formData를 한 번에 받아 처리할 수 있도록 Form에서 상태를 관리하자.
- 

- 인증 정보를 저장하는 AuthProvider를 만들어 필요한 다른 컴포넌트에서도 인증상태를 받을 수 있게 해보자.
