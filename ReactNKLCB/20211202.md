# React

## 지난 시간 수습 및 복습
- JSX를 사용하는 목적: React API로 함수를 호출하기보다 XML문법을 사용하여 편리하게 작성
- JSX를 React.createElement로 컴파일해주는 바벨도 사용해보았다.

## 오늘 해볼 리액트 실습 남은 것들
1. 바벨 폴리필: 브라우저가 지원하지 못하는 것들을 지원하기 위해 사용
2. 지난 시간 배운 함수 콤포넌트를 이어서 배울 것
3. 함수 콤포넌트들을 Babel CLI를 통해 모듈 프로그래밍 해볼 것

### Babel Polyfill
- Polyfill이 왜 필요할까? 
  - [Babel 공식문서에서 Polyfill](https://babeljs.io/docs/en/babel-polyfill#docsNav)을 찾아보자.
  - 이제는 deprecated 되었으니 core-js와 regenerator-runtime로 하라는 안내 메시지가 있다.
- 뭔말인지 모르겠으니 직접 해보면서 polyfill의 필요성을 느껴보자. 
  - render-react-browser에서 npm start 명령으로 서버를 돌리자
- 지난 이야기: babel standalone CDN으로 우리는 script 태그를 컴파일해서 썼다. 
  - 이는 `type="text/babel"`로 지정한 스크립트 태그 안의 코드를 babel standalone이 head 태그에 컴파일결과를 새로운 스크립트로 넣어주기에 가능한 것
  - head에 있는 컴파일 결과물을 보면 모두 createElement로 되어있는 것을 알 수 있다. 
- babel standalone이 컴파일 못해주는 것(`Array.prototype.find`, `Promise`)을 한 번 써보자.
  - canIUse에서 find 배열메서드와 promise를 보면 IE 지원이 안되고 있음을 알 수 있다.
```js
// index.html 의 script 태그, babel standalone에 의해 컴파일되어야 하므로 type="text/babel"

const numbers = [101, 201, 301];
let findTwoZeroOne = numbers.find(number => number === 201);
console.log(findTwoZeroOne);

function delay(timeout) {
    return new Promise(resolve => {
        window.setTimeout(()=> resolve(), timeout)
    })
}

delay(3000).then(()=> {
    console.log('Call out');
})
```
- 위 코드를 실행하면 콘솔에 201과 3초 후 'CallOut'이 찍히는데, 이 두 개는 어떻게 컴파일 되었는지 확인해보자.
  - 따로 컴파일 된 게 아니라 그대로 find와 Promise로 쓰이고 있음을 알 수 있다.
  - IE에서는 이런 코드가 다 해석이 안돼서 작동이 안 된다.
  - 이렇게 구형 브라우저가 지원하지 않는 문법을 대체할 옛 문법을 제공하는 것이 바로 babel/polyfill인 것이다.
- 우리는 브라우저 환경에서 쓸 것이기 때문에 CDN으로 쓰자. 
  - babel/polyfill 스크립트 태그로 넣는다. 개발자도구의 network을 보면 로드된 것을 확인할 수 있다.
  - 그러나 이제는 core-js를 쓰면 된다고 하니 corejs의 CDN도 가져오자. 
  - 나중에 웹팩 다룰 때는 regenerator-runtime도 필요하다. 둘다 CDN 가져와 작성한다.
  - 이제 하위 브라우저 호환을 해주는 코드로 컴파일할 수 있다.
- 위 내용들은 [React FAQ의 Babel, JSX, 빌드 과정들](https://reactjs.org/docs/faq-build.html#gatsby-focus-wrapper) 에서 읽을 수 있다.
  - JSX에서 주석을 쓰고 싶으면 `{/* comment */}`의 형태로 쓸 수 있다는 것도 나와있다.

### component로 쪼개주기
- 지금까지는 index.html 안에서 script 태그 안에 코드를 작성하면 babel standalone이 컴파일을 해주었다.
- 지금까지 작성한 모든 것을 src/components/App 안에 만들자
  - 아까 작성한 함수 delay는 src/utils에 timeControl/delay.js에 만들고 re-export하는 entry파일인 index.js파일도 만들어 넣어두자.
  - utils의 index.js에서 timeControl/index.js를 import해주는 것도 잊지 말기
- script 태그 안에 있던 모든 컴포넌트들을 복붙해서 client/src/components/App에 넣어준다.
  - Headline.js, Description.js, Contents.js 등으로 옮겨주는데, JSX 문법을 쓰려면 scope에 React가 있어야 한다는 lint 에러메시지가 뜬다. 이를 위해 각 파일의 상단에 `const { React } = window`를 넣어준다.
  - AppContents 빼주려는데 prop type을 지정 안했다는 lint 에러메시지가 뜬다. 지금은 무시하게끔 eslintrc.json에서 rules 항목에 `"react/prop-types":"off"`를 설정해준다.
  - App에 모두 넣은 후에는 App/index.js에서 AppContents를 import하고, TranslationButton도 import해서 return
- index.html에서 body 속에 #root 인 div 요소 빼고 다 지워주고, `<script src="./src/main.js" type="module"></script>`로 로드해준다.
  - main.js에서는 이제 ReactDOM을 통해 rendering하는 코드를 작성해준다.
```js
// src/main.js
import { App } from './components/App/index.js';
const { React, ReactDOM } = window;

ReactDOM.render(<App />, document.getElementById('root'))
```

#### babel standalone에서 CLI로 옮겨타기
- 서버를 구동하고 브라우저를 보면 콘솔에 '<'를 파싱하지 못한다는 에러가 뜬다. 이는 JSX가 비표준이라 브라우저가 해석하지 못했기 때문이다. 
  - JSX는 표준에 등재될 계획 없는, ECMAScript의 확장 문법일 뿐이다.
- 이를 parsing할 수 있게끔 babel standalone을 적용하려면 `type="text/babel"` 또는 `type="text/jsx"`을 써줘야 하는데, 그렇게 하고났더니 이제는 require의 Reference 에러가 났다.
  - babel standalone에 의해 컴파일된 결과물을 보니 require를 쓴게 보인다. 웹브라우저에서는 umd나 ESM만 인식할 수 있는데 바벨은 기본 설정인 commonJS로 컴파일했고, 브라우저는 require가 갑툭튀하니까 에러가 난것. 
  - .babelrc 파일을 열어서 ESM으로 해주게 설정해보자. "presets"의 @babel/preset-env에는 기본 설정이 commonJS로 되어있으니까 이것을 커스텀 설정인 `'modules': false`로 바꿔준다. 브라우저가 읽을 수 있게 모듈을 commonJS로 바꾸지 말아달라는 설정이다.
  ```js
  // .babelrc
    "presets": [["@babel/preset-env", { "modules": false }]],
  ```
  - 다시 돌려보면 여전히 에러가 난다. .babelrc는 노드환경에서의 설정사항일 뿐 브라우저에 적용되는 건 CDN에 의해 로드되는 babel standalone이기 때문이다. 
  - 이를 해결하기 위해서는 CDN script 태그에 옵션을 넣어주면 된다. 컴파일할 script 태그에 `data-type="module"`을 넣어주면 된다. 
  - 이제 돌려보니 다른 오류가 뜬다. src가 아닌 client를 찾는 경로 문제이다. babel standalone은 하나의 파일만 경로를 정확히 import할 수 있고 그 이후의 다른 모듈 파일들의 경로를 하나하나 수정해줘도 문제는 해결되지 않기 때문이다.
  - 그러니까 babel standalone은 이제 놓아주자. core-js랑 regenerate-runtime CDN은 그래도 놔둘 것
- 이제 webBrowser에서 컴파일하지 말고 babelCLI로 dist 파일을 만들어 써보자.
  - @babel/cli 를 설치해야 하는데, JSX도 쓰려면 이를 처리해줄 수 있는 transform plugin도 설치해줘야 한다. (바벨이 JSX를 알아서 처리해주는 게 아니다!)
  - `$ npm i -D @babel/{cli,plugin-transform-react-jsx}`로 두개의 플러그인을 한 번에 깔아줄 수 있다.
- 배포용 파일을 모두 삭제하고 다시 빌드할 필요가 있을 때 `$ rm -rf`로도 가능하지만 윈도우 유저를 위해 `rimraf`라는 패키지도 깔아주자.
- 이제 설정파일들에 이것들을 포함시켜준다. preset이 아니라 plugin을 따로 만들어준다.
  - 아까 우리가 preset-env에 이미 commonJS로 바꾸지 말라고 `"modules":false`를 써주었기 때문에 컴파일이 이제 ESM으로 된 배포파일을 만들어준다.
```js
// .babelrc
    "presets" : [ ["@babel/preset-env", { "modules": false } ]],
    "plugins" : [ "@babel/plugin-transform-react-jsx" ]
```

#### babel로 dist 폴더 빌드하기
- 바벨로 디렉토리를 컴파일해보자. (이전에는 파일만 컴파일 해보았다)
- 아까 설치한 패키지들을 잘 사용하기 위해 package.json에서 scripts에 다음과 같이 추가해보자
```js
// "scripts"
  "dev": "run-p watch:compile serve",
  "serve": "node ./server/index.mjs",
  "compile": "babel ./client/src -d ./client/dist",
  "clear": "rimraf ./client/dist",
  "watch:test": "npm t -- -watchAll",
  "watch:compile": "npm run compile -- --watch"
```
- 원래 "node ./server/index.mjs"는 dev가 하는 명령이었는데 이를 serve가 하는 거로 바꾸고, dev는 실시간으로 파일이 바뀔때마다 compile하며 serve(서버구동)를 병렬로 실행하는 것으로 추가했다. 
  -  watch를 해주고 있기 때문에 매번 컴파일할 때마다 다시 start해서 새로운창을 켜주지 않아도 된다.
- 실행해보면 dist 폴더가 생성되며 src안의 모든 파일을 다 빌드한 결과물을 갖는다. 
  - dist에 있는 js를 보면 JSX 문법으로 작성된 것도 다 React.createElement로 되어있고, require이 아니라 import로 모듈을 불러오는 것을 알 수 있다. 
- 이제 script태그의 경로와 type을 바꿔주자.
  - 경로는 dist/main.js로 바꿔준다. (src/main.js로 로드하면 JSX가 바벨로 컴파일 안됐기 때문에 '<' 파싱 못한다는 에러가 뜬다) 
  - type은 babel standalone 쓰느라 `type="text/babel"`로 해두었던 것을 다시 `type="module"`로 바꿔준다.
  - 이제 드디어 에러 없이 컴포넌트 렌더링 성공!

#### 방금 했던 것 다시 한 번 복습
- standalone babel은 단 하나의 파일만 compile하며, 여러개로 나눠진 모듈파일의 경로문제를 해결하지 못했다.
- 이때문에 @babel/cli를 통해 배포용 파일을 만들기로 했으니 @babel/cli를 설치했다.
- 바벨의 기본 설정에는 JSX를 컴파일하는 게 없기 때문에 plugin(@babel/plugin-transform-react-jsx)도 설치하고 .babelrc에 이것저것 설정도 해주었다. 
  - preset-env에 module을 commonJS로 못바꾸게끔 false 로 기재
  - plugin에 위 플러그인을 기재
- 아직 웹팩을 쓰지 않기 때문에 여러개 파일을 번들링하지 않고 브라우저의 ESM모듈에 의존하고 있다.
  - 컴파일된 dist/main.js를 index.html에서 모듈 방식(type="module")으로 로드한다. 
  - 바벨은 번들러가 아니므로 컴파일만 하고, 컴파일된 여러개의 모듈은 브라우저가 읽어온다.
  - 이 여러 개의 모듈을 읽어오는 과정에서 babel standalone은 경로문제가 생겨서 cli로 한 것이었다.
