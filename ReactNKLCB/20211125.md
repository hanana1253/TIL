# React 

## 인상 깊은 조언

## 수업

### Miscellany
- Web의 가장 큰 장점이자 단점이 바로 보편성인데, 모든 웹브라우저에 대해 동작해야 하므로 class를 지원하거나 지원하지 않는 브라우저를 모두 대응해야 한다.
- transpiler vs. compiler: 같은 언어의 다른 버전으로 바꿔주는 것이 transpile, 다른 언어로 바꿔주는 것이 compile이지만 같은 언어의 경우에도 transpile이라고 하기도 한다.
  - 바벨은 컴파일러이지만 ES5 이하 문법으로 바꿔주려면 `preset-env`로 해줘야 한다.
- overload: 전달된 인자의 유형에 따라 다른 동작을 하는 함수.

### React의 특징
1. 선언형(Declarative)
- 명령형 vs. 선언형
  - 명령형은 하나하나 명령하는 과정, how가 코드에 드러난다.
    - js는 일반적으로 명령형 (Document에서 querySelector로 찾은 요소에 onClick에 이 함수를 등록해줘)
  - 선언형은 과정은 필요없고 결과만 중요하다.
    - HTML도 선언형이다. parser에게 선언(lang은 ko, DOCTYPE은 이것이다 선언 등)

2. 콤포넌트(Component) 
- 재사용을 손쉽게 할 수 있도록

3. 한번 배우면 어느 환경에서도 쓸 수 있다.
- 2015년 class가 등장하면서 React Native를 공개했다. 
- React Native나 Electron 등으로 모바일 / 데스크탑 어플리케이션 등 멀티플랫폼을 지원한다. 

### React의 역사
- 2016년 v15
  - SVG(Scalable Vector Graphic) 속성을 지원한다. 
  - vector는 zoom해도 다시 계산하여 보여주기 때문에 깨지지 않는다. (c.f. bmp)
- 2017년 v16
  - Error Boundary: 이벤트위임처럼 에러 처리도 부모에게 걸어 하위 모든 콤포넌트에서 온 에러를 캐치
  - Portal(표준명칭은 slot): HTML에서 alert modal dialog과 같이 다른 정보들이 dimmed되고 독립적으로 시선을 집중시켜야 하는 경우를 구현하기 위해 Portal이 등장
  - Reconciliation (재조정 알고리즘)을 획기적으로 업데이트하며 Fiber라고 명명.
- 2018년: 리액트를 비롯해 모든 도구는 '잘' 써야 성능이 좋아지는데, 이런 문제진단하고 개선할 수 있는 React Profiler 제공
- 2019년: React Hooks 공개
- 2020년: 디딤돌 업데이트, 하위호환을 염두에 두겠다는 의중을 밝힘

### jQuery 맛보기
- `$`(팩토리함수)는 overload 함수, 즉 전달되는 인자에 따라 달리 동작하는 함수
  - 선택자 string을 전달하면 해당 요소를 찾아와 jQuery instance로 만들어 반환한다.
```js
const $btn = $('.highlightButton');
// 'on' 메서드로 click event에 이벤트핸들러 등록 (c.f. 'off'로는 이벤트핸들러 해제)
$btn.on('click', function () {
    var $this = $(this); // 여기서의 this는 $btn을 가리키며, 이벤트핸들러가 등록된 요소이다.
    $this.toggleClass('highlight'); // jQuery의 toggleClass === Javascript의 classList.toggle
    $this.text() === '하이라이트 추가' ? $this.text('하이라이트 제거') : $this.text('하이라이트 추가');
    // jQuery에서 text는 get으로도 set으로도 사용할 수 있는, textContent와 동일한 역할
}); 
```
- jQuery의 이벤트핸들러로 전달하는 함수 안에서 this는 이벤트핸들러가 등록된 요소이다. `$`에 전달하면 해당 요소를 jQuery instance로 반환한다.
> When jQuery calls a handler, the this keyword is a reference to the element where the event is being delivered; for directly bound events this is the element where the event was attached and for delegated events this is an element matching selector. (Note that this may not be equal to event.target if the event has bubbled from a descendant element.) (출처: jQuery 공식문서)

### 실습환경 설정
- 선생님 레포 fork하여 clone

#### package.json scripts 뜯어보기
- node, npm, npx, git, code 버전을 터미널에서 확인하면서 잘 깔려있는지 확인하자.
  - code 버전 확인할 때 안 깔려있는 거로 나오면 vscode에서 cmd+shift+p로 shell command 검색해 사용하도록 설정 
- `$ npm install`하여 패키지를 깔자
- `"start": "npm run dev:compile-watch & npm run dev:server-open"`: `dev:compile-watch` 명령어와 `dev:server-open`을 실행한다
- `"dev:compile-watch": "npm run dev:compile -- -w"`: `dev:compile`이라는 또다른 script 명령어를 실행하면서 `-w` 옵션을 주려면 `--`를 넣어준다.
- `"dev:compile": "babel ./client/src/main.js -o ./client/js/main.js"`: 'client/src/main.js' 파일을 'client/js/main.js'라는 파일로 트랜스파일해준다.
- `"dev:server-open": "OPEN=/client npm run dev:server"`: `OPEN=/client`로 환경변수 설정후 dev:server 명령어 실행
- `"dev:server": "node server/index"`: server/index.js 실행

### 실습하기
- src/main.js 에는 textFormatting과 throwError라는 utility 함수가 있고, translator라는 객체가 있다.
- 이를 (1) js로, (2) jQuery로, (3) class문법으로, (4) ES모듈로 뷰에 반영하는 것이 미션!

#### jQuery로 해보기
- CDN(Content Delivery Network)을 사용하면 실제 리소스를 다운받지 않고도 unpkg.com을 통해 node.js에 있는 패키지들을 사용할 수 있다. 
- index.html에 `<script src="https://unpkg.com/jquery@3.6.0/dist/jquery.js"></script>` 써주기
- 그 아래에 컴파일된 `client/main.js` 불러오도록 script 태그도 써주고, defer 키워드는 따로 안 써줘도 되는데, 이는 jQuery에서 알아서 DOMContentLoaded 이후 동작하게 해주기 때문? (못 알아들었음 추후 확인 필요)
  - `$ npm start`로 서버와 클라이언트 컴파일 워치 모두 돌리고 네트워크나 콘솔에서 jQuery 로드되었는지 확인한다.
  - `window.jQuery`나 `window.$`를 찍어주면 확인이 가능하다.
- main.js에서 이제 jQuery로 작업을 해보자. 일단 window 객체 안에 jQuery가 있는지 확인하는 if문으로 감싸준다.
```js
if ('jQuery' in window) {
    const { jQuery } = window;
    jQuery(document).ready(translatorApp);
}
```
- jQuery를 디스트럭처링 할당으로 꺼내와 호출하는데, 이 때 인자로는 문자열, DOM 요소, 배열, 함수 등을 모두 전달할 수 있다. 
  - ready 메서드는 DOMContentLoaded와 동일한 작동을 하며, 인자로 전달하는 함수(translatorApp)에게 jQuery 인스턴스를 전달하며 호출한다.
  - 이제 translatorApp을 만들자. 먼저 버튼요소를 가져와 클릭이벤트에 handleTranslation 이벤트 핸들러를 등록해준다.
```js
if ('jQuery' in window) {
    const { jQuery } = window;

    const translatorApp = $ => {
        const $btn = $('.button__translation');
        $btn.on('click', handleTranslation);
    }

    jQuery(document).ready(translatorApp);
}
```
- 이제 handleTranslation 함수를 만들어준다. 먼저 translator 객체에 있는 language mode 토글해주고, UI에 바뀐 language mode에 맞는 내용을 반영하는 함수(renderUpdatedUI)를 만들고 호출해주기까지 하자.
```js
// if문과 translatorApp 함수 내부

const handleTranslation = () => {
    translator.toggleLanguageMode();
    renderUpdatedUI();
}

const renderUpdatedUI = () => {
    const { headline, description } = translator.getContents();
    $('.contents').find(':header').text(headline);
    $('.contents').find('p').text(description);
}
```
- 특정 요소에 바인딩된 jQuery instance에 find 메서드를 쓰면 해당 요소 안에서 jQuery instance를 찾아 반환하며, 이 때 선택자 뿐 아니라 ':header'로 헤딩 태그 요소를 찾을 수도 있다.  
  - 팩토리 함수의 첫, 두번째 인자로 선택자를 넣는 방법(`$(':header', '.contents').text(headline)`)도 동일하게 동작한다.
- renderUpdatedUI할 때 보이는 것 뿐 아니라 보이지 않는 것도 바꿔주어야 한다. 버튼의 툴팁같은 것들.
  - attribute를 바꾸기 위해서는 attr라는 메서드를 사용하며, 인자를 하나만 전달하면 해당 어트리뷰트 값을 조회하는 getter 함수로 동작하고, 바꿀 어트리뷰트의 속성과 값을 문자열형태로 두개 전달하면 그 값으로 set해준다. 여러개인 경우 객체로 넘길 수도 있다. 
```js
const renderUpdatedUI = () => {
    // headline, description 세팅 생략
    const label = translator.getLabel();
    $btn.attr('title', label);
    $btn.attr('aria-label', label);
    // 또는 $btn.attr({title: label, 'aria-label': label})
}
```