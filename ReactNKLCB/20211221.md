# React

## 지난 시간 복습
- 파일명과 해시문자열을 넣은 className을 동적으로 부여하여 컴포넌트가 로컬스코프를 갖는 것처럼 CSS를 사용하도록 해주는 모듈 CSS 방식 (해시값은 css-loader가 부여해준다)
  - 이를 통해 컴포넌트의 독립적 스타일을 고수할 수 있다.
- 화살표함수로 컴포넌트를 정의한 경우 컴포넌트 이름이 anonymous로 나와서 디버깅하기 힘들다. displayName으로 이름을 설정해주거나 named function으로 정의해주자.
- 리액트 컴포넌트가 필수적으로 갖는 static property: displayName, defaultProps, propTypes

## Prop types
- 우리는 prop type check를 안하는 것으로 설정해두었었지만 원래는 prop type를 조건처리문으로 검사해주어야 한다.
- 컴포넌트의 propTypes라는 객체 속에 prop이름과 동일한 메서드를 정의하면 인자로 props, propName, componentName이 들어온다. 
- type을 체크해주고 객체인지 확인해주는 유틸함수를 활용한다.

```js
import style from './Heading.module.css';
import { typeIs, isString } from '../utils';

const Heading = ({ as: Comp, className, children, ...restProps }) => {
  return (
    <Comp className={classNames(styles.headline, className)} {...restProps}>
      <span className={styles.SK}>SK</span>
      <span className={styles.title}>{children}</span>
    </Comp>
  );
};

Heading.propTypes = {
    as(props, propName, componentName) {
        if (!isString(props[propName])) {
            throw new Error(`${componentName} 컴포넌트에 전달된 ${propName}은 string이어야 합니다.
                전달된 prop은 ${typeIs(props[propName])}입니다`);
        }
        if (isUndefined(props[propName])){
            throw new Error(`${componentName} 컴포넌트에 ${propName}은 필수 항목입니다.`);
        }
    },
    // ...
}
```
- propTypes 유틸을 따로 빼서 넣어주는 것이 더 용이할 수도 있다. 
  - 메서드는 결국 해당 함수이름를 키로 하는 프로퍼티의 값으로 함수가 오는 것이므로 propTypes 유틸에서 만들어둔 객체 속 메서드를 전달해주면 props, propName, componentName을 받아 처리하게 한다.
```js
// utils/propTypes.js

export const propTypes = {
    string(props, propName, componentName) {
    let value = props[propName];
    if (!isString(value)) {
      throw new Error(
        `${componentName} 컴포넌트에 잘못된 ${propName} prop이 전달되었습니다.`
      );
    }
  },
};

// Heading.js
import { propTypes } from 'utils';

const Heading = ({ as: Comp, className, children, ...restProps }) => {
    // ...
};

Heading.propTypes = {
    as: propTypes.string,
    // ...
}
```
- 타입스크립트를 쓴다면 이런 것을 할 필요가 없지만 우리는 JS니까 해줘야 한다.

## Dialog: modal 만들기

### Tabbable vs. Focusable
- tabbable element는 사용자가 tab 키를 통해 접근할 수 있는 요소이다.
  - tabindex에 0 또는 양수 값을 갖는 요소 및 focus가 기본적으로 가능한 form 요소들이 있다.
  - 그렇다면 focusable과는 어떤 차이가 있을까?
  - tabindex에 -1을 주면 사용자가 tab키로 접근할 수는 없지만 js를 통해 `focus()`로 포커스를 줄 수는 있다.
- 위와 같이 focusable 요소는 사용자가 tab키로 접근할 수는 없지만 js를 통해 focus를 줄 수 있는 요소까지를 포함한다.
  - href 어트리뷰트를 갖는 a와 area 태그
  - button, input, select, textarea, iframe 요소
  - control 어트리뷰트를 갖는 video, audio 요소
  - summary, details 요소
  - tabindex, contenteditable 어트리뷰트를 갖는 경우
- 위에 해당하는 요소들을 모두 querySelectorAll로 찾아와서, 모달창 안에서만 키보드 네비게이션이 돌도록 작업해줄 것이다.

### KeyBoard Trap 만들기
- esc 키를 누르면 닫히고 모달 다이얼로그 열기 버튼에 focus를 가게 해줄 것이다.
- 먼저 focusable 요소인지 판별하는 유틸함수를 만든다. (왜 focusable element를 데려와서 이걸 다시 하는 것일지 야무님께 물어보기) 
- 초점 이동 가능한 HTML 요소들을 모두 가져와 focusable인지 확인 후 배열에 넣는 유틸함수를 만들고, 이 배열의 처음과 끝에 해당하는 요소들에서 tab 또는 shift+tab을 눌렀을 때 서로에게 focus가 가도록 해준다.
- ref의 current에서 자기 자손 요소들의 focusable 요소를 모두 가져와 배열로 받아온다.
- firstFocusableElement와 lastFocusableElement를 배열의 0번 인덱스와 length-1번 인덱스로 받아 할당한다.