# React

## 지난 시간 복습 및 수습
- 설치한 패키지인 jest의 함수들(test, expect)에 대해서 eslint가 자꾸 defined된 함수 아니라며 빨간 줄 띄운다.
  - 보기싫으니 이를 막아주기 위해 eslintrc.js에서 `"globals/jest": true`로 했다가 안돼서 결국 `globals: { jest: true },`로 넣어주었는데, "globals/jest"가 아니라 "jest/globals"로 했어야 했다.

## preparing-for-react TEST with Jest
- test파일을 이전에는 `~.test.js`로 파일명을 설정하여 jest의 테스트 대상에 포함시켰는데, 이제는 src 폴더 안에 `__tests__`라는 폴더를 만들어 그 안에 js 파일로 저장한다. 
  - jest.config.mjs 파일 안에 아래와 같이 설정해주었기 때문에 tests 폴더 안에 있는 js파일을 다 테스트해준다.
```
  testMatch: ['**/__tests__/**/*.[jt]s?(x)', '**/?(*.)+(spec|test).[tj]s?(x)'],
```
- package.json에서 scripts로 테스트 설정하기
  - `"test": "jest ./client"` 말고 `"test": "jest"`로만 해도 된다. 
  - `"watch:test": "npm test -- --watchAll"`로 설정하면 지난 시간 "watch:**"로 설정한 watch 명령어에서 lint와 prettier, jest 모두 돌아간다.
  - 하나의 파일만 test하고 싶으면 `jest getrandom`으로 하면 되고(`$ npm test getrandom`), 이 경우 description으로 넣은 텍스트도 보여진다.

### DOM TEST를 node.js 환경에서 하기 (+ matcher function 확장)
- getRandom 처럼 단순한 함수는 node.js에서 결과확인이 가능했지만, domTest에 있는 테스트들은 서버를 돌리면서 브라우저에서 콘솔을 열어 테스트 결과를 확인했었는데, jest로는 html문서가 따로 없는데 어떻게 테스트할 수 있을까?
- utils 속에 dom이라는 폴더를 만들고 특정 노드에 클래스 추가해주는 함수 addClass를 js파일에 틀만 만들어주자.
  - 메서드 체이닝을 해서 후속 작업 할수 있도록 node를 반환해주는 것까지만 함수를 만들어두자
```js
// utils/dom/addClass.js
export const addClass = (node, ... classNames) => {
    return node;
}
```
- 테스트 코드를 먼저 만들어주자
```js
// utils/__tests__/addClass.js
import { addClass } from '../dom/addClass.js';

test(`addClass(document.body, 'some') 실행시 document.body는 'some'이라는 클래스를 소유합니다.`, ()=> {
    const addedClassName = 'some';
    expect(addClass(document.body, addedClassName)).toHaveClass(addedClassName);
})
```
- 실행해보면 toHaveClass가 함수가 아니라는 에러가 난다. 우리가 지난 시간 직접 만든 test 라이브러리에는 있지만 jest 자체에서는 toHaveClass라는 메서드를 제공하지 않기 때문이다. 
  - 이를 해결하려면 (1) toHaveClass 메서드 없이 toBeTruthy로 테스트할 수 있는 로직을 작성하거나 (2) toHaveClass 메서드를 제공하는 jest 확장하는 플러그인 사용하거나

1. jest 확장 사용 없이 toBeTruthy로 해보자
```js
// utils/__tests__/addClass.js
test(`addClass(document.body, 'some') 실행시 document.body는 'some'이라는 클래스를 소유합니다.`, ()=> {
    const addedClassName = 'some';
    addClass(document.body, addedClassName);
    expect(document.body.classList.contains(addedClassName)).toBeTruthy();
})
```
  - 이제 test를 돌려보면 addClass 함수 로직이 안 짜여져 있어서 received가 false라고 나온다. 그러니까 이제 addClass 함수를 만들어주자.
    - 노드가 있고, classList라는 프로퍼티를 가진다면 classList에 받은 class를 add해준다.
```js
// utils/dom/addClass.js
export const addClass = (node, ... classNames) => {
    if (node && 'classList' in node) {
        node.classList.add(...classNames);
    }
    return node;
}
```
- 이제 테스트 해보면 성공한 것을 알 수 있다.
- 문서의 특정 노드에 접근하여 클래스이름 설정해보자. 테스트 코드 먼저 짠다.
```js
// utils/__tests__/addClass.js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {
    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode.classList.contains(addedClassName)).toBeTruthy();
})
```
- 테스트를 돌리면 getElementById라는 함수를 호출할 수 없다고 뜰거다(근데 우리는 이미 'jsdom'으로 설정해둬서 안뜸).
  - ( testEnvironment: 'jsdom'을 주석처리하니까 getElementById가 아니라 document not found라고 뜸. 선생님께 문의 예정 )
  - jest가 돌아가는 node.js 환경에서는 web browser이 아니므로 getElementById를 제공하지 않기 때문이다.
  - jest.config.mjs에서 `testEnvironment: "jsdom"`를 써주면 node.js환경에서도 dom테스트를 할 수 있다.
  - 과연 node.js환경에서 jest를 통해 문서에 접근할 수 있는지 확인해보자.
- jsdom으로 하면 appNode가 null이기 때문에 null의 'classList'를 참조할 수 없다는 에러가 뜬다. 
  - appNode를 만들어 준 후 작업해보자.
```js
// utils/__tests__/addClass.js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {

    document.body.innerHTML = `<div id="app"></div>`

    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode.classList.contains(addedClassName)).toBeTruthy();
})
```
- 이렇게 하면 가상으로 만든 dom에서 문서에 접근하는 테스트를 돌릴 수 있다.
- 꿀팁: 벡틱 안의 html에도 emmet abbreviation과 알록달록한 색깔을 입혀주고 싶으면 es6-string-html이라는 vscode extension을 설치 후 벡틱 앞에서 `/* html */` 주석을 사용해주면 된다.

2. 이번에는 jest를 확장하여 사용해보자
- 확장하는 도구인 `@testing-library/jest-dom` 패키지를 보면, dom의 상태테스트를 위한 jest의 custom matcher function들을 확장시켜준다는 설명이 있다. 
  - `$ npm i -D @testing-library/jest-dom`으로 설치
  - toHaveClass와 같이 DOM test에 도움이 되는 matcher functions로 더 편하게 test코드를 작성할 수 있다.
- 또한 jest-dom 사용법을 보면 eslint plugin인 'jest-dom'도 설치하기를 권장하고있다. 
  - `$ npm i -D eslint-plugin-jest-dom`으로 설치
  - eslintrc.js에서 plug-in에 'jest-dom' 추가해주고
  - extends에서도 'plugin:jest-dom/recommend' 넣어준다.
  - 이제 이 프로젝트에서 eslint가 jest-dom을 인식해준다. 
- 확장도구를 설치만 했지 연결을 해주지 않았다. 사용하기 위해서는 불러와야만 한다.
  - 프로젝트 루트에 setup파일을 만들고(jest.setup.mjs) `import '@testing-library/jest-dom'`
  - 이제 jest.config.js에서 setupFilesAfterEnv에 './jest.setup.mjs'를 넣어주면 모든 설정 완료된 후 이 setting도 하겠다는 뜻이다.
  - 이제 실행해보았는데 에러가 난다. 모듈파일인데도 import를 인식하지 못하기 때문. (WHY????? 질문하기) 
    - 'jest.setup.mjs'를 'jest.setup.cjs'로 바꾸고 내용을 `require('@testing-library/jest-dom')`으로 해주자.
    - jest.config.js 파일에서도 확장자명 바꿔주고 다시 실행하면 된다.
- jest-dom 실행에 성공하면 toHaveClass를 써보자. test폴더의 addClass.js에서 아래와 같이 써보자
```js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {

    document.body.innerHTML = `<div id="app"></div>`

    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode).toHaveClass(addedClassName);
}) 
```
- 이렇게 하면 장황하지 않게 DOM 테스트코드를 작성하는 것에 성공

## React app을 브라우저에서 렌더링하기
- 선생님 레포의 render-react-browser branch를  pull 후 `$ npm install`로 필요한 패키지들을 깔아주자.
- 갑작스럽지만 jQuery 패키지의 파일구조를 [unpkg.com의 jQuery](https://unpkg.com/browse/jquery@3.6.0/)에서 보자.
  - jQuery의 시대에는 ESM이 없었기 때문에, 각각의 모듈 폴더와 그 폴더 상위경로의 entry 파일들이 amd진영의 방식(define)으로 모듈을 로드하고 있는 것을 확인할 수 있다.
  - 현재 표준인 ESM 중심으로 공부하면 되지만 amd 방식이 있다는 것과, 이런 패키지가 모듈로 구성되고, 모듈을 불러오는 식으로 개발할 때 사용된다는 것을 기억하자.
- index.html 12번째 줄(엔트리파일 utils/index.js를 로드하는 script 태그)을 지워준다. 
  - network 탭을 보면 index.js를 로드하면서 각각 쪼개진 수많은 모듈을 가져오기 때문이다.(jQuery처럼 하나로 뭉쳐준 dist 파일이 아니라...)
  - 이 대신 `<script type="module" src="./src/main.js"></script>`를 추가해준다. 

### React와 비슷한 utility 만들어보기
- React가 제공하는 createElement와 유사한 utility를 표준 DOM API를 활용하여 직접 만들어보자.
- src/main.js는 모듈파일이라 IIFE로 해줄 필요가 없다. 모듈파일은 스코프가 캡슐화되어있기 때문이다.
- 이제 동적으로 추가할 노드를 작성해보자. 전에 translator 객체로 만들었던 내용 그대로 해보자.
  - 먼저 node를 만들고 'contents'라는 class를 주고, lang 어트리뷰트에 'en'을 넣어주어야 한다.
  - console.log로 찍어보면 html 태그가 잘 만들어졌다.
  - 이제 이것을 #app 노드의 자식노드로 추가해주자.
```js
// main.js
const contentsNode = document.createElement('div');

contentsNode.classList.add('contents');
contentsNode.setAttribute('lang', 'en');

console.log(contentsNode);

const appNode = document.getElementById('app');
appNode.appendChild(contentsNode);
```
- 위와 같이 노드를 만들어 추가하고 어트리뷰트들을 넣어주는 것을 함수로 만들어보자
  - document.createElement에 전달할 수 있는, 어떤 노드를 만들 것인지 결정하는 type을 인자로 받는다. 
  - 노드가 가질 어트리뷰트들을 props라는 매개변수를 통해 객체 형태로 받고, 이를 bindProps라는 또다른 함수로 세팅해주자
  - 이 때 class는 js에서 예약어이기 때문에 props의 key로 바로 사용하지 말고 className이라는 키로 넘겨야 한다. 이를 처리하는 if문을 하나 만들어주자. 
```js
// main.js
function bindProps(node, props) {
    if (props) {
        Object.entries(props).forEach(([key, value]) => {
            if (key === 'className') {
                key = 'class';
            }        
            node.setAttribute(key, value);
        })
    }
}

function createElement(type, props) {
    const node = document.createElement(type);
    bindProps(node, props);
    return node;
}

const contentsNode = createElement('div', { className: 'contents', lang: 'en' })
const appNode = document.getElementById('app');
appNode.appendChild(contentsNode);
```

### React가 제공하는 createElement 사용해보기
- 이제 드디어 react를 써보자. index.html의 body 안에 `<div id="root"></div>`를 만들어준다.
- 이번에도 갑작스럽지만 [unpkg.com에서 react의 파일구조](https://unpkg.com/browse/react@17.0.2/)를 보면, umd 폴더가 있다. 
  - 우리는 배포할게 아니기 때문에 development 버전으로 CDN script를 head 태그 안에 작성해주자.
- body 태그 안에 script 태그, 그 안에 renderReactApp이라는 즉시실행함수를 만들어주자.
  - 매개변수에 global, react를 받고 즉시실행함수의 호출연산자에 인자로 window와 window.React를 전달한다.
  - `'use strict'`로 스트릭트 모드 설정해주고, React가 가진 메서드 createElement를 구조분해할당으로 h라는 식별자로 받아온다.
  - h(createElement)는 필수인자인 type과 선택사항인 props, children을 인자로 받아 React element를 반환하는 API이며, virtual dom의 요소가 된다. 
    - [React document의 createElement](https://reactjs.org/docs/react-api.html#createelement)를 읽어보면 첫 인자로는 세 가지 종류를 전달할 수 있다.
    - (1) 문자열: 'div', 'span' 등의 문자열을 전달하면 표준 HTML 태그의 타입으로 인식하여 해당 요소에 해당하는 react element를 반환
    - (2) React Component 함수참조: react element를 반환하는 함수를 호출하지 않고 참조로 전달하면 해당 react element를 반환
    - (3) React Fragment: 나중에 살펴보자

```js
// index.html 의 body 내부 script 태그 (CDN으로 React를 import한 상태)

(function renderReactApp(global, React) {
    const { createElement: h } = React;

    const contentsElement = h('div', { className: 'contents', lang: 'en' });
    console.log(contentsElement);
})(window, window.React)
```
- 이렇게 console.log를 찍어보면 리액트 요소라는 것 외에 기타 정보와 props들을 알 수 있다. 
  - `$$typeof: Symbol(react.element)`: react element라는 정체성
  - `type: "div"`: div 태그
  - `props: { className: "contents", lang: "en" }`: 내가 두번째 인자로 전달한 props
- 이제 h1과 p 태그도 가상노드로 만들어보자.
  - createElement에 세 번째 인자로 children으로 오는 요소를 전달할 수 있다. 문자열로 전달하면 텍스트노드가 자식요소로 생긴다.
  - props를 전달 안할거면 두번째 인자에 null을 주고, 세 번째 인자로 문자열 바로 준다.
```js
const headlineElement = h('h1', null, '선언형 프로그래밍이란');
const descriptionElement = h('p', null, '선언형 프로그래밍에 대한 설명 블라블라');
```
- 아까 만든 contentsElement에 세 번째 이후의 인자로 전달하면 전달된 react element들이 props 안에 children이라는 키의 값에 h1과 p가 배열 속에 각각의 객체(한 개인 경우 배열 없이 하나의 객체)로 들어간다.
```js
(function renderReactApp(global, React) {
    const { createElement: h } = React;

    // ...

    const contentsElement = h('div', { className: 'contents', lang: 'en' }, headlineElement, descriptionElement );
})(window, window.React)
```

### ReactDOM으로 virtual DOM을 actual DOM에 mounting 
- virtual DOM의 정체는 이렇게 추상화된 객체, 실제 DOM과 유사하게 표현된 객체이다.
  - 이를 실제 DOM에 붙이는 건 React의 능력이 아니다. React는 정보객체를 만들어 내는 것 뿐, 이를 해석해내는 건 웹이나 모바일 별로 별도의 라이브러리가 수행한다.
  - virtual DOM은 무거운 actual DOM과 달리 필요한 정보만 가진 가벼운 객체. 
  - 이를 그림으로 그려내는 것은 render라는 함수가 하는데, 이 함수는 웹의 경우 ReactDOM이, 모바일은 React Native가, 데스크탑 앱의 경우 Electron이 제공한다.
- 이제 우리는 ReactDOM이라는 라이브러리를 필요로 하므로 이를 load하는 CDN 스크립트 태그를 head에 넣어주자
  - 즉시실행함수에서 세 번째 매개변수에 ReactDOM을 받고 호출연산자에 인자로 window.ReactDOM을 넘겨준다.
- `ReactDOM.render`라는 API를 활용하여 mount할 때 전달할 인자는 다음과 같다.
  - 첫 번째 인자로는 붙여줄 가상돔노드(virtual node)인 contentsElement를 전달한다.
  - 두 번째 인자는 index.html에 존재하는 실제 DOM노드인 root div 요소를 전달한다.
  - 세 번째 인자로는 mounting 후 호출할 callback함수를 전달할 수 있는데, 우리는 console.log로 성공메시지 띄우자.
```js
(function renderReactApp(global, React, ReactDOM) {
    const { createElement: h } = React;
    // ... h1과 p 선언 및 할당
    const contentsElement = h('div', { className: 'contents', lang: 'en' }, headlineElement, descriptionElement );

    ReactDOM.render(contentsElement, document.getElementById('root'), () => {
        console.log('successfully mounted');
    })
})(window, window.React, window.ReactDOM);
```
- 이제 성공적으로 실제 DOM에 붙어 렌더링 되는 것을 확인할 수 있다.
- ReactDOM이 제공하는 또다른 API들
  - `hydrate`는 서버사이드렌더링을 통해 렌더링 된 컨테이너에 이벤트를 보충할 때 사용
  - 'createPortal`는 나중에 한 번 portal할 때 사용해볼 것
- 결론: React는 추상화된 객체인 Virtual DOM Node를 만들고, ReactDOM은 Virtual DOM node를 가지고 actual DOM에 붙인다.

### 