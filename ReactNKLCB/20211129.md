# React

## 지난 시간 복습 및 수습
- 설치한 패키지인 jest의 함수들(test, expect)에 대해서 eslint가 자꾸 defined된 함수 아니라며 빨간 줄 띄운다.
  - 보기싫으니 이를 막아주기 위해 eslintrc.js에서 `"globals/jest": true`로 했다가 안돼서 결국 `globals: { jest: true },`로 넣어주었는데, "globals/jest"가 아니라 "jest/globals"로 했어야 했다.

### preparing-for-react
- test파일을 이전에는 `~.test.js`로 파일명을 설정하여 jest의 테스트 대상에 포함시켰는데, 이제는 src 폴더 안에 `__tests__`라는 폴더를 만들어 그 안에 js 파일로 저장한다. 
  - jest.config.mjs 파일 안에 아래와 같이 설정해주었기 때문에 tests 폴더 안에 있는 js파일을 다 테스트해준다.
```
  testMatch: ['**/__tests__/**/*.[jt]s?(x)', '**/?(*.)+(spec|test).[tj]s?(x)'],
```
- package.json에서 scripts로 테스트 설정하기
  - `"test": "jest ./client"` 말고 `"test": "jest"`로만 해도 된다. 
  - `"watch:test": "npm test -- --watchAll"`로 설정하면 지난 시간 "watch:**"로 설정한 watch 명령어에서 lint와 prettier, jest 모두 돌아간다.
  - 하나의 파일만 test하고 싶으면 `jest getrandom`으로 하면 되고(`$ npm test getrandom`), 이 경우 description으로 넣은 텍스트도 보여진다.

#### DOM TEST
- getRandom 처럼 단순한 함수는 node.js에서 결과확인이 가능했지만, domTest에 있는 테스트들은 서버를 돌리면서 브라우저에서 콘솔을 열어 테스트 결과를 확인했었는데, jest로는 html문서가 따로 없는데 어떻게 테스트할 수 있을까?
- utils 속에 dom이라는 폴더를 만들고 특정 노드에 클래스 추가해주는 함수 addClass를 js파일에 틀만 만들어주자.
  - 메서드 체이닝을 해서 후속 작업 할수 있도록 node를 반환해주는 것까지만 함수를 만들어두자
```js
// utils/dom/addClass.js
export const addClass = (node, ... classNames) => {
    return node;
}
```
- 테스트 코드를 먼저 만들어주자
```js
// utils/__tests__/addClass.js
import { addClass } from '../dom/addClass.js';

test(`addClass(document.body, 'some') 실행시 document.body는 'some'이라는 클래스를 소유합니다.`, ()=> {
    const addedClassName = 'some';
    expect(addClass(document.body, addedClassName)).toHaveClass(addedClassName);
})
```
- 실행해보면 toHaveClass가 함수가 아니라는 에러가 난다. 우리가 지난 시간 직접 만든 test 라이브러리에는 있지만 jest 자체에서는 toHaveClass라는 메서드를 제공하지 않기 때문이다. 
  - 이를 해결하려면 (1) toHaveClass 메서드 없이 toBeTruthy로 테스트할 수 있는 로직을 작성하거나 (2) toHaveClass 메서드를 제공하는 jest 확장하는 플러그인 사용하거나

1. jest 확장 사용 없이 toBeTruthy로 해보자
```js
// utils/__tests__/addClass.js
test(`addClass(document.body, 'some') 실행시 document.body는 'some'이라는 클래스를 소유합니다.`, ()=> {
    const addedClassName = 'some';
    addClass(document.body, addedClassName);
    expect(document.body.classList.contains(addedClassName)).toBeTruthy();
})
```
  - 이제 test를 돌려보면 addClass 함수 로직이 안 짜여져 있어서 received가 false라고 나온다. 그러니까 이제 addClass 함수를 만들어주자.
    - 노드가 있고, classList라는 프로퍼티를 가진다면 classList에 받은 class를 add해준다.
```js
// utils/dom/addClass.js
export const addClass = (node, ... classNames) => {
    if (node && 'classList' in node) {
        node.classList.add(...classNames);
    }
    return node;
}
```
- 이제 테스트 해보면 성공한 것을 알 수 있다.
- 문서의 특정 노드에 접근하여 클래스이름 설정해보자. 테스트 코드 먼저 짠다.
```js
// utils/__tests__/addClass.js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {
    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode.classList.contains(addedClassName)).toBeTruthy();
})
```
- 테스트를 돌리면 getElementById라는 함수를 호출할 수 없다고 뜰거다(근데 우리는 이미 'jsdom'으로 설정해둬서 안뜸).
  - ( testEnvironment: 'jsdom'을 주석처리하니까 getElementById가 아니라 document not found라고 뜸. 선생님께 문의 예정 )
  - jest가 돌아가는 node.js 환경에서는 web browser이 아니므로 getElementById를 제공하지 않기 때문이다.
  - jest.config.mjs에서 `testEnvironment: "jsdom"`를 써주면 node.js환경에서도 dom테스트를 할 수 있다.
  - 과연 node.js환경에서 jest를 통해 문서에 접근할 수 있는지 확인해보자.
- jsdom으로 하면 appNode가 null이기 때문에 null의 'classList'를 참조할 수 없다는 에러가 뜬다. 
  - appNode를 만들어 준 후 작업해보자.
```js
// utils/__tests__/addClass.js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {

    document.body.innerHTML = `<div id="app"></div>`

    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode.classList.contains(addedClassName)).toBeTruthy();
})
```
- 이렇게 하면 가상으로 만든 dom에서 문서에 접근하는 테스트를 돌릴 수 있다.
- 꿀팁: 벡틱 안의 html에도 emmet abbreviation과 알록달록한 색깔을 입혀주고 싶으면 es6-string-html이라는 vscode extension을 설치 후 벡틱 앞에서 `/* html */` 주석을 사용해주면 된다.

2. 이번에는 jest를 확장하여 사용해보자
- 확장하는 도구인 `@testing-library/jest-dom` 패키지를 보면, dom의 상태테스트를 위한 jest의 custom matcher function들을 확장시켜준다는 설명이 있다. 
  - `$ npm i -D @testing-library/jest-dom`으로 설치
  - toHaveClass와 같이 DOM test에 도움이 되는 matcher functions로 더 편하게 test코드를 작성할 수 있다.
- 또한 jest-dom 사용법을 보면 eslint plugin인 'jest-dom'도 설치하기를 권장하고있다. 
  - `$ npm i -D eslint-plugin-jest-dom`으로 설치
  - eslintrc.js에서 plug-in에 'jest-dom' 추가해주고
  - extends에서도 'plugin:jest-dom/recommend' 넣어준다.
  - 이제 이 프로젝트에서 eslint가 jest-dom을 인식해준다. 
- 확장도구를 설치만 했지 연결을 해주지 않았다. 사용하기 위해서는 불러와야만 한다.
  - 프로젝트 루트에 setup파일을 만들고(jest.setup.mjs) `import '@testing-library/jest-dom'`
  - 이제 jest.config.js에서 setupFilesAfterEnv에 './jest.setup.mjs'를 넣어주면 모든 설정 완료된 후 이 setting도 하겠다는 뜻이다.
  - 이제 실행해보았는데 에러가 난다. 모듈파일인데도 import를 인식하지 못하기 때문. (WHY????? 질문하기) 
    - 'jest.setup.mjs'를 'jest.setup.cjs'로 바꾸고 내용을 `require('@testing-library/jest-dom')`으로 해주자.
    - jest.config.js 파일에서도 확장자명 바꿔주고 다시 실행하면 된다.
- jest-dom 실행에 성공하면 toHaveClass를 써보자. test폴더의 addClass.js에서 아래와 같이 써보자
```js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {

    document.body.innerHTML = `<div id="app"></div>`

    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode).toHaveClass(addedClassName);
}) 
```
- 이렇게 하면 장황하지 않게 DOM 테스트코드를 작성하는 것에 성공

