# React

## 지난 시간 복습 및 수습
- 설치한 패키지인 jest의 메서드에 대해서 eslint가 자꾸 빨간 줄 띄우는 것을 막아주기 위해 eslintrc.js에서 `"globals/jest": true`로 했다가 안돼서 결국 `globals: { jest: true },`로 넣어주었는데, "globals/jest"가 아니라 "jest/globals"로 했어야 했다.

### preparing-for-react
- test파일을 이전에는 `~.test.js`로 파일명을 설정하여 jest의 테스트 대상에 포함시켰는데, 이제는 src 폴더 안에 `__tests__`라는 폴더를 만들어 그 안에 js 파일로 저장한다. 
  - jest.config.mjs 파일 안에 아래와 같이 설정해주었기 때문에 tests 폴더 안에 있는 js파일을 다 테스트해준다.
```
  testMatch: ['**/__tests__/**/*.[jt]s?(x)', '**/?(*.)+(spec|test).[tj]s?(x)'],
```
- package.json에서 scripts로 테스트 설정하기
  - `"test": "jest ./client"` 말고 `"test": "jest"`로만 해도 된다. 
  - `"watch:test": "npm test -- --watchAll"`로 설정하면 지난 시간 "watch:**"로 설정한 watch 명령어에서 lint와 prettier, jest 모두 돌아간다.
  - 하나의 파일만 test하고 싶으면 `jest getrandom`으로 하면 되고(`$ npm test getrandom`), 하나의 파일만 테스트하는 경우 description으로 넣은 텍스트도 보여진다.

#### DOM TEST
- 이렇게 단순한 getRandom 함수가 아니라 domTest에 있는 테스트들은 서버를 돌리면서 브라우저에서 콘솔을 열어 테스트 결과를 확인했는데, jest로는 html문서가 따로 없는데 어떻게 테스트할 수 있을까?
- utils 속에 dom 폴더를 만들고 특정 노드에 클래스 추가해주는 함수 addClass를 js파일에 틀만 만들어주자.
  - 메서드 체이닝을 해서 후속 작업 할수 있도록 node를 반환해주는 거로 하자
```js
// utils/dom/addClass.js
export const addClass = (node, ... classNames) => {
    return node;
}
```
- 테스트 코드를 먼저 만들어주자
```js
// utils/__tests__/addClass.js
import { addClass } from '../dom/addClass.js';

test(`addClass(document.body, 'some') 실행시 document.body는 'some'이라는 클래스를 소유합니다.`, ()=> {
    const addedClassName = 'some';
    expect(addClass(document.body, addedClassName)).toHaveClass(addedClassName);
})
```
- 실행해보면 toHaveClass가 함수가 아니라는 에러가 난다. 우리가 지난 시간 직접 만든 test 라이브러리에는 있지만 jest 자체에서는 toHaveClass라는 메서드를 제공하지 않기 때문이다. 
  - 이를 해결하려면 (1) toHaveClass 메서드 없이 toBeTruthy로 테스트할 수 있는 로직을 작성하거나 (2) toHaveClass 메서드를 제공하는 jest 확장하는 플러그인 사용하거나

1. jest 확장 사용 없이 toBeTruthy로 해보자
```js
// utils/__tests__/addClass.js
test(`addClass(document.body, 'some') 실행시 document.body는 'some'이라는 클래스를 소유합니다.`, ()=> {
    const addedClassName = 'some';
    addClass(document.body, addedClassName);
    expect(document.body.classList.contains(addedClassName)).toBeTruthy();
})
```
  - 이제 test를 돌려보면 addClass 함수 로직이 안 짜여져 있어서 received가 false라고 나온다. 그러니까 이제 addClass 함수를 만들어주자.
    - 노드가 있고, classList라는 프로퍼티를 가진다면 classList에 받은 class를 add해준다.
```js
// utils/dom/addClass.js
export const addClass = (node, ... classNames) => {
    if (node && 'classList' in node) {
        node.classList.add(...classNames);
    }
    return node;
}
```
- 이제 테스트 해보면 성공한 것을 알 수 있다.
- 문서의 특정 노드에 접근하여 클래스이름 설정해보자. 테스트 코드 먼저 짠다.
```js
// utils/__tests__/addClass.js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {
    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode.classList.contains(addedClassName)).toBeTruthy();
})
```
- 테스트를 돌리면 getElementById라는 함수를 호출할 수 없다고 뜬다(근데 우리는 이미 'jsdom'으로 설정해둬서 안뜸).
  - jest가 돌아가는 node.js 환경에서는 web browser이 아니므로 getElementById를 제공하지 않기 때문이다.
  - jest.config.mjs에서 `testEnvironment: "jsdom"`를 써주면 node.js환경에서도 dom테스트를 할 수 있다.
  - 과연 node.js환경에서 jest를 통해 문서에 접근할 수 있는지 확인해보자.
- jsdom으로 하면 appNode가 null이기 때문에 null의 'classList'를 참조할 수 없다는 에러가 뜬다. 
  - appNode를 만들어 준 후 작업해보자.
```js
// utils/__tests__/addClass.js
test(`addClass(document.getElementById('app'), 'anything')으로 #app 요소에 'anything' 클래스를 추가할 수 있습니다.`, () => {

    document.body.innerHTML = `<div id="app"></div>`

    const appNode = document.getElementById('app');
    let addedClassName = 'anything';
    addClass(appNode, addedClassName);
    expect(appNode.classList.contains(addedClassName)).toBeTruthy();
})
```
- 이렇게 하면 가상으로 만든 dom에서 문서에 접근하는 테스트를 돌릴 수 있다.

2. 