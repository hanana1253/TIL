# React

## 지난 시간 복습
- lazy function과 dynamic import를 통해 code splitting을 했는데, 매번 호출하지 말고 component로 만들어서 해보자.
```js
// utils/lazyComponent.js 

export const lazyComponent = (componentName, pageDirectory = 'pages' ) => {
    return lazy(() => import(`../${pageDirectory}/${componentName}/${componentName}`));
}
 
// App.js

const Home = lazyComponent('Home');
const SignIn = lazyComponent('SignIn');
// ...
```

## Context API

### ThemeContext, ThemeProvider, useTheme 만들어 theme 관리하기
- createContext에 초기값을 전달하며 만든 Context는 Provider로 감싸지 않아도 초기값을 공급받을 수 있다.
  - 값이 업데이트 될 필요가 없으면 초기값에 넣은 default data를 Provider 없이 state로 사용이 가능하다.
- createContext로 context를 만든 후, 이 컨텍스트의 Provider를 반환하는 ThemeProvider component를 만들자.
  - mode가 변할 때마다 theme을 새로 업데이트한 value를 공급해주도록 한다. 
- context를 반환하는 커스텀 훅을 만든다.
```js
// theme.js
import { createContext, useContext, useMemo } from 'react';

const theme = {
    dark: {
        background: 'black',
        color: 'white',
    },
    light: {
        background: 'white',
        color: 'black'
    }
}

const ThemeContext = createContext(theme.light);

export const ThemeProvider = (props) => {
    const [ mode, setMode ] = useState('light');
    const value = useMemo(() => ({
        theme: theme[mode],
        toggleTheme() {
            setMode(mode === 'light'? 'dark', 'light');
        }
    }), [mode]);
    return <ThemeContext.Provider value={value} { ... props} />;
}

export const useTheme = () => {
    const context = useContext(ThemeContext);
    if (!context) throw new Error('useTheme 훅은 ThemeProvider 내부에서만 사용할 수 있습니다.');
    return context;
} 
```
- 이제 App을 ThemeProvider로 감싸고, useTheme으로 toggleTheme을 받아서 이를 호출하는 버튼 등을 만들어 모드를 바꿔줄 수 있다.
 
### styled components 라이브러리로 테마 관리하기
- styled components가 제공하는 useTheme이라는 훅을 통해 theme을 공급해줄 수 있으며, 4버전 이하의 경우 render props와 withTheme이라는 HOC를 통해서도 공급해줄 수 있다.
- StyledThemeProvider에 value 대신 theme이라는 prop을 통해 전달한다. 
- 원래는 모든 컴포넌트에 theme을 공급해서 각각 처리해줬어야 하는데 이제는 styled component의 ThemeProvider로 감싸기만 하면 편하게 받아서 쓸 수 있다.

### Constate 
- Redux 대비 Context는 성능 영향이 있다. 상태를 각각 하나의 context로 관리하므로 Provider가 중첩되는 문제도 있고, 하위 컴포넌트들이 불필요한 렌더링을 일으키기도 하는데, 리덕스는 이를 차단해준다.
- 앱의 규모가 크지 않고 Context API를 사용하는 것이 익숙하다면 constate를 쓰는 것도 좋은 선택이다.
- constate를 설치하고 import하고 '상태정보와 이를 업데이트하는 함수를 가진 객체'를 반환하는 커스텀 훅을 전달하며 호출하면, Provider와 context value를 리턴하는 훅을 튜플 데이터 형식으로 내보내준다. 
```js
// auth.constate.js
import { useState } from 'react';
import constate from 'constate';

const useAuthentication = () => {
    const [ authUser, setAuthUser ] = useState(null);
    return { authUser, setAuthUser };
}

const [ AuthProvider, useAuth ] = constate(useAuthentication);
```
- 그 외의 advanced usage를 보면 constate가 팩토리 함수임을 알 수 있다. 
  - 인자를 하나만 넘기면 Provider와 전체 context 객체를 리턴하는 hook을 반환
  - 인자를 두개이상 넘기면 두 번째 인자는 'context를 인자로 받아 작업한 결과를 넘기는 콜백'이며 이 결과물을 반환하는 훅이 두번째 이후 인자로 순서대로 반환된다. 
```js
const [ AuthProvider, useAuthUser, useSetAuthUser ] = constate(useAuthentication, ({authUser}) => authUser, ({ setAuthUser })=> setAuthUser );
```

## Redux