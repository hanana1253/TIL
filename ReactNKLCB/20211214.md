# React

## Web component
- 앞으로의 표준으로 웹 컴포넌트가 보편화되면 리액트와 같은 프레임워크 없이도 CDD를 할 수 있어야 한다.
- web component 안에서는 shadow dom이라는 로컬 스코프를 통해 global css의 문제를 해결한다.
  - CSS는 항상 global scope를 가지기 때문에 요소 이름이나 공통된 클래스 이름으로 스타일링을 할 때 주의했어야 한다.
  - 하지만 shadow DOM 안에서는 local scope로 CSS를 사용할 수 있다. encapsulated된 것이 웹컴포넌트의 특징
- web component는 kebab-case로 명명한다. (vuejs의 네이밍컨벤션도 이러한데, 표준을 지키는 훌륭한 프레임워크라는 반증)
- web component 안의 shadow dom 안에서 stylesheet를 불러오는 link 태그는 그 안에서만 스타일링이 적용된다.
  - 하나의 css파일을 여러 shadow dom에서 로드할 경우 한 번만 로드되게끔 성능적으로 문제 없도록 처리된다고 한다.
- web component에 적용된 css의 :host라는 가상클래스는 스타일시트를 불러온 custom component를 가리킨다. 
- slot은 외부에서 가져온 정보를 넣어주는 곳으로, react의 children과 같이 밖에서 온 text를 끼워줄 수 있다. 
- custom component 안에 또다른 custom component를 넣어줄 수도 있다.

### web component class 만들기  
- index.html에서 components/index.js를 불러오는데, index.js에서는 내가 쓸 모듈을 import만 하는 구문만 있으면 된다.
- `window.customElements.define('class-name', ClassRef)`처럼 정의하는데, 이 때 두 번째 인자는 반드시 HTMLElement를 상속받아 만든 클래스 참조값이어야만 한다.
- `constructor`에서 .... this를 사용하려면 super 호출이 필수적이다. 
  - shadowDOM을 열어주기 위해 mode를 open으로 하는 객체를 전달하며 `this.attachShadow` 호출한다. 
- `connectedCallback`은 이 컴포넌트가 문서에 성공적으로 연결되면 호출되는 메서드를 정의한다.
- `disconnectedCallback`은 반대로 컴포넌트가 제거될 때 호출되는 메서드로, 채팅친구 목록에서 이미 로그아웃한 유저의 온라인 상태를 계속해서 묻는 등의 작업을 중단할 때 등 컴포넌트가 제거될 때 수행할 clear function으로 사용한다.
- `render`는 `this.shadowRoot.innerHTML`에 html코드를 넣어주는 내용으로 작성한다.
```js
class EuidButton extends HTMLElement {
    constructor(){
        super();
        this.attachShadow({ mode: 'open' });
        this._rendered = false;
        this._attrs = {};
    }

    connectedCallback(){
        if (!this._rendered) {
            this._rendered = true;
            this.setAttrs();
            this.render();
        }
    }

    setAttrs() {
        for (const { nodeName, nodeValue } of this.attributes) {
            this._attrs[nodeName] = nodeValue;
        }
    }

    _bindAttrs() {
        const buttonNode = this.shadowRoot.querySelector('button');
        for (const [key, value] of Object.entries(this._attrs)){
            if (key !== 'type' && key !== 'class'){
                buttonNode.setAttribute(key, value);
            }
        }
    }
    render() {
        const { type, class: className, style } = this._attrs;
        this.shadowRoot.innerHTML = `
            <style>
                :host button {
                    ...
                }
            </style>
            <button type=${type ?? "button"} class="${`EuidButton ${className ?? ''}`.trim()}">
            <slot />
            </button>`;
        this._bindAttrs();   
    }
} 
```

### html, css, js로 웹 컴포넌트 뭉치기
- template.html에서 link태그로 stylesheet를 데려오고, button은 아까 만든 euid-button 컴포넌트를 사용하자.
- 템플릿이 분리되어 있어도 데이터를 주입해줘야 하는데, domScripting을 통해 우리는 해주자.
- 컴포넌트 js 코드에서 `fetch('./template.html')`로 데려온 후 then으로 후속작업해준다. 
  - 파일 그대로 오니까 `text()`로 코드를 텍스트화한 후 이를 바탕으로 component 만들어 custom component로 등록까지 해주는 define 함수를 호출한다.
```js
fetch('./template.html').then(html => html.text()).then(template => {
    define('euid-counter', template);
})

function define(componentName, template) {
    class EuidCounter extends HTMLElement {
        constructor () {
            super();
            this.attchShadow({ mode: 'open' });
            ...
        }
    }
    customElements.define(componentName, EuidCounter);
}
```

## props vs. state 
- props는 부모로부터 물려받는 readonly 상태이며, state는 인스턴스 안에서 읽기, 쓰기가 가능한 상태이다. 
- 두개 이상의 컴포넌트가 사용하는 상태는 상위 컴포넌트로 올려 통신하며 관리해야하는데 이를 state lift up이라고 한다.

## class vs. function component
- class는 life cycle method가 있지만 function은 항상 재실행된다. 
  - 이 때문에 초기 react에서는, 상태를 가지면 무조건 class component로 만들고 presentational component만 function으로 관리했다. (클래스보다 함수가 더 가볍기 때문)
  - 이제는 hook을 통해 함수 안에서도 상태를 관리할 수 있게 되었다. 그래서 function component의 시대가 열렸다. 
  - hook은 함수 바깥에서 이 state를 기억하여 함수가 재실행되더라도 이를 사용할 수 있게 해준다.
  - 또한 function보다 class가 자바스크립트에서는 최신 문법이기 때문에 function component가 더 하위 호환에도 대응할 수 있는 형태이다.

### class component 만들기
- class component는 instance 멤버를 가지며, React.Components를 상속받는다.
- 상속을 위해서는 constructor 메서드 안에서의 super 호출이 필요하지만, 최신 문법에서는 클래스 필드 정의로 state를 정의할 수 있기 때문에 이제는 constructor 메서드 자체를 생략해도 괜찮다.
- render 메서드는 업데이트를 할 때 호출된다. 