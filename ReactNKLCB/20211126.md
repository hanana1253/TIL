# React

## 지난 시간 복습 및 수습
- 지난 시간 `package.json`에서 'start' 스크립트로 '&'을 사용하여 병렬 명령(`npm run dev:compile-watch & npm run dev:server-open`)을 했는데, 윈도우 환경에서는 잘 안되니까 `npm-run-all` 패키지를 깔고 script를 `run-p dev:compile-watch dev:server-open`으로 바꿔주었다.
- 모듈화하면서 생긴 여러 모듈 파일 디렉토리를 다 컴파일해줘야하므로, dev:compile-watch 명령어가 실행할 스크립트는 `"npm run dev:compile -- -w"`에서 `dev:compile`이 아니라 `dev:compile-dir`로 바꿔줘야. (dev:compile은 main.js 파일만 컴파일해주고 있었다.)
- index.html 파일에서 contents라는 클래스를 가진 div의 lang 속성도 버튼을 누를 때마다 toggle 시켜주어야만 한다.
  - renderUpdatedUI 함수 안에서 `$('.contents').attr('lang', translator.currentMode)`를 추가해준다.
- 어제 우리는 `@types/node`, `@types/live-server`를 설치했다. typescript와 vscode 모두 MS사가 만든 거라 서로 친화적이며 편리한 기능을 제공한다.

## preparing 실습
### package.json 및 server.js의 서버환경을 commonJS와 ESM 버전으로 관리하기
- [nodejs.dev에서 package.json Guide](https://nodejs.dev/learn/the-package-json-guide)을 읽고 다음과 같이 설정해주자
  - `"private": true`: npm에 올려 공개할 package라면 public으로 해도 되지만 우리는 아니니까 
  - `"name": "preparing"`: package이름 될거니까 대문자 쓰지 말것
  - `"version": "0.0.1"`
  - `"scripts": { "start": "", "dev": "node server/index", "test": "" }`: 일단 넣어두기
  - `"type": "module"`: server.js에서 commonJS를 사용하지만 브라우저의 ESM과 동일하게 하려면 넣어주자
- 이 상태에서 "npm run dev"로 server을 돌리면 live-server을 import하는 구문인 require을 해석하지 못해 reference error가 난다. 
  - commonJS로 바꾸어 해결하기: server/index.js의 확장자를 server/index.cjs로 바꾼다.
  - ESM으로 바꾸어 해결하기: server/index.js의 확장자를 server/index.mjs로 바꾸고 `const liveServer = require('live-server')`를 `import liveServer from 'live-server'`로 바꾼다. 
  - node.js환경에서 ESM을 기본으로 설정한 경우, 즉 package.json에 "type":"module"를 지정한 경우 명령어에 확장자를 생략하면 안된다. scripts의 "dev" 명령어에 꼭 확장자(`node server/index.mjs`)를 지정해주어야 한다. 지정하지 않으면 'cannot find module'에러!

### server에서 환경변수 설정하기
- node.js에서는 `process.env`로 환경변수를 참조할 수 있다. 콘솔로 찍어보면 여러가지 환경정보가 나온다.
- 참조 뿐만 아니라 프로퍼티 동적 추가로 custom 환경변수를 세팅할수도 있다. (참고: [nodejs에서 환경변수 다루기 블로그](https://www.daleseo.com/js-node-process-env/), [nodejs.dev의 환경변수 가이드](https://nodejs.dev/learn/how-to-read-environment-variables-from-nodejs))
- 현재 server/index.mjs는 다음과 같이 구성되어있다.
```js
// server/index.mjs
import liveServer from 'live-server';

const params = {
  host: 'localhost',
  port: 3000,
  open: false
}

liveServer.start(params);
```
- 여기서 port와 open에 주어질 params를 CLI 명령어로 환경변수 세팅해주면서 server을 구동시켜보자
  - 먼저 `const { PORT, OPEN } = process.env;`로 환경변수를 받고, null 병합연산자로 port와 open에 각각 넣어준다.
  - null 병합 연산자 대신 or 단축평가법(`||`)을 사용하기도 하지만, 그런 경우 '0'이나 빈 문자열이 falsy로 평가되므로 더욱 안전한 null 병합 연산자를 써주면 좋다.
```js
const { PORT, OPEN } = process.env;
const params = {
  host: 'localhost',
  port: PORT ?? 3000,
  open: OPEN ?? false
}
```
- 그대로 server을 돌리면 아직 PORT와 OPEN을 넣어주지 않았기 때문에 둘다 undefined 값을 가진다.
- bash shell에서 명령어를 입력할 때, (scripts에) `환경변수=값`의 형태로 넣어주기만 하면 된다. 1회성으로 설정해준 환경 변수이기 때문에 해당 프로세스가 살아있는 동안에만 유효하며 프로세스를 종료하면 사라진다.
  - `"dev": "PORT=8080 node server/index.mjs"`로, `"start": "OPEN='/client/public' npm run dev"`으로 환경변수를 설정하며 명령어를 실행시킨다.
- 하지만 window 환경에서는 환경변수 설정이 이걸로 잘 안될거다. 그러니까 cross-env라는 패키지를 깔아서 모든 scripts의 환경변수 설정 CLI 명령어에 cross-env를 앞에 붙여준다.
```
// bash 명령어
$ npm i -D cross-env 

// package.json
"scripts": {
    "start": "cross-env OPEN='/client/public' npm run dev",
    "dev": "cross-env PORT=8080 node server/index.mjs",
    // 기타 스크립트
},
```
- 이제 server 건드릴 일 없긴 한데 그래도 server 파일에 변화가 있을 때마다 감지하여 다시 구동해주는 watch 옵션을 가진 패키지도 다운받아보자. 이전에 nodemon을 써봤을테니 오늘은 node-dev로 (근데 window는 node-dev 안되니까 nodemon으로)
  - `$ npm i -D node-dev`로 설치하고, package.json에서 "dev" 명령어에 node 대신 node-dev를 넣어준다.
  
## clent 파일 작업

### HTML head 태그
- 기본 설정 메타태그 분석해보자
```html
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
```
- `http-equiv`는 문서의 초기정보를 지정하는 속성으로, content를 꼭 기재해주어야 한다.
  - 브라우저 호환성 설정을 나타내는 `X-UA-Compatible`에서 X는 실험적인 단계를, UA는 User Agent를, Compatible은 호환을 나타내며, content로 오는 `"IE=edge"`는 Internet Explorer의 가장 최신(edge) 단계를 나타낸다. 
  - 이것은 곧 이 html 문서를 열 때 사용할 렌더링 엔진을 지정하는 것으로, IE의 최신 렌더링 엔진을 사용하도록 지정했다.
  - 한 때 IE가 표준을 너무 안 지켰기 때문에, "IE=9"로 지정되는 경우는 만일 IE로 열리면 최소한 9버전으로 렌더링하게끔 해달라는 요청이다.

```html
  <meta name="viewport" content="width=device-width, initial-scale=1" />
```
- viewport가 device-width로 설정되는 경우, 사용자의 기기에 맞게 맞춰진다.
- 접근성 관점에서 "user-scalable=no"는 쓰지 않는 것이 권장된다. 확대해서 봐야할 때가 있으니까.
- 그 밖에도 head 태그 안에 SEO, favicon, webfonts, open-graph info 등을 넣어주어야 한다.
- favicon(favorite icon)은 해당 사이트의 아이덴티티를 위해 필수적인데, link태그에서 'link:icon'으로 emmet 속기법을 사용하면 `<link rel="shortcut icon">`이 되는데 여기서 shortcut은 삭제하고 그냥 icon으로.
- webfont도 spoqa han sans로 CDN link 태그를 걸어주자.
```html
<link rel="stylesheet" href="//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSansNeo.css" />
<link rel="icon" href="//vectorlogo.zone/logos/reactjs/reactjs-icon.svg" />
<link rel="stylesheet" href="./css/main.css" />
```

### Test Driven Development
- client/src 안에 utils라는 폴더를 만들고, tests.js, index.js, throwError.js, getRandom.js, transformText.js 모듈파일을 만들어주자.
- 테스트 주도 개발이란, 먼저 어떤 함수가 필요한지 생각(think)하고, test하고, code를 짜고 refactoring한다!
- 책을 쓸 때 기획자와 미팅하는 게 think, 목차를 짜는 게 test, 실제로 글을 쓰는 게 code, 다듬는 게 Refactor이라고 보면 된다.
- 보통은 test는 library로 많이 하지만, 이번에 한 번 직접 짜보도록 하자.
  - describe: 기술하는 utility 
  - test: 테스트 utility
  - expect: 기대값을 검토하는 utility

#### expect utility
- `expect(전달값).toBe(기대값)`으로 같은지 비교해주거나, `expect(노드).toBeInTheDocument()`로 해당 노드가 문서 안에 존재하는지를 알아볼 수 있으며, `expect(전달값).not.toBe(기대값)` 등으로 반대 결과도 확인이 가능하다.
```js
// utils/tests.js
function expect(received) {
  // 전달값과 비교할 수 있는 utility 모음 객체 반환
  return {
    toBe(expected) {
      // 전달값과 기대값이 같지 않으면 오류
      if (received !== expected) {
        throwError(`${received}와 ${expected}의 값이 동일하지 않습니다.`);
      }
    }, 
    toBeInTheDocument() {
      if (!document.body.contains(received)){
        throwError(`${received}는 문서 안에 존재하지 않습니다.`);
      }
    }
    not: {
      toBe(expected) {
        if (received === expected) {
          throwError(`${received}와 ${expected}의 값이 동일합니다.`);
        }
      },
      toBeInTheDocument() {
        if (document.body.contains(received)) {
          throwError(`${received}는 문서 안에 존재합니다.`);
        }
      }
    }
  }
}
```
- 여기에서 expect가 리턴하는 객체 속 received는 함수와 같이 클로저로 expect함수에게 주어진 인자 received를 참조하고 있다.
- `throw new Error`을 매번 하기 귀찮으니까 utility func로 빼주고 tests.js에서 import해준다
```js
// utils/throwError.js

export function throwError(errorMsg) {
  throw new Error(errorMsg);
}
```

#### test utility
- 코드 사용 예시는 다음과 같다.
```js
test('1+1=2', () => expect('1+1').toBe(2))
```
- 만들어보자
```js
function test(description, callback) {
  try { // 사용자가 전달한 함수를 실행
    callback();    
    console.log(`😃테스트 성공: ${description}`)
  } catch(error) {
    console.groupCollapsed(`😫테스트 실패: ${description}`);
    console.error(error.message);
    console.groupEnd();
  }
}
```
- `console.groupCollapsed`는 `console.groupEnd`가 호출되기 전까지의 긴 콘솔메시지를 닫힘상태로 제공한다.

#### expect utility
- 코드 사용 예시는 다음과 같다.
```js
describe(테스트 리스트 항목을 대변하는 레이블, () => {
  test();
  test();
  test();
  ...
})
```
- 만들어보자
```js
function describe(testLabel, callback) {
  console.group(testLabel);
  callback();
  console.groupEnd();
}
```
- `console.group`은 상위에서 여러개의 테스트 코드를 묶어주기만 하는 애다.

#### 테스트 실행해보기
- 여기까지 우리는 describe, test, expect를 호출할 수 있는 테스트 라이브러리를 직접 작성해보았다. 
  - 이제 이 세개의 함수를 export해주고, public/index.html에 script태그로 src/main.js를 `type="module"`로 불러오자
```html
<script type="module" src="./src/main.js"></script>
```
- main.js에서 테스트코드를 써보자
```js
import { describe, test, expect } from './utils/tests.js';

describe('초등수학', () => {
  test('10 * 20 - 8 = 192', () => {
    expect(10 * 20 - 8).toBe(192);
  });
  test('1+1=11', () => {
    expect(1+1).toBe(11);
  });
})
```
