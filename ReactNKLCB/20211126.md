# React

## 지난 시간 복습 및 수습
- 지난 시간 `package.json`에서 'start' 스크립트로 '&'을 사용하여 병렬 명령(`npm run dev:compile-watch & npm run dev:server-open`)을 했는데, 윈도우 환경에서는 잘 안되니까 `npm-run-all` 패키지를 깔고 script를 `run-p dev:compile-watch dev:server-open`으로 바꿔주었다.
- 모듈화하면서 생긴 여러 모듈 파일 디렉토리를 다 컴파일해줘야하므로, dev:compile-watch 명령어가 실행할 스크립트는 `"npm run dev:compile -- -w"`에서 `dev:compile`이 아니라 `dev:compile-dir`로 바꿔줘야. (dev:compile은 main.js 파일만 컴파일해주고 있었다.)
- index.html 파일에서 contents라는 클래스를 가진 div의 lang 속성도 버튼을 누를 때마다 toggle 시켜주어야만 한다.
  - renderUpdatedUI 함수 안에서 `$('.contents').attr('lang', translator.currentMode)`를 추가해준다.
- 어제 우리는 `@types/node`, `@types/live-server`를 설치했다. typescript와 vscode 모두 MS사가 만든 거라 서로 친화적이며 편리한 기능을 제공한다.

## preparing 실습
### package.json 및 server.js의 서버환경을 commonJS와 ESM 버전으로 관리하기
- [nodejs.dev에서 package.json Guide](https://nodejs.dev/learn/the-package-json-guide)을 읽고 다음과 같이 설정해주자
  - `"private": true`: npm에 올려 공개할 package라면 public으로 해도 되지만 우리는 아니니까 
  - `"name": "preparing"`: package이름 될거니까 대문자 쓰지 말것
  - `"version": "0.0.1"`
  - `"scripts": { "start": "", "dev": "node server/index", "test": "" }`: 일단 넣어두기
  - `"type": "module"`: server.js에서 commonJS를 사용하지만 브라우저의 ESM과 동일하게 하려면 넣어주자
- 이 상태에서 "npm run dev"로 server을 돌리면 live-server을 import하는 구문인 require을 해석하지 못해 reference error가 난다. 
  - commonJS로 바꾸어 해결하기: server/index.js의 확장자를 server/index.cjs로 바꾼다.
  - ESM으로 바꾸어 해결하기: server/index.js의 확장자를 server/index.mjs로 바꾸고 `const liveServer = require('live-server')`를 `import liveServer from 'live-server'`로 바꾼다. 
  - node.js환경에서 ESM을 기본으로 설정한 경우, 즉 package.json에 "type":"module"를 지정한 경우 명령어에 확장자를 생략하면 안된다. scripts의 "dev" 명령어에 꼭 확장자(`node server/index.mjs`)를 지정해주어야 한다. 지정하지 않으면 'cannot find module'에러!

### server에서 환경변수 설정하기
- node.js에서는 `process.env`로 환경변수를 참조할 수 있다. 콘솔로 찍어보면 여러가지 환경정보가 나온다.
- 참조 뿐만 아니라 프로퍼티 동적 추가로 custom 환경변수를 세팅할수도 있다. (참고: [nodejs에서 환경변수 다루기 블로그](https://www.daleseo.com/js-node-process-env/), [nodejs.dev의 환경변수 가이드](https://nodejs.dev/learn/how-to-read-environment-variables-from-nodejs))
- 현재 server/index.mjs는 다음과 같이 구성되어있다.
```js
// server/index.mjs
import liveServer from 'live-server';

const params = {
  host: 'localhost',
  port: 3000,
  open: false
}

liveServer.start(params);
```
- 여기서 port와 open에 주어질 params를 CLI 명령어로 환경변수 세팅해주면서 server을 구동시켜보자
  - 먼저 `const { PORT, OPEN } = process.env;`로 환경변수를 받고, null 병합연산자로 port와 open에 각각 넣어준다.
  - null 병합 연산자 대신 or 단축평가법(`||`)을 사용하기도 하지만, 그런 경우 '0'이나 빈 문자열이 falsy로 평가되므로 더욱 안전한 null 병합 연산자를 써주면 좋다.
```js
const { PORT, OPEN } = process.env;
const params = {
  host: 'localhost',
  port: PORT ?? 3000,
  open: OPEN ?? false
}
```
- 그대로 server을 돌리면 아직 PORT와 OPEN을 넣어주지 않았기 때문에 둘다 undefined 값을 가진다.
- bash shell에서 명령어를 입력할 때, (scripts에) `환경변수=값`의 형태로 넣어주기만 하면 된다. 1회성으로 설정해준 환경 변수이기 때문에 해당 프로세스가 살아있는 동안에만 유효하며 프로세스를 종료하면 사라진다.
  - `"dev": "PORT=8080 node server/index.mjs"`로, `"start": "OPEN='/client/public' npm run dev"`으로 환경변수를 설정하며 명령어를 실행시킨다.
- 하지만 window 환경에서는 환경변수 설정이 이걸로 잘 안될거다. 그러니까 cross-env라는 패키지를 깔아서 모든 scripts의 환경변수 설정 CLI 명령어에 cross-env를 앞에 붙여준다.
```
// bash 명령어
$ npm i -D cross-env 

// package.json
"scripts": {
    "start": "cross-env OPEN='/client/public' npm run dev",
    "dev": "cross-env PORT=8080 node server/index.mjs",
    // 기타 스크립트
},
```
- 이제 server 건드릴 일 없긴 한데 그래도 server 파일에 변화가 있을 때마다 감지하여 다시 구동해주는 watch 옵션을 가진 패키지도 다운받아보자. 이전에 nodemon을 써봤을테니 오늘은 node-dev로 (근데 window는 node-dev 안되니까 nodemon으로)
  - `$ npm i -D node-dev`로 설치하고, package.json에서 "dev" 명령어에 node 대신 node-dev를 넣어준다. 