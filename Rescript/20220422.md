# Bootcamp Day 4

Rescript & 함수형 프로그래밍 부트캠프

## 오늘 한 일
- 패턴매칭, 레코드와 객체, 배리언트, 리스트 공부
- AoC Day 5 Part 2 리팩토링
- AoC Day 6 `set`과 `reduce`로 리팩토링

## 배운 것들

### rescript 특징
- 레코드
  - JS의 객체와 유사하지만 일반적으로 불변이며 고정 필드(확장 불가)를 갖는다. 
  - 반드시 타입 선언을 먼저 해야하며, 타입 선언 시 mutable을 필드명 앞에 쓰면 해당 필드는 mutable
  - (기선언한 타입 형태에 맞는) 레코드 값을 생성하면 rescript가 상응하는 타입을 찾아 추론된다.
- 객체
  - type 선언은 optional, 타입선언 할 때 필드 이름을 따옴표로 감싼다.
  - 레코드와 달리 객체 생성시에는 해당 필드가 있는 타입 선언을 자동으로 찾아 비교하지 않으며, 각 객체는 자기자신의 형태를 가진 타입으로 추론된다. 
  - 선언된 객체 타입과 비교되게 하려면 객체 생성 시 선언부 변수에 어노테이션을 준다.
- 배리언트
  - 리스크립트에서는 `type myType = int | string`와 같이 정의하는 것이 불가능, `type myType = Int(int) | String(string)`와 같이 각각 생성자를 제공해야 한다.
  - 인터롭 부분 공부하고 다시 보자
- 리스트
  - 배열과 같이 같은 타입의 값들만을 포함하며, 불변이다.
  - head 또는 tail 항목을 가져오는 것이 빠르며 나머지 다른 것들은 느리다.
  - 리스트는 `type List = Nil | Cons(Int, List)`와 같이 재귀적으로 자신의 타입을 포함하고 있다. 
    - 마지막 요소 Nil, 빈 리스트가 필요하다.
    - 이렇게 자료구조 자체가 재귀적으로 만들어져있다보니 재귀적으로 풀어야 하는 문제에서 순차적으로 접근하여 패턴매칭을 하기에 적합
    - 그러나 임의의 위치에 있는 원소에 접근하는 것에는 비효율
    - c.f. 배열은 반대로 index를 통해 임의의 원소에 접근하는 것이 빠르지만, 순차적인 패턴매칭에는 부족합
- 패턴 매칭
  - 배리언트를 통해 여러 케이스를 다르게 처리할 수 있는 `switch` 패턴매칭 구조분해 및 작업이 가능하다.
  - List보다는 Option이나 Variant 등 다른 자료구조에서 패턴매칭을 더 많이 사용하게 될 것
- Set
  - 공집합은 모든 집합에 존재하는 일반적인 구조이기 때문에 라이브러리에서 제공
  - 진정한 의미의 전체집합은 만들 수 없기 때문에 필요한 범위 안의 전체 집합을 스스로 정의한 후 작업해야 한다.
- 배열은 고정된 길이가 아니기 때문에 아래와 같은 상황이 일어난다.
```res
open Belt
let xs = [1,2,3]
let y = xs[3] // y의 타입은 Option
```
  - 3번째 인덱스에 새로운 요소가 들어갈 수도, 아닐 수도 있기 때문
  - AoC 2일차를 풀면서 parsing 할 때 Option이 필요할 것


### 함수형 프로그래밍
- 중첩이 여러 번 되어 있는 구조라는 것에 너무 신경쓰지 않아도 된다. 필요하면 필요한 만큼 map의 도움을 받으면 되니까.

## 피드백
- 공통되는 부분들을 묶고, 달라지는 것들만 패턴을 파악해서 함수와 코드를 재사용하자.
- 이제는 `Js.Array2` 대신 `Belt.Array` 쓸 것
- 재귀와 귀납은 동전의 양면처럼 일맥상통하다. 

## 느낀 점
- 리스크립트 어려울 거라 생각해서 겁먹고 시작했는데, 공부해보니 매우 합리적이고 간단해서 즐겁게 배우고 있다. 
- 위의 사항은 배리언트를 시작하기 전까지의 느낀 점이었다. 배리언트는 매우 오묘하고 어렵다.
- 이미 메서드에서 제공하고 있는 것을 굳이굳이 함수로 정의해서 쓰고, 동일한 작업을 하는 건데도 나누어서 사용하고 있었다. 이 부분만 춘구님에게 리팩토링 받았는데 코드량이 획기적으로 줄었다!

## TO DO
- [x] parse, don't validate 읽기
- [x] AoC 2일차 풀기