# Bootcamp Day 2

Rescript 부트캠프

## 오늘 한 일
- 리스크립트 문제 풀이 (Day 5)

## 배운 것들

### rescript 특징
- default나 optional param을 넣어 정의한 함수의 매개변수 마지막에는 꼭 unit(`()`)을 넣어주고, 함수를 호출할 때 인자 전달이 마무리 되었다면 `()`을 넣는다.
  - rescript의 모든 함수는 **autocurrying**: `()`를 넣지 않으면 다음 인자를 전달하는 함수를 리턴한다. 
  - 아무 인자도 전달하지 않으면 default값 쓰려고 생략한건지 아니면 currying할건지 모르니까... 
  ```res
  let splitString = (string, ~splitLetter="", ()) => string->Js.String2.split(splitLetter)
  "hello"->splitString()->Js.log // ["h", "e", "l", "l", "o"]
  "hello"->splitString->Js.log // [Function (anonymous)]
  ```   
- 거듭제곱연산자(`**`)는 실수(float)만 취급: 타입이 안 맞아서 `Js.Math.pow_int(~base=2, ~exp=3)`으로 쓸 수 밖에 없었다.
- 리스크립트에서는 튜플을 배열처럼 사용하지 않기 때문에 배열 메서드인 map은 튜플에서 사용할 수 없다.
  - 튜플은 요소들의 자료형이 서로 다른 것을 허용하고 있으니 그 때문에 아마도...?
- rescript에는 JS의 let(재할당가능한 변수선언)과 loop문이 없다.

### 함수형 프로그래밍
- 함수 안에서 외부의 다른 함수를 참조하는 것은 경우에 따라 바람직하지 않을 수 있으니, 함수 몸체에 다른 함수를 정의하고 사용하여 가독성을 높일 수 있음 
- 하나의 함수가 여러가지 일을 하지 않는 것이 바람직
- 배열에 세 개의 작업을 하기 위해 map을 세 번 돌기보다는, 한 map에서 세 개의 작업을 하도록 하면 3n -> n으로 성능상 이점
  - 자바스크립트의 map은 배열을 순회하며 작업을 하기 때문. 다른 자료구조는 또 다를 수 있다.
- rescript에는 JS의 let과 loop문이 없으니 이를 어떻게 바꿀지 생각해 볼 것
  - Before: JS let으로 선언한 변수에 값을 재할당하며 새로운 값과 하나하나 비교 (명령형)
  - After: 비교하고자 하는 대상 자체를 값으로 만든 후, 이 값을 대상으로 작업 (선언형) 

## 피드백
- map으로 배열 작업하는 것과 문제 해결을 위해 계획 먼저 짜는 것은 바람직하다.
- 멀리 돌아가더라도 좌절하지 말것. brute force로 해결하고 나중에 refactoring하면 된다. 
- type을 고려하면서, 문제를 합성할 때의 순서도 중요하다. 
  - 이를 염두에 두고 코드를 작성하면 코드블록도 더 간단해진다 
  - e.g. map을 돌 때마다 `array<string>`을 `array<[number, number]>`로, 그리고 `array<number>`로 변환될 때 어떤 순서로 어떤 type이 와야 좋은지 생각해볼 것
 
 
## 느낀 점
- 작업을 잘게 나눈다고 나눴는데도 여전히 나중에가면 뭉탱이가 되어버려 아쉽다.
- 두뇌 풀 가동 중

## 숙제
- [ ] Day 6 문제를 set을 사용해서 풀면서, 왜 set이 필요한지 생각해 볼 것 
- [ ] Day 5 Part 2 선언형으로 작성해볼 것
