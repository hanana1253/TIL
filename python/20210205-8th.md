# Day 8 of python3

## Today I learned ...

### LAMBDA

1. `map(function, iterable object)`
- iterable object 안의 모든 요소에 대해서 function 작업을 수행하여 map object를 return
- list comprehension과 다른 점은, map은 map object를 만들어두고 필요할 때마다 하나씩 순회하며 값을 생산하기 때문에 효율적. `next(map object)`를 돌려보면 그때그때 작업하는 것을 알 수 있다. (그러나 나는 무슨 말인지 이해 못했기 때문에 알 수 없었다) 반면 for문은 한번에 처리하기 때문에 for문 돌아가는 중에는 다른 일을 할 수가 없다.  
```
list(map(len, ['1','22','333'])) #[1,2,3]
```

2. `filter(function, iterable object)`
- iterable object의 각 요소 중 특정 함수를 만족하는 요소만 남기는 `filter`
- `filter` 안에 들어가는 함수는 항상 Boolean 자료형을 리턴해야만 한다. 왜냐면 조건 충족 여부를 판단해서 남겨야 하니까!
- `filter`는 filter object를 리턴하므로 list로 type casting 해줘야 한다.
```
#1부터 10까지의 짝수를 표현하는 여러가지 방법
list(range(1,10+1,2)) #range의 세번째 argument는 step(몇번씩 뛰어넘을지)을 나타낸다.
[i*2 for i in range(1, 5+1)] #list comprehension
[i for i in range(1, 10+1) if i%2==0] #list comprehension with if condition
list(filter(lambda x:x%2==0, range(1,10+1)))
#모두 결과값은 [2,4,6,8,10]
```
3. `reduce(function, iterable object[, initializer])`
- iterable object 안의 모든 요소에 대해 연산을 반복수행하여 값을 쌓아나가며, 그러므로 항상 1개의 결과값이 return된다.
- `reduce` 안에 들어가는 함수는 항상 2개의 parameter을 가진다. 그래야 이전 값에 다음 값을 연산하며 쌓아나가니까!
- python3 기본 내장함수에서 제외되어 처음에 `from functools import reduce`로 모듈을 불러줘야 한다. (map, filter과 더불어 lambda는 readability가 떨어진다는 이유로 핍박받다가 reduce는 결국 유배됨)
```
#1부터 100까지의 모든 숫자의 합을 연산하자

#without reduce
result = 0
for i in range(1,100+1):
  result += i 
print(result) #5050

#with reduce
from functools import reduce


reduce(lambda x,y:x+y, range(1, 100+1)) #5050

#만약 이미 값을 가진 변수에 값을 쌓고 싶다면, reduce의 세번째 argument에 넣어준다.
reduce(lambda x,y:x+y, range(1, 100+1), 100) #5150
```

#### Practice Do it yourself
```
#재료: 여러가지 type의 자료형을 요소로 가진 list
recycle_bin = [
1, 2, "Fastcampus", ['dog', 'cat', 'pig'], 5, 4, 5.6, False
"패스트캠퍼스", 100, 3.14, 2.71828, {'name':'Kim'}, True,
]

#도구: 대상이 특정instance(객체/타입)에 속했는지 판단하여 Boolean 값을 리턴해주는 함수 isinstance() 
isinstance(대상, 객체 또는 타입) 
```
- 1. recycle_bin의 요소 중 정수와 실수인 요소만 리스트로 구성하기
```
list(filter(lambda a:isinstance(a, (int, float)), recycle_bin))
#isinstance()의 두번째 parameter는 튜플도 인자로 받는다.
#[1, 2, 5, 4, 5.6, False, 100, 3.14, 2.71828, True] # True / False가 1과 0으로 인식되어 여전히 list에 포함된다. 

list(filter(lambda b:not isinstance(b,bool), filter(lambda a:instance(a, (int, float)), recycle_bin)))
#아까 나온 filter객체를 대상으로 Boolean 자료형이 아닌 것들로 한번 더 filter해줘야 정수와 실수만 출력된다.
```
- 2. recycle_bin의 요소 중 정수인 요소만 각각 제곱하여 리스트로 구성하기
```
list(map(lambda x:x**2, filter(lambda b:not isinstance(b,bool), filter(lambda a:isinstance(a, int), recycle_bin))))
#int인 요소를 filter 후 bool 아닌 요소로 filter한 객체에 대해, map을 통해 각 요소를 제곱 연산한 결과값을 요소로 갖는 리스트가 만들어졌다.
```
- 3. recycle_bin의 요소 중 정수인 요소만 각각 제곱한 수의 합계 출력하기
```
#위의 2번의 결과로 나온 리스트에 대해서 reduce를 수행한다.
from functools import reduce


square_int = list(map(lambda x:x**2, filter(lambda b:not isinstance(b,bool), filter(lambda a:isinstance(a, int), recycle_bin))))

reduce(lambda x,y:x+y, square_int)
```

### OOP & Class

1. 프로그래밍의 패러다임
- 0, 1로 이루어진 기계어에서 조금 더 쉽게 접근할 수 있도록 assembly가 등장
- Imperative Programming(명령형 프로그래밍): statement로 코드를 구성하여 프로그램의 상태를 바꿈. 의미 있는 뿌리 단계였음.
- Procedural Programming(함수기반 프로그래밍): 함수를 정의하고 그 함수를 실행함으로써 결과값을 얻는 프로그래밍으로, 현대 대부분의 언어가 이에 기반(=함수기능을 지원)하고 있다. 
- 그러다보니 특정 함수가 거의 똑같은데 parameter 개수만 다르다던지 기능이 비슷한 것들이 많아지는 문제가 발생했다. 이를 해결하기 위해 등장한 것이 OOP.
- Object Oriented Programming(객체지향형 프로그래밍)은 기존의 line by line 프로그래밍과 달리 데이터와 코드를 포함하는 object, 즉 실제 움직이는 객체를 중심으로 하는 프로그래밍이다.
- Functional Programming은 외부와 독립되어 영향을 받지 않는 상태에서 오롯이 연산을 통해 답을 찾아내는 형태로, lambda의 `map`, `filter`, `reduce`와 list comprehension처럼 input과 output을 정해주고 그 안에서 해결하는 프로그래밍이다.

2. Scope
- 어떤 변수나 함수의 적용 범위로, 함수의 life-cycle과 같다고 볼 수 있다.
- local variable: 해당 함수 안에서만 적용됨
- nonlocal variable: 해당 함수와, 한 scope 밖의 함수까지만 적용됨
- global variable: 전역변수로, outerscope 안에서... 이해못함

3. Class
- `class ClassName`으로 선언하며, class naming할 땐 camelcase convention을 따른다. (c.f. 다른 모든 경우에 대해서, python은 snakecase convention 준수)


 


## 느낀 점
컴퓨터의 세계는 규칙을 따르기만 하면 되는 줄 알았더니 규칙과 활용방법이 굉장히 다양해서 규칙을 모르면, 심지어 규칙을 잘 알더라도 활용방법을 모르면 그만큼 손해보는 것 같다. 재미없고 딱딱한 것으로만 생각했는데, 지식과 지혜가 조합해야 하는 영역이라 매력적이다.
