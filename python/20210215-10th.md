# Day 10 of python3

## Today I Learned ...

### Module
- 변수, 함수, statements까지 다 포함하는 개념으로, `{}.py`이기만 하면 다 모듈이라고 볼 수 있다.
- Practice : shell 상에서 module-practice라는 디렉토리를 만들고 그 안에 모듈을 불러와 실행할 main.py를 만들었다.
  - fibo.py라는 모듈파일을 만들고 `text = 'it works!`를 넣어주었다.
  - main.py에서 `import fibo`를 해주고, `print(fibo.text)`로 출력
  - 그냥 출력하면 define되지 않은 name이라고 nameerror가 뜬다. 꼭 fibo의 객체임을 지정해주도록 `fibo.text`로 호출해줄 것
- 모듈을 불러오는 것에는 여러가지 방법이 있다.
  - `import {module}` 후 {module}.{object in the module}
  - `from {module} import {object}`


### Package
- module 여러개가 들어있는 디렉토리
- Practice : 아까 만든 module-practice 디렉토리 아래 fibo라는 디렉토리를 만들고, 그 안에 recursion을 이용한 피보나치 수열 함수를 넣은 rec.py와 binet공식을 이용한 피보나치 수열 함수 binet.py를 모듈로 생성했다.
- 아까는 모듈에서 객체를 불러올 때 `from fibo import text`를 사용했지만, 이번에는 패키지 안의 모듈을 불러올 때 사용한다. 
  - `from fibo import rec, binet` 처럼 같은 패키지 안에 있으면 콤마로 연결하여 두 개 이상의 모듈을 불러올 수 있다.
  - `from fibo import *` 로 패키지 안에 있는 모든 모듈을 불러올 수도 있다. 하지만 웬만해서는 필요한 모듈만 불러와 용량과 작업시간을 줄이도록 하자.
- 모듈 이름을 편의에 맞게 지정하며 불러낼 수도 있다.
  - `from fibo import rec as r`로 하면 rec.py 안의 객체(함수 등)를 `rec.{object}`가 아닌 `r.{object}`로 호출할 수 있다. 

### Library vs. Framework

- library : module이 여러개인 package. 
  - e.g. jQuery는 자바스크립트에서 간소화된 명령어를 제공, 지금은 쇠퇴함
  - 내가 불러와서 기능을 사용하는 것으로, function에 가깝다.

- framework : class로 만들어진 것들을 불러오는 것
  - e.g. Flask 나 Django 등
  - 내가 아니라 class화 된 대상이 작업을 수행하는 것으로, class에 가깝다.


## 가상환경 구축과 poetry 설치

### pyenv and virtualenv
- pyenv를 통해 만든 virtualenv 안에서 package를 install하면, 그 가상환경 안에서만 package가 존재한다.
  - `pip install {package}`: pip(package installer for python)으로 package를 설치할 수 있다.


- 서로 다른 버전의 패키지를 사용하는 여러 프로젝트를 할 때 가상환경을 각각 만들어준다.
- 이 때 해당 프로젝트에 필요한 library, module을 명시해주는 requirements.txt를 써줘야 하는데, 이를 수동으로 쓰려면 굉장히 번거롭다. 이것을 쉽게 관리하게끔 하는 도구가 바로 poetry이다.

### poetry installation
- [python-poetry 홈페이지](https://python-poetry.org/docs/)에 가서 system requirements를 확인, 나는 macOS라서 osx에 해당하는 install command를 가져와 terminal에 복붙하고, 그 아래 수행해야 할 것들도 읽고 따라해본다.
  - user폴더 최상단(cd)에 있는 .zshrc 파일을 vim으로 열어 아래 내용을 넣어준다.
```
# pyenv의 PATH
export PYENV_PATH=$HOME/.pyenv
if which pyenv > /dev/null; then eval "$(pyenv init -)"; fi
if which pyenv-virtualenv-init > /dev/null; then eval "$(pyenv virtualenv-init -)"; fi
# poetry실행파일의 PATH가 pyenv의 PATH보다 우선되도록 설정
export PATH=$HOME/.poetry/bin:$PATH
```
  - `$ source ~/.zshrc`로 쉘 설정을 다시 해준다.

### 가상환경을 만들고 그 위에서 poetry로 버전관리하기
pyenv는 python의 버전 여러개를 동시에 사용하기 위한 도구이다. pyenv에 설치된 버전 하나를 토대로 virtualenv를 만드는 방법은 아래와 같다.


- `$ pyenv versions`로 가지고 있는 python version을 확인한다. 
- 원하는 버전이 없다면 `$ pyenv install list`로 설치할 python version을 보고, `$ pyenv install {버전이름}`로 설치한다.
- `$ pyenv virtualenv {python버전} {가상환경 이름}`으로 가상환경을 만들어준다. 이때, 가상환경 이름에 python 버전을 확인할 수 있는 390 등의 숫자를 넣어주면 나중에 편리하다.
- `$ pyenv activate {가상환경 이름}`으로 가상환경에 진입하고, 프로젝트를 개발할 디렉토리를 만들어 들어간다. 
- `$ poetry init`을 해주고 각종 초기설정을 한다. 나중에 생기는 pyproject.toml 파일에서 설정 내용을 확인할 수 있다.
- `$ pyenv activate {가상환경이름}`으로 가상환경으로 진입한다.
- `poetry add {패키지이름 == 버전}`으로 특정 버전의 패키지를 다운받을 수 있다. 
버전을 따로 지정하지 않는 경우 가장 최신으로 깔리지만, 우리가 해볼 Django 같은 경우에는 버전별로 문법이 많이 바뀌기 때문에 웬만해서는 버전을 지정하여 설치하는 것이 좋다.
  - 지우고 싶으면 `poetry remove {패키지이름}`으로 지울 수 있다.
  - dev-dependencies로 저장하려면 `poetry add --dev {패키지이름}`
- pyproject.toml 파일에서 tool.poetry.dependencies와 tool.poetry.dev-dependencies 목록을 통해 패키지들이 설치되었는지 확인할 수 있다.
  - dev-dependencies에는 개발에만 필요하고 실행에는 필요치 않은 라이브러리를 설치한다. 실행과 개발에 필요한 라이브러리를 나눠서 관리해야 비용이 절약되고 효율적이다. 

정리하자면, pyenv는 파이썬 버전관리로서 프로젝트마다 각기 다른 환경, 각기 다른 버전의 파이썬을 사용할 수 있게 하며, virtualenv는 이를 위한 가상환경을 구축해준다. poetry는 그 가상환경 안에서 이용한 package를 잘 관리하기 위한 도구이다.

## decorator



