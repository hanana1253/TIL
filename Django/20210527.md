# Django 

## 인상 깊은 조언

## 지난 시간 복습

### CBV(Class Based View)
- CBV 호출 순서: `as_view()` -> `setup()` -> `dispatch()`
- `setup()`은 어트리뷰트 세팅하고 `dispatch()` 호출, `dispatch()`는 HTTP 메서드에 맞는 get이나 post 등의 함수 호출

### 로그인 데코레이터
- `from django.contrib.auth.decorators import login_required`으로 import해준다.
- FBV에 적용하기: 장고가 만들어둔 다양한 데코레이터(e.g. `@login_required`)를 통해 해당 함수 호출 전후의 작업을 해줄 수 있다.
- CBV에 적용하기: FBV와는 다르게 해야한다.
  -`@method_decorator(login_required, redirect_name='dispatch')`: get요청인지 post요청인지 확인해야 하므로 dispatch로 보내줘야 한다.
- CBV에서는 mixin을 상속받고 변수를 재할당해주는 게 더 편할 수 있다.
```python
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views import View

class ClassDetailView(LoginRequiredMixin, View):
    redirect_field_name = None
    login_url = '/student/login/'
    # 이하생략
```

### Service Layer 분리하기
- url로 요청이 들어오면 view를 호출하고, views에서 service를 호출하면 service layer에서 DB 접근을 한다.
- views가 해야 하는 작업이 분배되므로 views가 얇아지고 책임소재가 명확해지므로 문제가 생겼을 때 어떤 파일을 보아야 하는지 파악이 용이하다.
- Static Method: 인스턴스화 하지 않아도 class 자체 메서드로 사용할 수 있다.
- DTO(Data Transfer Object): views와 service가 교환할 패턴을 dataclass로 정리해둔 것
  - dataclass: 어떤 데이터가 있는지 목록과 type만 작성해두면 `__init__` 없이도 편리하게 정의가 가능하다.
  - views에서 받은 request를 dto 형태로 만들어 service에 전달한다.





## 느낀 점
