# Django 

## 인상 깊은 조언

## 지난 시간 복습

### CBV(Class Based View)
- CBV 호출 순서: `as_view()` -> `setup()` -> `dispatch()`
- `setup()`은 어트리뷰트 세팅하고 `dispatch()` 호출, `dispatch()`는 HTTP 메서드에 맞는 get이나 post 등의 함수 호출

### 로그인 데코레이터
- `from django.contrib.auth.decorators import login_required`으로 import해준다.
- FBV에 적용하기: 장고가 만들어둔 다양한 데코레이터(e.g. `@login_required`)를 통해 해당 함수 호출 전후의 작업을 해줄 수 있다.
- CBV에 적용하기: FBV와는 다르게 해야한다.
  -`@method_decorator(login_required, redirect_name='dispatch')`: get요청인지 post요청인지 확인해야 하므로 dispatch로 보내줘야 한다.
- CBV에서는 mixin을 상속받고 변수를 재할당해주는 게 더 편할 수 있다.
```python
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views import View

class ClassDetailView(LoginRequiredMixin, View):
    redirect_field_name = None
    login_url = '/student/login/'
    # 이하생략
```

### Service Layer 분리하기
- url로 요청이 들어오면 view를 호출하고, views에서 service를 호출하면 service layer에서 DB 접근을 한다.
- views가 해야 하는 작업이 분배되므로 views가 얇아지고 책임소재가 명확해지므로 문제가 생겼을 때 어떤 파일을 보아야 하는지 파악이 용이하다.
- Static Method: 인스턴스화 하지 않아도 class 자체 메서드로 사용할 수 있다.
- DTO(Data Transfer Object): views와 service가 교환할 패턴을 dataclass로 정리해둔 것
  - dataclass: 어떤 데이터가 있는지 목록과 type만 작성해두면 `__init__` 없이도 편리하게 정의가 가능하다.
  - views에서 받은 request를 dto 형태로 만들어 service에 전달한다.

## CBV로 학생 조회 페이지 만들기 (Continued)
### 로그인 기능
- 회원가입 기능과 거의 유사하지만 복습 차원으로 다시 한 번 해보자

#### 템플릿 만들기
- 로그인을 위해 아이디와 비밀번호를 받는 템플릿 'login.html' 을 만든다. 
- 로그인 입력에 에러가 있을 시 띄워줄 메시지 부분을 마크업한다.
- form 태그 post 요청 메서드로 지정하고, student 앱의 login으로 url 경로 설정해준다.
```html
{% if error.state %}
<h2>{{ error.msg }}</h2>
{% endif %}
<form method="POST" action="{% url 'student:login' %}">
  {% csrf_token %}
  <input type="text" name="userid" placeholder="아이디를 입력하세요" />
  <input type="password" name="userpw" placeholder="비밀번호를 입력하세요" />
  <button type="submit">로그인</button>
</form>
```
#### url 설정하기
- LoginView를 `as_view()`로 호출하는 경로를 urls.py에 추가해준다.
```python
# student 앱의 urls.py

app_name = 'student'

url_pattern = [
    path('login/', LoginView.as_view(), name='login'),
    # 나머지 경로는 생략
]
```

#### dto와 login함수 만들기
- dataclass로 로그인에 필요한 request의 정보를 받을 패턴을 지정해준다.
```python
# services.py에 있지만 dto파일을 따로 빼주는 것이 결국엔 좋다.

@dataclass
class LoginDto():
    userid: str
    userpw: str
```
- 원래 있던 UserService 클래스의 정적 메서드로 login 함수를 만들어준다.
  - 입력값이 비거나 아이디가 없거나 비밀번호가 틀리는 경우 해당 에러메시지를 담은 객체를 리턴
  - 에러를 피한 경우 `auth.authenticate`로 인증된 유저객체를 담아 리턴
```python
# student의 services.py

class UserService():
    @staticmethod
    def login(dto: LoginDto):
	if not (dto.userid and dto.userpw):
	    return {'error': {'state': True, 'msg': ERROR_MSG['MISSING_INPUT']}}

	if len(User.objects.filter(username=dto.userid)) == 0:
	    return {'error': {'state': True, 'msg': ERROR_MSG['INVALID_ID']}}

        auth_user = auth.authenticate(username=dto.userid, password=dto.userpw).first()
	if not auth_user:
	    return {'error': {'state': True, 'msg': ERROR_MSG['INVALID_PW']}}

        return {'error': {'state': False}, 'user': auth_user}
```

#### LoginView 클래스 만들기
- get 요청에 대해서는 로그인페이지를 렌더링
- post 요청에 대해서는 dto를 넘겨주는 함수로 dto를 만들고, 이를 service에서 작업하게끔 넘겨준 후 result 라는 변수에 결과물을 받는다.
  - result의 에러가 True인 경우 에러메시지를 context에 담아 렌더링
  - 에러 없으면 result로 받은 유저객체를 로그인 후 리다이렉트
```python
class LoginView(View):
    def get(self, request, *args, **kwargs):
	return render(request, 'login.html')

    def post(self, request, *args, **kwargs):
	login_dto = self._build_login_dto(request.POST)
	result = UserService.login(login_dto)
	if result['error']['state']:
	    context = { 'error': result['error'] }
	    return render(request, 'login.html', context)

	auth.login(request, result['user'])
	return redirect('index')
	
    @staticmethod
    def _build_login_dto(post_data):
	return LoginDto(userid=post_date['userid'], userpw=post_data['userpw'])
```



## 느낀 점
