# Django 

## 인상 깊은 조언
- CBV와 FBV는 서로 대척점에 있는 것이 아니라 조합하여 사용하는 것. CBV를 더 나중에 배우니까 더 중요하고 어려운 것으로 생각하지만 더 낫거나 심화된 것이 아니다.

## 지난 시간 복습
- URL 기준으로 app을 나누어 설계하고 모델을 분리할 수 있다.
  - REST API: 뜻과 활용
  - 앱의 핵심 모델이 곧 앱이라고 생각할 수도 있다.
  - urls.py에 `app_name`이라는 변수를 통해 url name을 지정할 수 있다.
- 비즈니스 로직 분리에 대한 다양한 의견
  - fat models: 모델의 class 안에 메서드로 비즈니스 로직을 만든다. views에서는 이를 통해 만든 메서드를 활용하며, 서비스가 작으면 괜찮지만 커질수록 모델에 가중이 많이 쏠릴 수 있따.
  - service layers: 모델을 조회하는 것, 즉 DB에 대한 부분(filter, get 등 쿼리를 날리는 작업)을 모두 service layer에서 한다. views는 controller 역할만 하므로 얇아진다는 장점이 있지만, 서비스 규모가 그닥 크지 않다면 나누는 과정이 오히려 비효율일 수 있다.

## CBV(Class Based View)
- 함수형 뷰(FBV, Function Based View)의 불편함을 개선하는 방법
- 장점: 재사용성이 높아지고, 코드 중복이 줄어든다. 장고에 내장된 class view를 상속받으면 코드 라인 수가 혁명적으로 줄어든다.
- 단점: 로직이 복잡(상속과 믹스인이 많아질 경우)해지면 FBV보다 가독성이 떨어진다.  간단한 로직의 경우에 클래스를 일부러 정의하는 건 배보다 배꼽이 더 큰 격.
- 클래스 상속으로 모델코드의 중복을 개선하고, service layer에서의 class 기반 작업을 통해 signup, login 등의 auth 기능을 구현해보자.

### 클래스 상속으로 모델 중복 문제 개선
- `is_deleted`나 `created_at` 등은 모든 데이터에 똑같이 적용되는 필드이다.
- 이를 각 모델마다 가지고 있으면, 어떤 필드를 가지고 있는지 읽을 수는 있지만 모델마다 변수명이 달라지거나 필드 옵션이 달라질 수 있다는 문제가 있다.
- 같은 필드를 묶어 클래스로 정의하여 상속함으로써 공통코드의 일관성과 효율성을 활보할 수 있다.
- manage.py와 같은 레벨에 behaviors.py라는 파일을 생성하여 BaseFields라는 클래스를 만들어본다.
  - 필드 정의에 필요한 models를 import한다.
  - 상속만을 위한 모델이므로 꼭 클래스 안에 'abstract=True'인 Meta 클래스가 정의되어야한다. 이를 해주지 않으면 migrations 할 때 필요없는 테이블이 생성된다.
```python
# behaviors.py
from django.db import models
import time

class BaseFields(models.Model):
    is_deleted = models.BooleanField(default=False)
    created_at = models.TextField(default=time.time())
    updated_at = models.TextField(null=True, blank=True)

    class Meta:
	abstract = True
```
- 앱 내의 models.py에서는 `from behaviors import BaseFields`로 import한 후 클래스를 상속한다.
```python
# student 앱의 models.py
from django.contrib.auth.models import User
from django.db import models
from behaviors import BaseFields

class Classroom(BaseFields):
    class_num = models.IntegerField()
    teacher = models.CharField(max_length=8)

class Student(BaseFields):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='student')
    classroom = models.ForeignKey(Classroom, on_delete=models.PROTECT, related_name='students')
    name = models.CharField(max_length=8)
    intro = models.TextField()
```
- 파이썬은 다중 상속을 지원하므로 쉼표로 여러 개의 상속받을 클래스이름을 넣을 수 있다.
- 라인 수만 줄이는 것 뿐 아니라 공통된 네임필드를 일관적으로 유지할 수 있다는 의의를 갖는다.
- 상속받는 클래스의 필드만 필요하고 추가할 필드가 없으면 pass로 클래스 정의를 끝낼 수 있다.


### URL 설계를 위한 REST API


### 프로젝트 안에서 앱을 나누기

### 비즈니스 로직 처리 위치에 대한 다양한 의견
### Service Layers 실습

## 느낀 점
- 방법론이 참 많기도 한 걸 보니 사람들은 정말 똑똑하다.
- REST에 대해 공부하던 중에 수업에서도 마침 타이밍 좋게 배울 수 있어서 좋았다.
