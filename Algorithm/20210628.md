# 자료구조와 Algorithm

## 지난 시간 복습
- 배열 기반 이진트리로 DFS를 구현해보았다.
- 하지만 일반적으로 배열기반보다는 노드기반 DFS를 더 자주 보게 될 것이므로 이번 시간에는 노드 기반으로 구현해보자.

## 수업 내용

### 노드 기반 완전이진트리
- 배열 기반 이진트리에는 값이 바로 배열의 요소로 들어갔지만, 노드 기반은 배열 속에 노드객체가 들어간다.

#### 생성 구현
- 0부터 6까지의 일곱 개 요소를 갖는 리스트를 인자로 넘겼을 때 이진트리로 만들어내는 클래스를 생성해보자
- 먼저 value를 자신의 값으로, left와 right을 None으로 갖는 노드객체를 생성하여 리스트에 넣는다.
```python
class Node:
    def __init__(self, value, left, right):
	self.value = value
	self.left = left
	self.right = right

class BinaryTree:
    def __init__(self, arr):
	self.node_list = [Node(value, None, None) for value in arr]
	for idx, node in enumerate(self.node_list):
	    lt = idx * 2 + 1 
	    rt = idx * 2 + 2
	    # 노드객체의 left, right 변수와 구분하기 위해 인덱스에는 lt, rt로 표기
	    if lt < len(self.node_list):
		node.left = self.node_list[lt]
	    if rt < len(self.node_list):
		node.right = self.node_list[rt]
	self.root = self.node_list[0]
```

#### 노드 기반 완전이진트리의 DFS 탐색
- 전위순회
```python
class BinaryTree:
    def __init__(self, arr):
	#생략

    def preorder(self):
	def DFS(root):
	    if self.root = None:
		return 
	    else:
	    	print(root.value)
		DFS(root.left)
		DFS(root.right)

	DFS(self.root)
```
- 중위순회와 후위순회는 동일한 코드에 print문이 DFS 재귀호출의 중간, 뒤쪽에 자리한다.

#### 순회방식의 차이
- 왜 전위, 중위, 후위 순회를 하는 것일까? 분할정복정렬 등에 필요하기 때문이다. (여기는 자세히 이해 못했음)
- 후위 순회의 경우 병합정렬은 왼쪽 오른쪽을 모두 정렬한 후에야 부모 노드 수준에서 정렬이 가능하다.

### BFS(Breadth First Search, 너비우선탐색, 상태트리탐색)
- 루트(0레벨)부터 간선(edge)을 n번 거쳐가는 노드는 n레벨이라고 할 수 있다. 
- leaf node까지 뻗어나가는 게 아니라 부모노드부터 레벨 순서대로 순회방문하는 것이 BFS 탐색
- 최소거리, 최단거리, 최소횟수 등을 구하라고 하면 무조건 BFS
- 주어진 문제를 상태로 하는 트리를 만들기 때문에 상태트리탐색이라고도 한다.
- 최소의 원하는 답을 얻은 후에는 더이상 순회하지 않고 return한다.

#### 노드 기반 완전이진트리의 BFS 탐색
- 아까 만든 BinaryTree 클래스에 메서드로 구현하자
- 최상단 노드를 큐에 넣고 (deque 모듈 사용) while문으로 빈 Q가 나올 때까지 순회한다.
- while문에서는 Q에서 꺼낸 노드의 값을 출력한 후 해당 노드가 자식노드를 가졌다면 왼쪽 자식부터 큐에 넣어준다.
  - 큐에 넣은 순서대로 실행되므로 현재의 왼쪽 자식의 자식, 즉 손자 노드가 큐에 들어가더라도 오른쪽 자식보다 나중에 출력된다.
```python
from collections import deque

class Node:
    def __init__(self, value, left, right):
	self.value = value
	self.left = left
	self.right = right

class BinaryTree:
    def __init__(self, arr):
	self.node_list = [ Node(value, None, None) for value in arr ]
	for idx, node in enumerate(self.node_list):
	    lt = idx * 2 + 1
	    rt = idx * 2 + 2
	    if lt <= len(self.node_list):
		node.left = self.node_list[lt]
	    if rt <= len(self.node_list):
		node.right = self.node_list[rt]

	self.root = self.node_list[0]

    def bst(self):
	Q = deque()
	Q.append(self.root)
	while Q:
	    cur = Q.leftpop()
	    print(cur.value)
	    if cur.left != None:
		Q.append(cur.left)
	    if cur.right != None:
		Q.append(cur.right)

```
	
	
#### BFS 알고리즘 문제 풀이- 송아지 찾기 
- 수직선 상에서 목표지점까지의 최소 이동 횟수 구하기


### 그래프(Graph)
- 객체 간에 짝을 이루는 구조를 나타내기 위한 위한 가장 유연한 자료 구조
- `G(V, E)`로 표현하는데, V는 voltex(종점), E는 edge(간선)을 나타낸다.
  - c.f. 트리 또한 종점과 간선의 집합이지만, cycle이 없다. 그러므로 트리의 노드가 n개이면 n-1개의 edge가 존재하지만 그래프는 그렇지 않다.
- 그래프는 사이클이 있을 수도, 없을 수도 있다.
  - 경로는 한 번 방문한 노드를 다시 방문해서는 안된다.
  - c.f. 트리는 한 노드에서 다른 노드로 갈 때 경로가 유일하다.
- 

#### 그래프 종류 및 관련 용어
- 무방향/방향; 이동 방향이 상관없는 / 한쪽으로만 이동이 가능한 그래프
- 가중치: 해당 edge를 선택했을 때 걸리는 시간이나 비용 등
- cycle(circuit): 노드가 이어져 서로 순회 시 도는 것으로, 사이클/서킷의 크기는 방문하는 노드의 개수로 정해진다.
- connected/disconnected: 모든 노드가 연결되어있는 것 / 분리된 노드가 있는 것

#### 인접행렬(Adjacency Matrix)
#### 인접리스트(Adjacency List)

#### 스킬트리 (순서가 있는 필수요구사항 충족여부 판단)

#### 

### 이진트리(Binary Tree) for DFS (Depth First Search)

#### 이진트리의 순회방식
#### 구현하기 pseudocoding
## 느낀 점
- 큐 안에도 선형 큐, 원형 큐, 노드기반 큐 등 여러가지 종류가 있다니 재미있다.
- 트리구조를 배열 형태로 나타낼 수 있다는 게 흥미롭고 특히 순회 방식이 엄청 복잡할 줄 알았는데 단순히 프린트문의 위치에 따라 달라진다는 것은 인상적이었다. 
