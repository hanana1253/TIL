# Algorithm

## Greedy, Priority Queue
- 그리디 기법이란, 문제 푸는 단계마다 그 단계, 즉 현재 상태에서 가장 좋은 것을 선택하는 것.
  - 그렇게 하여 최적의 상태가 되면 greedy 기법이 성공한 것
  - 그 기법으로 했을 때 반례가 있으면 실패한 것이므로, 해결여부를 판단하는 데에는 반례 확인하는 것이 빠르다.
- 인생을 살다 보면 선택의 기로에 놓이는데, 그 때 보기에 가장 좋은 것을 선택하는 것이 Greedy 기법.
  - 근데 나중에 가면 후회스러운 선택이 될 수도 있으므로 최적화하는 게 필요하다.
  - 최적화하는 것은 동적계획법(dynamic 기법)으로 푼다.

## Max Heap 구현하기
- Max Heap이란 가장 큰 값이 root에 오는 이진트리 자료구조이다.


## 문제 풀기

### 가장 적은 수의 동전으로 거스름돈 만들기
- 특정 금액을 완성하기 위해 필요한 가장 적은 동전의 수를 구한다.
- 입력: 동전의 금액이 각 단위마다 오름차순으로 담긴 배열 nums와 목표 금액 m
- 출력: 목표금액을 만드는 동전의 최소개수

#### Pseudocoding
- nums를 reverse로 내림차순으로 놓은 후, 가장 큰 동전의 금액으로 목표금액을 나눈다. 
- 나눈 몫은 answer에 더하고 나머지는 그 다음 목표금액으로 설정한 다음 그다음 큰 단위의 금액으로 나누어 동일한 작업을 반복한다.
- 큰 금액부터 목표금액을 빼면서 내려오므로 가장 적은 수의 동전으로 거스름돈을 만들 수 있다. 
- 유의할 점: 큰 단위 동전의 금액이 항상 작은 단위 동전 금액의 배수인 일반적 경우에만 성립한다. 만약 그렇지 않는다면 [1, 5, 12] 에서 15를 만드는 최소개수는 5*3의 3개인데 1*3, 12*1의 4개로 답이 나올 수 있다.

#### 코드 구현
```javascript
function solution(nums, m){
  let answer = 0;
  nums.reverse();
  for (let i=0; i<nums.length; i++) {
  // 또는 for (let coin of nums){
    answer += parseInt(m/nums[i]);
    m = m % nums[i];
  }
  return answer;
}

console.log([1, 5, 10], 15) // 2
```

### 필요한 구명보트 최소 개수 구하기
- 구명보트 하나에는 2명 이하만 탈 수 있으며, 탈 수 있는 무게도 Mkg 이하로 제한되어있다. n명의 승객 몸무게가 주어졌을 때 승객 모두가 탈출하기 위한 구명보트 최소개수를 구하라 (승객 몸무게는 m을 넘지 않는다.)
- 입력: 승객 몸무게가 담긴 배열 nums, 구명보트 무게 제한기준  m
- 출력: 모든 승객을 탈출시키기 위한 구명보트의 최소 개수

#### Pseudocoding
- 승객을 몸무게 오름차순으로 나열한 후, 가장 무거운 승객과 가장 가벼운 승객을 짝지어 구명보트에 태운다. 
  - 이 때 둘의 무게가 제한기준을 초과하면 무거운 승객만 태운다.
- 양 끝에서 가운데로 좁혀들어가며, 둘씩 짝지어 보내거나 무거운 사람만 보내면서 보트 수 count를 반복한다.
- nums를 `sort()`로 정렬한 후 lt를 0번 인덱스로, rt를 마지막 인덱스로 세팅한다.
- lt에 해당하는 승객 몸무게와 rt에 해당하는 승객 몸무게를 더해 m보다 크면 rt만 좌측으로 인덱스를 옮기고 보트 수에 count++
- lt와 rt 승객 몸무게를 더했을 때 m보다 작거나 같으면 lt도 우측으로 인덱스를 옮기고 보트 수 count++
- while문으로 lt보다 rt가 작아질 때까지 반복한다. 마지막에 lt가 rt랑 같은 경우, 즉 같은 승객을 가리키고 있는 경우에도 무게와 상관없이 보트 수를 한 번 count하고 rt가 작아지면서 while문을 빠져나가므로 신경쓰지 않아도 된다.

#### 코드 구현
```javascript
function solution(nums, m){
  let answer = 0;
  nums.sort((a, b) => a - b);
  let lt = 0, rt = nums.length-1;
  while (lt <= rt) {
    if ( nums[lt]+nums[rt] <= m ) lt++;
    rt--;
    answer++;
  }
  return answer;
}

console.log(solution([90, 50, 70, 100, 60], 140)) // 3
```

### 회의실 하나에 가장 많은 회의 배정하기
- 하나의 회의실을 사용하고자 하는 여러 회의가 시작시간, 마치는 시간을 가진 요소의 배열로 주어진다. 이 때 각 회의가 겹치지 않으면서 사용할 수 있는 회의의 최대 개수를 구하라. 
  - 끝나는 시간과 동시에 다음 회의가 시작할 수 있다.
  - 시작과 동시에 끝나는 회의도 가능하다고 가정한다.
- 입력: 시작 시간(0번 index)과 끝나는 시간(1번 index)을 가진 회의정보의 배열 meeting
- 출력: 최대 회의 개수

#### pseudocoding
- 여러 회의를 끝나는 시간 기준으로 오름차순 정렬한다.
  - 끝나는 시간이 같은 경우에는 시작시간의 오름차순을 기준으로 정렬한다.
- 기준 시간을 변수에 0으로 잡아둔다.
- for문을 돌면서 기준시간보다 회의의 시작시간이 크거나 같은 경우에만 회의를 count하고 해당 회의 끝나는 시간으로 시간을 갱신한다.

#### 코드 구현
```javascript
function solution(meeting) {
  meeting.sort( (a, b) => a[1] - b[1] || a[0] - b[0] );
  let answer = 0;
  let endtime = 0;
  for (let i = 0; i < meeting.length; i++){
    if (endtime <= meeting[i][0]) {
      answer++;
      endtime = meeting[i][1];
    }
  }
  return answer;
}
console.log(
  solution([
    [1, 4],
    [2, 3],
    [3, 5],
    [4, 6],
    [5, 7],
  ])
); // 33
```

### 배열에서 가장 큰 두 수의 차를 뺸 값을 넣으며 마지막에 남는 수 구하기
- 
#### pseudocoding
#### 코드 구현
#### 문제 및 입출력
#### pseudocoding
#### 코드 구현
#### 문제 및 입출력
#### pseudocoding
#### 코드 구현
## 느낀 점



