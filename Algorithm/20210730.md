# Algorithm

## Greedy, Priority Queue
- 그리디 기법이란, 문제 푸는 단계마다 그 단계, 즉 현재 상태에서 가장 좋은 것을 선택하는 것.
  - 그렇게 하여 최적의 상태가 되면 greedy 기법이 성공한 것
  - 그 기법으로 했을 때 반례가 있으면 실패한 것이므로, 해결여부를 판단하는 데에는 반례 확인하는 것이 빠르다.
- 인생을 살다 보면 선택의 기로에 놓이는데, 그 때 보기에 가장 좋은 것을 선택하는 것이 Greedy 기법.
  - 근데 나중에 가면 후회스러운 선택이 될 수도 있으므로 최적화하는 게 필요하다.
  - 최적화하는 것은 동적계획법(dynamic 기법)으로 푼다.

## 문제 풀기

### 가장 적은 수의 동전으로 거스름돈 만들기

#### 문제 및 입출력
- 특정 금액을 완성하기 위해 필요한 가장 적은 동전의 수를 구한다.
- 입력: 동전의 금액이 각 단위마다 오름차순으로 담긴 배열 nums와 목표 금액 m
- 출력: 목표금액을 만드는 동전의 최소개수

#### Pseudocoding
- nums를 reverse로 내림차순으로 놓은 후, 가장 큰 동전의 금액으로 목표금액을 나눈다. 
- 나눈 몫은 answer에 더하고 나머지는 그 다음 목표금액으로 설정한 다음 그다음 큰 단위의 금액으로 나누어 동일한 작업을 반복한다.
- 큰 금액부터 목표금액을 빼면서 내려오므로 가장 적은 수의 동전으로 거스름돈을 만들 수 있다. 
- 유의할 점: 큰 단위 동전의 금액이 항상 작은 단위 동전 금액의 배수인 일반적 경우에만 성립한다. 만약 그렇지 않는다면 [1, 5, 12] 에서 15를 만드는 최소개수는 5*3의 3개인데 1*3, 12*1의 4개로 답이 나올 수 있다.

#### 코드 구현
- 입력: [1, 5, 10], 15
- 출력: 2
```javascript
function solution(nums, m){
  let answer = 0;
  nums.reverse();
  for (let i=0; i<nums.length; i++) {
  // 또는 for (let coin of nums){
    answer += parseInt(m/nums[i]);
    m = m % nums[i];
  }
  return answer;
}
```

## 느낀 점



