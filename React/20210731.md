# React

## 인상 깊은 조언
- 요구사항을 먼저 머리로 proceed하고, 간단히 코드를 짜고, 문제를 찾고 디버깅한다.

## 배운 것
### Class Component에서 Function Component로 Migration
- state와 관련된 것은 `useState`로
- handler는 `useCallback`으로
- life cycle에 관련한 변화는 `useEffect`로

### 이미 불러온 페이지를 다시 불러오지 않도록 
- currentPage를 담기 위한 storedPages라는 빈 배열을 초기값으로 하여 상태 생성
- useEffect를 통해 fetch하기 전에 해당 currentPage가 있는지 먼저 확인해서 있으면 return
- 해당 currentPage가 없으면 원래대로 fetch로직을 실행하면서, storedPages에 currentPage를 넣는다.
```javascript
// storedPages 관련 변수와 함수만 기재
const Cats = () => {
    const [ currentPage, setCurrentPage ] = useState(0);
    const [ storedPages, setStoredPages ] = useState([]);

    useEffect(() => {
        if (storedPages.includes(currentPage)) return;

        const fetchBreeds = async () => {
            // API Call and LoadingIndicator logics
        }

        // storedPages에 currentPage를 넣은 새로운 값으로 갱신
        setStoredPages(storedPages.concat(currentPage));
        fetchBreeds();
    }, [ currentPage, storedPages ]);
    
    return (JSX 객체);
}
```

### Clean-up 함수
- `useEffect`에서 함수를 반환하면, 해당 함수는 unmount 시점에 실행된다.
- `useEffect`는 매 렌더링 이후 실행되므로 매번 clean-up도 실행된다.
  - 업데이트 된 후 새로운 값으로 실행되기 때문에 업데이트 된 props 값을 반영하며 버그를 줄인다.
- Timer 함수나 웹 소켓, 라이브러리 자원을 정리할 때 사용한다.


## 느낀 점
- 실제로 실습하면서 수업을 들어야 하는데 시간에 쫓겨서 듣기만 하니까 제대로 공부가 안된다. 날 잡아서 처음부터 다시 실습해봐야지
