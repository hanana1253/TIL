# React

## 인상 깊은 조언
- 요구사항을 먼저 머리로 proceed하고, 간단히 코드를 짜고, 문제를 찾고 디버깅한다.

## 배운 것
### Class Component에서 Function Component로 Migration
- state와 관련된 것은 `useState`로
- handler는 `useCallback`으로
- life cycle에 관련한 변화는 `useEffect`로

### 이미 불러온 페이지를 다시 불러오지 않도록 
- currentPage를 담기 위한 storedPages라는 빈 배열을 초기값으로 하여 상태 생성
- useEffect를 통해 fetch하기 전에 해당 currentPage가 있는지 먼저 확인해서 있으면 return
- 해당 currentPage가 없으면 원래대로 fetch로직을 실행하면서, storedPages에 currentPage를 넣는다.
```javascript
// storedPages 관련 변수와 함수만 기재
const Cats = () => {
    const [ currentPage, setCurrentPage ] = useState(0);
    const [ storedPages, setStoredPages ] = useState([]);

    useEffect(() => {
        if (storedPages.includes(currentPage)) return;

        const fetchBreeds = async () => {
            // API Call and LoadingIndicator logics
        }

        // storedPages에 currentPage를 넣은 새로운 값으로 갱신
        setStoredPages(storedPages.concat(currentPage));
        fetchBreeds();
    }, [ currentPage, storedPages ]);
    
    return (JSX 객체);
}
```

### Clean-up 함수
- `useEffect`에서 함수를 반환하면, 해당 함수는 unmount 시점에 실행된다.
- `useEffect`는 매 렌더링 이후 실행되므로 매번 clean-up도 실행된다.
  - 업데이트 된 후 새로운 값으로 실행되기 때문에 업데이트 된 props 값을 반영하며 버그를 줄인다.
- Timer 함수나 웹 소켓, 라이브러리 자원을 정리할 때 사용한다.
```javascript
// Cats 컴포넌트에 timer을 통해 접속 후 경과한 시간(count)을 보여주기
// Cats 컴포넌트 몸체 속
  const [ count, setCount ] = useState(0);

  // 다른 Cats 로직

  useEffect(() => {
    setInterval({
        setCount(count => count + 1);
    }, 1000);
  });

  return (
      <h1>{count}</h1>
      // 다른 Cats JSX
  );
```
- 위와 같은 곳에서 timer은 1초(1000ms)마다 1씩 늘어날 거로 기대하지만, 기하급수적으로 늘어난다.
  - `useEffect`가 실행되고 렌더링될 때(currentPage, timer로 count가 바뀔때마다) `setInterval`이 실행되면서 count를 올리는 timer를 마구마구 만들어낸다.
  - 이를 방지하기 위해서 매 렌더링마다 timer을 해제하고 다시 만들도록 `clearInterval`을 clean-up 함수로 리턴해준다.
```javascript
// 올바른 타이머 세팅
  useEffect( () => {
      const timerId = setInterval(() => {
          setCount(count => count+1);
      }, 1000);
      return () => {
          clearInterval(timerId);
      };
  })
```
- `useEffect`로 전달되는 콜백함수가 리턴하는 clean-up 함수는 class component의 `componentWillUnmount`가 실행되는 시점, 즉 unmount되기 전에 리액트에 의해 실행된다.



### Clean-up 함수를 넘겨줘야 하는 이유
- 마구마구 생겨난 timer로 내가 기대하는 결과물을 얻지 못한다는 점도 문제이지만, 페이지 변경하고 나서도 위와 같은 timer는 브라우저 메모리에 계속 남아있어 나중에 꽉 차면 먹통을 만든다. 
  - Memory Leak을 막기 위해 clean-up 함수를 전달해줘야 한다.
- 

## 느낀 점
- 실제로 실습하면서 수업을 들어야 하는데 시간에 쫓겨서 듣기만 하니까 제대로 공부가 안된다. 날 잡아서 처음부터 다시 실습해봐야지
