# React
지난 시간에 땡땡이 쳐서 못 배운 form 부분을 공식문서로 급히 읽고 수업 들음

## React Form
- Form component를 만들고 각 input의 onChange에 콜백함수를 주어 렌더링에 반영한다.
- validation은 onChange의 콜백함수 안에서도 할 수 있고, useEffect에서 처리할 수도 있다.
  - validation 코드는 컴포넌트 외부에 놓거나, src/utils/validation.js로 빼서 import하면 다른 컴포넌트에서도 쓸 수 있다.

### Validation 스타일링 
- invalid 한 input 요소를 눈에 띄게 만드는 방법에는 무엇이 있을까
  - scss로 준비해둔 스타일 선택자를 삼항연산자로 부여한다.
  - classNames라는 패키지. `classNames('foo', {'bar': true})`인 경우 foo와 bar이 모두 클래스에 들어간다. 이를 활용하여 `classNames({'input-invalid': validation })`의 키값으로 validation 부분에 불리언 리턴하는 코드를 넣어준다.
- 아직 입력하지조차 않았는데 처음부터 invalid하다고 뜨면 UX에 좋지 않다. 적어도 해당 input에 접근하고 나서 invalid style이 뜰 수 있도록 하자.
  - isVisited라는 boolean 값을 만들어, onFocus 시 true 가 되도록 한 후 validation에 and 조건으로 넣어준다.

### Uncontrolled Component
- 대부분의 form 요소는 리액트에서 처리가 가능하다. 그러나 file type input 등 리액트 밖에서 처리하는 것과 같이 동작시켜야 하는 요소가 있다. 이를 비제어 컴포넌트라고 한다.
- 제어 컴포넌트는 `useState`등으로 관리할 수 있지만, `<input type="file" ... />`인 경우는 파일에 접근하기 어렵다. 
  - 이럴 때 ref를 이용해서 해당 돔 요소에 접근하여 좌표 등의 정보를 가져오거나 수정할 수 있다.

### Redux vs.  SWR/React Query
- Redux: 전역상태관리를 위한 라이브러리
  - 과거에는 single source of truth로 데이터를 한 군데에서만 있게 하자는 의도로 redux나 mobx가 많이 쓰였다.
  - 그러나 이를 위한 코드량이 지나치게 비대해 유지보수가 까다로워지고, 거기에 비동기까지 들어가면 더 복잡해져서 redux나 mobx를 위한 코드나 또다른 library를 쓰게 되면서 너무 heavy해졌다.
  - action, dispatcher을 비롯한 최소 4개의 코드를 개발자가 작성해야 했다.
- SWR: Stale-While-Revalidate이라는 HTTP 캐시컨트롤 익스텐션에서 derived된 리액트 라이브러리, React Query도 이와 비슷
  - `useQuery` 훅스 하나로 데이터를 불러오며, 그 데이터에 대한 key 하나만 알고 있으면 접근하고 관리할 수 있다. 
  - 코드량이 적어지고 데이터를 꺼내오고 동기화하는 것이 편해진다.
- 서버에 있는 데이터와의 정보 동기화를 어떻게 할 수 있을까? 
  - 전통적 방법 1: HTTP 연결이 아니라 웹소켓으로 실시간으로 데이터가 바뀔 때마다 업데이트하기
  - 전통적 방법 2: setInterval로 API를 1초마다 찔러서 redux가 들고 있는 데이터를 갱신해준 후 해당 데이터를 dispatch로 업데이트하고 connect해서 리렌더링도 해주고... 굉장히 많고 복잡해진다
  - SWR / React Query는 이런 것들을 다 대신해주며, 웹소켓 없이도 업데이트 해준다. Interval마다 찔러주는 것을 데이터 식별 key(보통은 API url)만 넣으면 revalidate 해준다.

### React Hook Form
- validation을 쉽게 해주는 라이브러리
- `useState`나 handler을 따로 안 만들고 onChange로 `setState` 안해도 되도록 대신해준다.
- `const { register, handleSubmit } = useForm();` 하고 `<input { ... register { max_length: 20} }>`로 리턴하는 JSX에서 활용할 수 있다.
- 에러객체에 해당 input 이름을 key로 하는 값이 error로 들어가 있어 나중에 error가 어디서 났는지 알 수 있다.
- 렌더링도 적게 해주고 validation과 error에 대한 코드량을 절약할 수 있어 현업에서 많이 쓴다.

### Fragment
- JSX 또한 다른 리턴문들과 같이 하나의 값만 리턴할 수 있다. 
- 여러 요소를 갖는 컴포넌트는 쓸데없는 div로 씌워야 하는 경우가 생긴다.
- 이를 방지하기 위해 `<React.Fragment>`로 감싸면 DOM에 붙일 때 알아서 사라지며, `<>`로도 쓸 수 있다.

### Portal
- div 태그 하나를 root로 렌더링하고 있지만, 모달창을 root 밖에 만들어 띄워야 하는 등 밖에서 렌더링해야 하는 경우가 있다. 
- body 태그에 root div의 sibling으로 다른 div를 만들고, id값을 portal로 줄 것
- `import { createPortal } from "react-dom";` 한 후 위에서 만든 DOM 요소를 가져온다.
- Portal 콤포넌트를 만들되, props를 받을 수 있다. 
  - `createElement`로 portal에 넣어줄 요소를 `modal`이라고 하자.
  - `createPortal(props, modal)`을 넣어 반환하면, 첫 인자를 두번째 인자에 렌더링해준다. 
```javascript
// Portal component 만들기
import { useEffect } from 'react';
import { createPortal } from "react-dom";


export const Portal = ({children}) => {
  const portalRoot = document.querySelector('#portal');
 const modal = document.createElement('div');

  useEffect(() => {
    portalRoot.appendChild(modal);
    return () => portalRoot.removeChild(modal);
  } , [ portalRoot, modal ])

  return createPortal(children, modal);
}
```
