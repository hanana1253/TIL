# React
## 인상 깊은 조언
- 취업준비를 할 때 내가 무엇을 목표하는지 잘 고민해야. 
  - 스스로가 무엇을 원하는지 잘 정리하지 않고 취업하면 스트레스 받을 수도.
  - 안정적이고 편하지만 도전이 없는 환경에서 스트레스를 받을 수도 있고, 도전이 너무 많은 곳에서 스트레스 받을 수 있다.
- 이유와 동기를 명확히 가지고 학습하며, 인풋과 아웃풋을 통해 뇌에 남게끔 해야한다.
- 학습은 나의 뇌를 바꾸는 일이다.
- 기업 고르는 기준: 개발자가 어느정도 이미 있으며, 연봉을 후려치지 않는 곳.

## React의 탄생 배경
- 페이스북에서 2015년 전후로, 각 국가마다 다른 UI 제공하기 위해 다양한 버전으로 프론트엔드를 손볼 수 있도록 만들었으며 오픈소스로 발표한 자바스크립트 라이브러리

### 현대 프론트엔드 웹의 문제점
- 비디오 속의 버튼을 클릭 시 여러 탭으로 구성된 팝업창을 만들어보자.
  - vanilla js로는 팝업 창 속의 탭 정보를 모두 js가 들고 있어야 하며, let이나 var 키워드가 남발된다. 
  - 각 노드에 이벤트핸들러를 일일이 달아주고, 노드가 삭제되면 메모리 관리를 위해 또 일일이 해제해줘야 하며, callback 함수 안에서는 let으로 상태도 변경해줘야 한다.
  - 명령형으로 만든 코드의 양이 많아지고 가독성은 떨어지며 에러 리스크도 커진다. 
- 위와 같은 문제로 jQuery가 등장하였다.
  - DOM 노드 탐색과 순회, 이벤트핸들러 관리, Inline CSS 관리 등의 반복적인 작업을 대신함으로써 이벤트핸들러 등록을 편하게 해준다.
  - 비동기 요청에 대한 응답 처리도 쉽게 해주면서, 명령형 코드를 만들었을 때의 문제점을 해결해주었다.
  - 이 때문에 2000년대 초반부터 시대를 풍미하였고, 현재도 npm에서 가장 다운로드 수가 많다(개발자들이 다운로드하기보다는 jQuery로 만들어진 프로그램을 실행하며 다운로드가 이뤄지는 것이긴 하지만...)

### React 및 SPA(Single Page Application) 솔루션
- 직관적이고 간단한 방법의 화면구성 방법론 제시
- 컴포넌트 단위로 쪼개어 관련된 로직의 응집도를 높이면서 하나의 UI와 그에 대한 상태/동작을 하나의 컴포넌트가 담당하도록 함
- 단방향 데이터 흐름, 불변성(추후 설명)

#### Virtual DOM
- 실제 DOM을 변경하면 매번 렌더링이 일어나므로 브라우저가 CPU 메모리를 점유하며 과부하 발생 
- React를 비롯한 SPA 3대장(React, Angular, VueJS)은 따로 JS 객체를 만든다.
  - 이벤트 핸들러 등록 시 실제 DOM은 건드리지 않고 자신이 만든 가상 JS DOM에서 변경
  - 이런 변경사항을 한번에 모아 batch 처리로 하여, 필요한 경우에 렌더링을 실행한다.

#### 한계
- React에서는 a 태그 등 다른 곳으로 넘어가는 routing 기능을 자체적으로 가지고 있지 않아 3rd party library를 사용해야만 한다.
- 응집도를 높이기 위해 하나의 UI와 상태정보를 같은 컴포넌트 내에서만 가지게끔 몰아넣었는데, 주식사이트(e.g. Webull) 같이 같은 데이터를 여러 컴포넌트가 공유해야 하는 경우에 전역상태관리에 어려움이 있다. Context API라는 것으로 지원하기는 하지만 딱히 적절하지 않아서 해결책으로 나타난 것이 redux
- CSR(Client Side Rendering): SSR(Server Side Rendering)이 아니라 태그가 비어있는 상태로 온 후에 JS가 실행되면서 그려내기 때문에 검색 엔진 최적화(SEO)에 좋지 않다.
- SPA의 한계: 웹은 인터넷 상에서 공유되는 문서인데 SPA는 index.html 자체가 내용을 갖지 않기 때문에 문서로 보기 어려우며, 관리복잡도가 증가하고 첫 렌더링까지의 시간이 증가한다. 

### 실습환경 세팅
#### Nodejs와 npm
- Nodejs: 브라우저 밖에서 동작하는 JavaScript의 런타임 환경. 브라우저 JS는 ECMA 명세를 따르지만, Nodejs는 그와는 조금 다른 명세로 돌아간다.
- npm(Node Package Manager): Nodejs의 기본 패키지 관리자. React 등 온갖 사람들이 만든 다양한 패키지가 npm의 레지스트리 공간에 설치되어 있다.
- npx: npm 패키지 실행도구로, npm 5-6부터 지원되는 새로운 명령어.
  - 이 명령어를 사용하면 패키지가 리모트 서버에 있음에도 내가 다운받지 않고도 사용가능하다. (e.g. `$ npx create-react-app {프로젝트 이름}`
  - 다운받지 않고 실행만 해보고 싶을 때 가볍게 사용
- `$ npm install {설치하고 싶은 패키지 이름}`: npm 레지스트리에 있는 패키지를 설치할 수 있다. `-g` 플래그를 넣지 않으면 해당 폴더 안에만 패키지가 설치된다.

#### React App 만들기
1. 폴더를 만든 후 `$ npm init` 하고 `$ npm install react redux --save`
2. `$ npx create-react-app {프로젝트명}`
  - CRA가 우리 대신 npm install과 설정을 대신 해준다.
  - package.json의 scripts를 보면 react-script라는 명령어가 있는데, dependency에 있는 react-script가 있기 때문에 실행되는 것이다. 
    - React는 git이나 node 처럼 CLI에서 실행되는 명령어가 아니지만 react-scripts 덕분에 터미널 환경에서 쉽게 실행되게끔 하는 것.
  - `$ npm (run) start`: start에 한해서 run 을 생략해도 실행된다.
3. nextjs: react를 가지고 SSR을 기본적으로 해주는 프레임워크

#### CRA로 만든 React 앱 구조
- package.json
  - 사용하는 패키지의 버전과 스크립트 등을 명시한 파일
  - 웹을 만드는 모든 프로젝트에 항상 존재한다
  - npm은 자신의 위치에서 package.json을 찾고, `$ npm install`을 하면 파일 안의 패키지를 설치한다.
  - npm install은 한 때 순서대로 설치하느라 너무 느리다는 단점이 있었다. 이에 대한 솔루션으로 여러 패키지를 병렬로 설치하여 속도를 획기적으로 높인 yarn이라는 패키지 매니저를 누군가 만들었다. npm 5 이후부터 병렬 설치로 속도가 빨라졌다. yarn 도 버전 2 이후부터 획기적인 개선이 이루어졌다.
- public 폴더: index.html등 정적 파일(html, css, img)이 올라간다. 
  - webpack: react-scripts start 되면 index.html의 마지막 줄에 있는 script 태그를 넣어주고, 모든 js 파일을 하나로 뭉쳐낸 파일(bundle.js)을 만들어 public 파일에 넣고 이 파일을 불러온다. 
  - webpack 말고도 rollup, parcel, snowpack 등의 bundler이 있다.
- src 폴더: 우리의 관심사인 온갖 React 파일이 저장되는 곳
  - index.js: react app의 시작 지점으로, DOM 트리처럼 React 트리가 만들어져 index.html에 들어간다.
  - app.js: app component 트리의 최상단 지점

## 느낀 점
- 리액트를 비롯한 이런저런 것들이 무엇인지 이제 감이 조금씩 잡히는 기분
- 다양한 언어/라이브러리/방법론의 부침과 그 배경이 흥미롭다.
