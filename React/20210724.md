# React

## 인상 깊은 조언

## Function Component & Hooks
- class component와 대조되며, 이제는 대부분 function component 많이 쓴다.
- 기본적인 형태는 함수와 같으며 렌더링할 JSX 객체를 반환한다.

## class component에서 function component으로 가면서 바뀐 것
- 상태관리: `this.state`와 `this.setState`로 관리하던 것을 이제는 `useState`로!
- Life Cycle Method: `constructor`, `componentDidMount`, `componentWillUnmount`, `componentDidUpdate`를 `useEffect`로!
- props: 함수의 파라미터가 prop로, 그 props 그대로 `useState`에 사용  
- `shouldComponentUpdate`는 memo로 구현

## Function Component에서의 상태관리

### `useState`
- 상태를 정의하는 함수
  - 첫 번째 파라미터에 값을 넘기면 그 값이 상태의 초기값이 된다.
- 두 요소를 가진 배열을 반환
  - 첫 번째 요소는 관리할 상태
  - 두 번째 요소는 그 상태를 업데이트하는 setter 함수이다.
  - 배열 디스트럭쳐링 할당으로 받는다.
- class component의 `this.setState`는 merge 방식, function component의 `useState`는 override 방식으로 상태를 업데이트
  - 객체를 병합하는 것이 아니라 setter함수가 받은 값으로 바꿔치기
- setter 함수는 값을 받을 수도, 함수를 받을 수도 있다.
  - 값을 받으면 비동기적으로 그 값으로 상태를 업데이트
  - 함수를 받으면 함수의 첫 번째 파라미터에 이전 상태를 전달
```javascript
import { useState } from 'react'

function App() {
  return (
    <Counter />
  )
}

function Counter() {
  const [ count, setCount ] = useState(0);
  const handleClick = () => {
    setCount((prevCount) => prevCount +1 );
  }
  return (
    <section>
      <span>{count}</span>
      <button onClick={handleClick}>Plus 1</button>
    </section>
  )
}
```

#### Lazy Initial State
- `useState`에 전달된 초기상태는 첫 렌더링 이후에는 무시된다. 
  - 초기 상태를 계산하는 과정이 비싼 연산이라면?
```javascript
import { useState } from 'react'

function getCount() {
  return Array(100000).fill(1).reduce((acc, cur)=> acc + cur, 0)
}

function App() {
  return (
    <Counter />
  )
}

function Counter() {
  const expensivelyCalculatedCount = getCount()
  const [ count, setCount ] = useState(expensivelyCalculatedCount)
 
  const handleClick = () => {
    setCount( prevCount => prevCount + 1 )
  }
  
  return (
    <section>
      <span>{count}</span>
      <button onClick={handleClick}>Plus 1</button>
    </section>
  )
}
```
  - 위와 같은 작업은 `handleClick`이 호출되어 리렌더링 될때마다 비싼 연산을 계속 한다.
- 이를 방지하기 위한 것이 Lazy Initial State
- 비싼 연산을 하는 함수를 호출한 결과를 초기값으로 넣는 것이 아니라, 비싼 연산을 하는 함수를 호출하는 함수를 `useState`의 파라미터에 콜백으로 넣는다.
```javascript
// Counter 함수 컴포넌트의 함수 몸체 내부
// 비싼 연산을 하는 함수를 매번 호출하는 초기값
const expensivelyCalculatedCount = getCount()
const [ count, setCount ] = useState(expensivelyCalculatedCount)

// 비싼 연산을 하는 함수를 콜백으로 넣은 초기값
const [ count, setCount ] =  useState( () => getCount() )
```
  - 이렇게 함수를 넘기면 React는 함수가 반환한 값을 한 번만 계산하여 사용, 그 뒤에 일어나는 렌더링 때는 계산하지 않는다.
- React는 이전 상태와 새 상태가 같다면 함수 컴포넌트를 실행(리렌더링)하지 않는다.
  - ObjectIs 알고리즘을 사용하여 무시하는 방식으로 자체최적화

#### `useState`의 특성
- setter함수 실행한다고 바로 렌더링에 반영되지 않는다.
  - 새로운 값을 받으면 실행 시 곧바로 렌더링을 다시 하는 것이 아니라, component rerendering queue에 등록해두고 React가 나중에 처리한다.
  - 새 값들을 모아서 리렌더링에 사용하는 batch 처리방식
- function component에서 리렌더링 시 모든 함수가 재실행되지만 `useState`는 한 번만 실행된다.
  - setter함수는 동일성이 보장된다. 즉 첫 번째로 반환했던 setter함수의 값을 리액트가 기억하고 있으므로, 재실행하더라도 새 함수를 만들어 반환하지 않고 기존함수를 사용한다.
  - setter함수는 dependency array에 넣지 않아도 된다.
- `useState`에 콜백함수를 전달하면 이 함수는 초기 렌더링에만 실행된다. 
  - 콜백함수가 반환하는 값을 초기 렌더링에 사용하고 그 뒤로는 값이 무시된다.
- setter 함수를 통해 현재 state와 같은 값으로 갱신하면, React는 자식을 렌더링하거나 다른 함수를 실행하는 등의 행동을 하지 않는다.
  - state의 변경 감지는 Object.is 알고리즘을 사용하며, 이 알고리즘은 === 연산보다 엄격

### `useMemo`
- `useState`로 비싼 연산을 한 번만 실행하기 위해 초기값으로 함수를 넣는 식으로 처리하는 방식을 배웠다. 
  - 콜백으로 넘긴 그 함수를 업데이트해야 하는 상황이 생기면?
  - 예컨대 장바구니에서 이것저것 넣을 때마다 주문서라는 component에서는 총 주문금액 등을 새로 계산하여야 한다. 이럴 때 `useState`보다는 `useMemo`로 실행하면 좋다.
- `useMemo`는 Memoization 기법을 활용하며, parameter가 똑같다면 계산하지 않는다.
- parameter 두개를 받는다
  - 함수: 비싼 연산을 실행하고 그 결과값을 반환하는 함수
  - 배열: dependency array, 이 안의 요소가 하나라도 변하면 첫 번째로 전달된 함수를 실행하여 반환한다. 이후 설명할 `useEffect` 등에서도 동일

```javascript
function getCount(fillNumber) {
  console.log('An expensive work is been executing...')
  return Array(100000).fill(fillNumber).reduce((acc, cur) => acc + cur, 0)
}


function App() {
  return (
    <Counter />
  )
}

function Counter() {
  const [fillNumber, setFillNumber] = useState(1)
  const [text, setText] = useState('')
  const sum = getCount(fillNumber)
  const handleClick = () => {
    setFillNumber((previousNumber) => previousNumber + 1)
  }

  return (
    <section>
      <span>Sum: {sum}</span>
      <input value={text} onChange={(event) => setText(event.target.value)} />
      <button onClick={handleClick}>
        Plus FillNumber 1
      </button>
    </section>
  )
}
```
- 위 코드에서, input 태그에 Change event가 발생할 경우마다 sum이라는 변수에 할당된 `getCount` 함수가 연산식을 실행한다.
  - 우리가 의도한 것은 fillNumber가 바뀔 때만 sum을 계산하는 것이므로, sum에 할당하는 `getCount`를 `useMemo`로 넣어준다.
```javascript
// Counter 함수 콤포넌트의 함수 몸체 내부
// 기존 비싼 연산을 바로 할당하는 경우
const sum = getCount(fillNumber)

// useMemo를 사용하여 비싼 연산을 필요할 때만 실행하게 하는 경우
const sum = useMemo(() => getCount(fillNumber), [ fillNumber ])
```
  - 비싼 연산을 하는 `getCount` 함수가 우리가 의도한대로 fillNumber값이 바뀔 때에만 수행된다. 
  - 이는 dependency array에 넘긴 값에 변경이 있을 때만 `useMemo`에 첫 번째로 넘긴 함수가 실행된다는 뜻

#### `useMemo`의 특성
- 최적화를 위해 사용될 수 있지만 항상 최적화를 보장하지는 않는다.
  -  Memoization을 한다는 것은 곧 memory에 값을 저장한다는 것이므로 불필요하게 많은 값을 메모하면 오히려 성능이 떨어진다. 
  - 정말 이 값을 메모해야하는지 고민한 후 사용할 것
- 단순한 값 자체를 메모이제이션 할 때 사용
- `useMemo`로 전달된 함수는 렌더링 중에 실행된다.
  - 렌더링 중 하지 않는 것은 `useEffect`에서 해야 한다.

#### Component Memoization
- 컴포넌트 내부에서 상태를 memo할 수 있다면 컴포넌트 자체도 memo가 가능할까?
- function component는 props라는 하나의 파라미터를 받아서 UI 결과를 반환하는 함수일 뿐이다.
  - 즉, 컴포넌트에 전달되는 props만 이전과 같다면 반환값도 동일하므로 memo를 통해 리렌더링을 방지, CPU연산을 아낄 수 있다.
- import를 해준 후 `React.memo(function MyComponent(props) { 함수 콤포넌트 몸체})`의 형태로 메모가 가능하다.
- 내부적으로 `useState`, `useReducer`. `useContext` 등의 상태변화 훅을 가지고 있어서 렌더링이 바뀌는 경우라면 컴포넌트 메모의 의미가 없어진다.
  - 위의 예제에서 input이 change event를 발생시킬 때마다 rendering 되는 경우 등
- 기본적으로 memo함수는 함수컴포넌트가 받는 props의 기존 객체와 새 객체를 shallow compare을 통해 비교
  - 객체의 레퍼런스만 비교하여 업데이트 여부를 판단한다.
- 다른 방식으로 더 엄격하게 비교하여 컴포넌트 렌더링을 통제하고자 한다면 memo의 두 번째 파라미터로 비교 함수를 사용하면 된다.
  - `export default memo(Counter, areEqual)` 처럼 메모함수에 넣는다.
  - 비교함수로는 `areEqual`을 만들어 내용물을 비교해주는 함수를 넣어주거나 또는 `Json.stringify()`를 사용하여 비교하면 된다.

### `useEffect`
- Function Component의 Life cycle method를 담당하는 훅 중 하나
  - class component에서는 `componentDidMount`, `componentDidUpdate`, `componentWillUnMount` 등의 메서드를 사용했다. 
  - 이중 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`의 역할을 한다.
- 렌더링이 모두 완료된 후 호출
- 함수와 배열을 파라미터로 받는다.
- 리렌더링 될때마다 계속 실행되는데, 이를 방지하는 dependency array가 두 번째 파라미터로 오는 배열이다.
- 함수 안에서 다른 함수를 반환하면, 해당 함수는 unmount시점에 실행

#### `useEffect`의 특성
- 렌더링 이후 비동기적으로 실행된다.
  - `useEffect`의 콜백함수는 렌더링 이후 실행을 보장한다. 또한 그 다음 렌더링 이전의 실행을 보장한다.
  - 렌더링 결과가 화면에 모두 그려진 뒤 비동기적으로 실행하므로 일부 상태를 즉시 변경할 필요가 없는 경우나, 이벤트 핸들러를 관리하는 경우 사용
  -  동기적으로 실행하여 레이아웃 측정 등의 작업을 해야 하는 경우에는 `useLayoutEffect`를 사용
  - 전달된 콜백함수를 기억하고 있다가 실행하기 때문이다.
- 매 렌더링 이후 실행, 매 렌더링 이후라도 dependency array가 있으면  dep array 값이 변경된 경우 실행
  - 매번 clean up도 실행하여 업데이트 된 새로운 값으로 실행, 업데이트 된 props 값을 반영하여 버그를 줄인다.
- 콜백으로 익명함수를 넘기는 이유는 클로저로 컴포넌트 내의 참조값을 제대로 업데이트 하기 위함이다.

### `useLayoutEffect`
- 모든 DOM 변경 이후 동기적으로 실행하며, DOM을 변경하려는 경우나, 상태 업데이트로 UI가 깜박거리는 경우를 방지하기 위해 사용
- `useEffect`와 함께 Function Component의 Life cycle method를 담당하는 훅 중 하나
- `useEffect`는 렌더링 완료 이후 실행되는데, `useEffect`에 전달되는 함수에서 DOM
에 직접 접근하여 변경해야 하는 함수를 넣으면, UI가 변경되고 난 후 렌더링을 또 하면서 깜박거림이 생긴다.
  - 그러므로 LifeCycle 내에서 직접 UI를 변경해야 하는 경우에는 `useEffect`가 아니라 `useLayoutEffect`로 한다.

## Function component로 Migrate

## 느낀 점
- 조금씩 조금씩 사용법을 익히는 중... 어렵지만 차근히 해보자.
