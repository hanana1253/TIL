# React

## 인상 깊은 조언

## Function Component & Hooks
- class component와 대조되며, 이제는 대부분 function component 많이 쓴다.
- 기본적인 형태는 함수와 같으며 렌더링할 JSX 객체를 반환한다.

### class component에서 function component으로 가면서 바뀐 것
- 상태관리: `this.state`와 `this.setState`로 관리하던 것을 이제는 `useState`로!
- Life Cycle Method: `constructor`, `componentDidMount`, `componentWillUnmount`, `componentDidUpdate`를 `useEffect`로!
- props: 함수의 파라미터가 prop로, 그 props 그대로 `useState`에 사용  
- `shouldComponentUpdate`는 memo로 구현

### Function Component에서의 상태관리

#### `useState`
- 상태를 정의하는 함수
  - 첫 번째 파라미터에 값을 넘기면 그 값이 상태의 초기값이 된다.
- 두 요소를 가진 배열을 반환
  - 첫 번째 요소는 관리할 상태
  - 두 번째 요소는 그 상태를 업데이트하는 setter 함수이다.
  - 배열 디스트럭쳐링 할당으로 받는다.
- class component의 `this.setState`는 merge 방식, function component의 `useState`는 override 방식으로 상태를 업데이트
  - 객체를 병합하는 것이 아니라 setter함수가 받은 값으로 바꿔치기
- setter 함수는 값을 받을 수도, 함수를 받을 수도 있다.
  - 값을 받으면 비동기적으로 그 값으로 상태를 업데이트
  - 함수를 받으면 함수의 첫 번째 파라미터에 이전 상태를 전달
```javascript
import { useState } from 'react'

function App() {
  return (
    <Counter />
  )
}

function Counter() {
  const [ count, setCount ] = useState(0);
  const handleClick = () => {
    setCount((prevCount) => prevCount +1 );
  }
  return (
    <section>
      <span>{count}</span>
      <button onClick={handleClick}>Plus 1</button>
    </section>
  )
}
```

#### Lazy Initial State
- `useState`에 전달된 초기상태는 첫 렌더링 이후에는 무시된다. 


## Function component로 Migrate

## 느낀 점
- 조금씩 조금씩 사용법을 익히는 중... 어렵지만 차근히 해보자.
