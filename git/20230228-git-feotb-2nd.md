# Git의 동작원리 (continued)

## 지난 시간 요약
- git DB: 해시 키와 값으로 이루어지며, update나 delete 되지 않는다.
  - 파일(blob)이나 파일/디렉토리정보(tree), 커밋정보(commit)를 담고 있다.
- commit
  - 특정 시점의 파일 시스템 전체의 스냅샷인 프로젝트 루트 트리의 해시값
  - 부모 커밋 해시값 (첫 커밋인 경우 null)
  - 메타 정보(author, 시간, 커밋메시지 등)
- tag
  - 특정 커밋을 가리키는 포인터
  - `.git/refs/tags` 디렉토리 안에 파일 이름은 태그 이름, 파일 내용은 해시값으로 저장
  - 일부러 삭제했다가 다시 만들지 않는 이상 변하지 않는다.
- branch
  - 브랜치 내에서의 가장 최신 커밋을 가리키는 포인터
  - `.git/refs/heads` 디렉토리 안에 파일 이름은 브랜치 이름, 파일 내용은 해시값으로 저장
  - 커밋할 때마다 새로운 해시값으로 갱신된다.
- HEAD
  - 현재 브랜치를 가리키는 포인터
  - `.git/HEAD`는 현재 브랜치를 가리키는 `.git/heads` 안의 파일 경로를 저장
  - 브랜치 checkout 할때마다 바뀐다.

## Reset
- `$git reset {특정 커밋}`: HEAD가 보고 있는 브랜치를 특정 커밋으로 이동시키는 명령어
- 미래든 과거든 다른 브랜치의 커밋이든 상관없이, 브랜치 head를 이동시킨다.
  - soft: 현재 작업 중인 파일들과, stage에 올라간 변경사항들은 그대로 유지되고, 단지 브랜치가 바라보는 마지막 commit만 변경된다.
  - mixed: 현재 작업 중인 파일들은 그대로 유지되지만, staging에 올라간 변경사항은 날아가고 이동된 브랜치의 파일상태로 변경된다. 
  - hard: 현재 작업 중인 파일들과 staging에 올라간 변경사항까지 모두 이동된 브랜치의 파일상태로 변경된다.
- 자식은 부모의 커밋을 기억하고 있지만, 부모는 자식 커밋을 알지 못하므로 과거로 reset하면 돌아가기 어렵다.
  - `$git reflog` 명령어를 통해 지난 commit, checkout, reset 등의 결과로 이동한 커밋 해시들이 있으니 잘못 reset했다면 이를 참고할 것

## Commit Amend
- `$git commit --amend`로 커밋 메시지를 수정하면, 브랜치가 바라보던 기존 커밋의 parent 커밋을 바라보는 새로운 커밋을 만들고, 브랜치가 바라보는 커밋을 갈아끼운다.

## Merge
- 하나의 parent 커밋을 가지는 두 개의 브랜치에서 각각 최신 커밋이 쌓였을 때, 한 쪽(A브랜치)에서 다른 브랜치(B브랜치)를 merge하면 어떤 일이 일어날까? 
  - B브랜치의 최신 커밋과 공통 parent 커밋과의 diff를 비교한 후 변경사항을 적용한다.
  - 위의 적용이 완료된 상태에 A브랜치의 최신 커밋과 공통 parent 커밋과의 diff를 비교한 후 변경사항을 적용한다.
  - 두 브랜치의 변경 사항이 모두 반영된 새로운 커밋이 생성된다. 이 때 새로운 커밋의 parent는 A브랜치와 B브랜치의 최신이었던 커밋 두개이다.
  - **merge commit은 부모를 두 개 갖는다.**
- 머지 대상이 자식이라서 내 자신이 공통 부모인 경우에는 별도의 merge commit 없이 fast-forward로 HEAD만 이동한다. 

### Conflict
- merge할 때, 두 파일이 정확히 일치한다면 같은 해시로 저장되므로 문제가 없으나, 같은 파일이 다른 내용을 가지는 경우 merge를 잠시 멈추고 conflict가 발생한 파일명과 충돌되는 부분을 알려준다.
  - A브랜치에서 적용된 파일 또는, B브랜치에서 적용된 파일을 사용할지에 따라 어느 파일 해시값을 갖는지 결정된다.
  - 둘 중 하나가 아닌, 새로운 내용으로 작성한 후 conflict를 커밋하면 새로운 내용이 적용된 파일 해시가 반영된다.

## Cherry-pick
- 특정 브랜치에서 다른 브랜치의 커밋(a1)을 체리픽해오면, a1에서 일어난 변경사항만을 가져온 커밋을 새로 만든다.
- `--ff`: 자식 커밋을 체리픽할 때, fast-forward 하도록 옵션을 적용할 수 있다. (`$git cherry-pick {자식커밋해시} --ff`)
- `-n`(`--no-commit`): 체리픽해온 결과물을 staging에만 올리고 커밋은 아직 하지 않은 상태로 가져온다.
- 여러 커밋을 동시에 체리픽하려면, `$git cherry-pick a1 a2 a3`처럼 하나씩 나열하거나 `$git cherry-pick a0..a3` 처럼 범위를 지정한다.
  - 범위를 나타낼 때 첫 번째 커밋은 포함하지 않는다. 

## Rebase
- 적용된 결과는 merge와 동일(커밋 루트노드 해시값이 동일)하지만, 머지와 달리 커밋들의 연결구조를 바꾸고 HEAD를 옮겨 공통 부모로부터 리베이스가 끝난 지점까지 한 줄로 히스토리가 이어진다.
- 하나의 parent 커밋에 두 개의 브랜치에서 각각 최신 커밋이 쌓였을 때, 한 쪽(A브랜치)에서 다른 브랜치(B브랜치)를 rebase하면 어떤 일이 일어날까?
  - B브랜치의 최신 커밋을 베이스로 하여, 공통 parent 커밋과 A브랜치의 최신 커밋 사이의 커밋들의 diff들을 각각 비교한다.
  - conflict 없으면 파일에 반영한 후 B브랜치의 최신 커밋에 A브랜치의 커밋개수만큼 커밋이 쌓인다. 
- 자식 커밋을 리베이스하여 공통 부모가 나 자신일 때는 HEAD만 옮겨지고 별도의 새로운 커밋을 만들지 않는다.
  - `--no--ff` 옵션을 주면 이를 피할 수는 있다.

## Revert
- reset 대신 이미 커밋된 기록을 보관하되 변경사항만 폐기하도록 하는 것이 revert
- `$git rebase -i`로 interactive 옵션을 주는 방식으로도 과거 커밋을 관리할 수 있다.
- 이미 배포가 된 히스토리, 또는 다른 사람과 공유된 히스토리는 편집하지 않는 것이 좋다

## 참고자료
- [소프트웨어 개발의 지혜 <Git 편>](https://www.codesoom.com/courses/git)
- [Git - Reset 명확히 알고 가기](https://git-scm.com/book/ko/v2/Git-%EB%8F%84%EA%B5%AC-Reset-%EB%AA%85%ED%99%95%ED%9E%88-%EC%95%8C%EA%B3%A0-%EA%B0%80%EA%B8%B0)
- [[코드잇] git reset의 3가지 옵션 제대로 이해하기](https://blog.naver.com/PostView.naver?blogId=codeitofficial&logNo=221950118036&redirect=Dlog&widgetTypeCall=true&directAccess=false)