# Javascript

## 모듈
- export에는 두 가지가 있으며 import도 export의 형태에 따라 사용 방식이 제한되기도 한다.
  - named export는 식별자 그대로 내보내므로 여러 개를 내보낼 수 있다.
    - import 할 때 식별자를 그대로 사용해야 한다.
    - 같은 모듈 파일에서 여러 named export 자산을 한 번에 받을 때 객체 디스트럭처링 할당처럼 중괄호로 묶인 named export 식별자들을 받아온다.
    - 함수선언문이나 변수선언문 앞에 export를 써줄 수 있다.
  - default export는 하나만 내보낼 수 있다. 주로 객체 안에 담아 내보낸다. 
    - import 할 때는 임의의 식별자를 지정하여 namespace로 사용할 수 있다.
    - default export는 const나 let 앞에 사용하지 못한다. 
      - 왜일까? default된 자산을 import해줄 때, 이는 식별자 선언문 const와 같이 동작, 즉 재할당이 불가하다. 
      - let으로 선언한 식별자를 default로 내보낼 수 있다고 가정하면, import하는 순간 재할당이 불가하다는 비일관성을 보인다. 
      - 또한 `export default const a = 1, b = 2;`와 같이 여러 변수를 선언하는 경우에도 두 변수 중 어느 것을 default export한 것인지 정하기 애매하다.
      - 그러므로 애초에 문제의 씨앗을 제거하기 위해 변수선언문 앞에는 default를 사용하지 못하게 했을 것이다.
- named와 default를 둘 다 쓸 수도 있으나 바람직하진 않다고 여겨졌다. 
  - 그러나 React에서는 버젓이 같이 쓰고 있는 것을 보면 소용이 있으니 그리 하는 것이라 판단된다.

## 에러 처리
- 에러란 무엇일까? 원하는 결과를 못 얻는 상황을 언제 에러로, 또는 exception으로, 또는 오류로 봐야 할까?
- 확실한 에러는 오타로 인한 문제나 type을 잘못 넣는 것 등일 것이다.
- querySelector에서 필요한 DOM 노드를 찾지 못한 경우, null을 반환하는 게 좋을까 아니면 에러를 던져야 할까?
  - clean code 책에서는 null을 반환하는 경우 if로 null을 잡아 처리해줘야 하므로 null을 반환하지 말라고 한다.

## async / await
- 난이도 극강인 generator라는 개념과 깊이 연관되어 있으며 이는 redux saga를 쓴다면 알게 될 것이다.
  - generator 함수는 특수한 함수이며, React를 한다면 알아야 할 수도 있다.
  - `function*()`의 형태로 선언한다.
  - 일반적인 함수는 함수바디가 막힘없이 실행되어, 개발자가 중간에 제어할 수 없다.
  - 반면 generator 함수는 개발자가 중단하거나 재개할 수 있는데, 함수의 실행이 중단된 상태에서 값을 주고받을 수 있으며 이를 이용하여 await을 구현한다. 
  - generate 함수는 Promise 내부에서 resolve 할때까지 기다리다가 호출자에게 resolve한 결과값을 yield해준다.
- await문을 통해 비동기를 동기처럼 쓸 수 있다. 
  - 즉 처리순서가 보장되고, caller가 있으므로 에러처리를 try/catch문으로 잡아낼 수 있다.
- await는 Promise 앞에서, 그리고 async 함수 내부에서만 쓸 수 있으며 이 두 가지 제약만 제외하면 비동기를 동기처럼 처리할 수 있으므로 매우 유용하다.
- fetch는 response 객체를 가진 promise를 반환하는데, `response.json()`도 promise이니 꼭 await를 사용해줄 것
- async 함수는 resolve한 프로미스를 리턴하는데, 리턴값이 없으면 undefined를 리턴한다. 
  - 그러므로 then으로 받아 처리해줄 수도 있지만 async 내부에서 모든 비동기 처리를 완료하는 것이 가독성은 물론이고 async/await 존재의의와 부합하는 일일 것이다. 
- 클래스의 constructor에는 왜 async를 쓰지 못할까? 
  - instance 초기값으로 비동기 처리 결과를 넘겨주고 싶을 때도 있을 텐데...?
  - constructor함수는 instance를 반환해야 하는데, async 함수는 promise를 반환하기 때문

## todos 어플리케이션을 async/await으로 변경하기

## 웹팩과 바벨
- ESM을 지원하지 않는 axios를 사용하면서 script 태그 하나가 추가되었고, ESM 때문에 확장자 명도 꼭 붙여줘야 하는 등 귀찮은 상황이 많다. 게다가 라이브러리를 여러 개 써주고 싶은데 그 때마다 import하는 것은 바람직하지 않은 상황이다. 
- 우리는 현재 ES Next 문법을 쓰고 있는데, 이를 지원하지 않는 구형 브라우저들까지도 커버해줄 배포용 코드가 필요할 것
- 바벨이라는 트랜스파일링 툴을 이용하여 ES5 또는 ES3으로 버전을 떨어뜨리고 웹팩으로 모듈을 번들링해줘야 한다.
- 웹팩은 환경설정이 가장 어렵다. 어떤 식으로 동작하는지 명확히 인지하자. 
- 이전 웹팩을 사용하다가 버전업된 웹팩으로 바꾸면 크리티컬한 문제를 야기할 수 있으므로 웬만해서는 놔두고, 문제가 전혀 없고 성능 개선만이 기대되는 확실한 경우에만 버전업하자.
- 바벨은 최신 문법을 구형 브라우저에 맞게 고쳐준다 (e.g. class를 생성자함수로)
  - 타입스크립트도 이와 비슷한 기능을 제공하며, transfile한 결과물에 있어서 타입스크립트가 더 이해할 수 있다는 차이가 있다. 
  - 바벨 트랜스파일 결과물은 거의 이해가 불가능하다. 그러나 우리는 트랜스파일 후의 코드를 굳이 이해할 필요가 없다.

### 환경 세팅

#### 폴더구조
- public은 배포 시의 root 폴더이며, 현재 express에 의해 정적파일이 제공된다.
- 우리는 이제 바벨을 통해 compile한 결과물을 public 디렉토리에 떨궈줄 것이다.
- 개발용으로만 작성하는 현재의 코드는 src폴더에 둔다. (Sass를 사용한다면 Sass 파일도 src)
- src 폴더에 있는 개발용 파일을 웹팩이 컴파일하여 public에 떨궈주는 형태

#### 패키지 설치
- webpack과 webpack-cli 패키지 개발용으로 설치 `$ npm install --save-dev webpack webpack-cli`
- 바벨 세가지도 설치 `$ npm install --save-dev @babel/core @babel/preset-env @babel/cli`

#### 환경설정 (webpack.config.js)


### webpack-dev-server