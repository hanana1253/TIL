# Javascript

## 배운 것들

### `Object.is()` 메서드
- `Object.is()`는 인수로 전달되는 두 값이 같은 값인지에 대한 불리언 값을 반환한다.
- 일치비교연산자에서 `0 === -0`이 `true`로, `NaN === NaN`이 `false`로 나오는 것에 대하여 정확히 비교해주기 위해 사용
- [MDN의 Object.is()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/is#%ED%8F%B4%EB%A6%AC%ED%95%84)의 폴리필 코드는 다음과 같다.
```javascript
if (!Object.is) {
  Object.is = function(x, y) {
    if (x === y) { // Steps 1-5, 7-10
     // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
   } else {
     // Step 6.a: NaN == NaN
     return x !== x && y !== y;
   }
  };
}
```
  - `Object` 객체에 `is`가 존재하지 않는다면 undefined가 반환되면서 falsy값이 나오며, 이를 true로 만들며 if 블록문이 실행된다.
  - 블록문에서 `Object.is` 메서드를 동적 생성하는데, x와 y값이 같은 경우 x가 0이 아니면 true를 반환
  - x가 0 또는 -0인데 y가 -0 또는 0인 경우에 일치비교연산자에서 걸러지지 않았으므로, 두 값이 다른 값으로 여겨지도록 분모에 넣어 Infinity로 만든다. -0이 분모인 경우 `-Infinity`라서 `Infinity`와 일치비교연산의 결과는 false, 만약 둘다 0이거나 둘다 -0이면 true.
  - x와 y가 일치비교연산자에서 다르다고 나온 경우에는, 두 값이 둘 다 NaN인지만 확인하면 된다. NaN은 자기 자신과 비교했을 때 false를 리턴하므로 둘다 자기 자신과 불일치하다고 하는 경우에 true를 반환하는 논리식을 리턴한다.
- 위 코드는 좋은 코드일까? 평가해보자면 일단 코드를 해석하는 것에 너무 많은 시간이 든다. 리턴은 마지막에 한 번만 해주는 게 정석이므로 if보다는 삼항조건연산자로 만들어주면 좋다. 

### 절차형/명령형 vs. 선언형 프로그래밍
- 절차형/명령형 프로그래밍이 사용하는 제어문은 가독성을 해치고 오류나 실수의 여지를 높인다.
  - 초창기 프로그래밍은 절차지향이자 명령형이었는데, 특정한 결과를 만들어내기 위해 절차를 나열한다.
  - if, for문 등은 의도치않게 변수를 쓸 수 밖에 없는 상황이 많아진다. 
  ```javascript
  // 짝수요소만 더하는 함수
  function sumEven(numbers) {
      var sum = 0;

      for (let i = 0; i < numbers.length; i++){
          var number = numbers[i];
          if (number % 2 === 0) {
              sum += number;
          }
      }

      return sum;
  }
  ```
- 그래서 등장한 새로운 패러다임이 선언형 프로그래밍인데, 리액트의 특징으로 가장 먼저 강조되는 것이 바로 선언형이라는 점이다.
  - 또한 hooks라는 함수 기반의 콤포넌트로 짜는 움직임이 득세하고 있다. 함수형은 선언형 프로그래밍에 포함된 개념
  - 객체지향보다는 함수형으로 짜는 게 더 코드가 아름답다.
- 선언형 프로그래밍에는 절차가 내부에 숨겨져 있고, 결국 뭘 하고 싶은지만 드러나있다. for문이나 if문을 최대한 피한다.
```javascript
// 위와 동일한 동작을 하는 함수

function sumEven(numbers) {
    return numbers.reduce(function (acc, cur) {
        return cur % 2 === 0 ? acc + cur : acc;
    }, 0);
}

// 화살표 함수를 사용하면 더 축약할 수 있다.

const sumEven = numbers => numbers.reduce((acc, cur) => cur % 2 === 0 ? acc + cur : acc, 0);

```
- 이렇게 영어처럼 해석해나갈 수 있는 코드가 선언형이며, 겉으로 드러나는 for문은 없지만 내부적으로는 순회한다.
- html도 절차를 나연하지 않고 태그의 속성이 정의되는 선언형 프로그래밍 언어라고 볼 수도 있다.
```html
<h1>Hello</h1>
<!-- Hello라는 텍스트를 가장 높은 단계의 제목으로 굵고 큰 폰트로 처리하겠다는 뜻  -->
```

### 제어문

#### 블록문
- scope를 인위적으로 만들 필요가 있을 때 사용
  - switch문에서 변수를 선언하는 경우 블록문으로 스코프를 설정해주는 등
- `var` 키워드로 선언한 변수는 블록문 안이더라도 전역변수이며, 함수 안에서만 지역변수로 관리된다.
```javascript
for (var i = 0; i < 2; i++){
    console.log(i);
}

console.log(i); // 2
```
- if나 for문의 소괄호 안은 엄밀히 말하면 코드블록문 내부는 아니지만 블록문 안에 있다고 봐야한다.

#### for문 vs. while문
- 둘다 동일하게 동작시킬 수 있다. 결국 가독성을 따라 선택하는 것.
- for문: 몇 번 도는지 횟수가 명확하게 드러나야 할 때
- while문: 반복횟수가 불명확하고 반복횟수보다 조건식이 중요한 정보일 때

#### break와 continue
- break는 반복문을 탈출하고, continue는 해당 코드블록의 코드는 중지하고 반복문의 처음으로 다시 돌아간다.
- 함수 안에서 for문을 쓸 때 바로 함수를 끝내기 위해서는 break 없어도 return을 쳐주면 된다.

### 타입 변환
- 문자열 타입 변환 `String(value)`에 대한 고찰
  - 생성자 함수에 `new`를 붙이지 않고 호출하는 것은 에러가 나야 마땅한 동작인데 문자열로 바꿔준다는 것은 생성자 함수가 본래 용도가 아닌 다른 목적으로 쓰인다는 것이다. 이는 Semantic한 활용이 아니므로 바람직하지 않다고 평가할 수 있다. 
  - 그러나 어떤 사람들은 String으로 만드는 의도가 명확하기 때문에 이를 더 좋은 코드로 생각할 수 있다.
  - 연산자를 써서 간단하게 `value + ''`로 변환하자.
- 숫자 타입 변환은 `+` 단항산술연산자로 간단하고 직관적이게 처리하자.

### 단축평가 및 기타 연산자
- if문을 안 쓰려는 의도 (c.f. 삼항조건연산자는 if ... else문을 대체 의도)
- parameter에 데이터타입 validation을 위해 쓰기도 했다.
```javascript
function getStringLength(str) {
    str = str || '';
    return str.length;
}
```
- 하지만 이제는 Typescript 활용하여 parameter에 `function getStringLength(str:string){}`으로 받으면 호출할 때 문자열이 아닌 값이 들어올 때 런타임 전에 컴파일 에러를 띄울 수 있다.
- 옵셔널 체이닝(`?.`)이나 null 병합 연산자(`??`)는 각각 없는 객체를 참조하여 발생하는 의도치 않은 에러나 숫자 0이 falsy값으로 암묵적 변환이 되어 예상하지 못한 결과가 생기지 않도록 방지한다.

### 객체
- JS는 멀티패러다임 프로그래밍 언어로, 100% 객체지향형이라고 말할 수 없다. 
  - c.f. Java는 클래스 기반의 객체지향언어다.
  - JS는 함수형이자 프로토타입 기반 객체지향언어이다.
- 객체지향의 단점 : 설계도를 미리 만들어두겠다는 의도이지만... 먼저 어떤 것을 넣을지 설계가 다 되어있어야 한다. 
  - 이는 실시간으로 변화하는 비즈니스 요구에 대응하기 어려우며, 그냥 지금껏 설계한 것에 부합하지 않으면 안된다고 하는 개발자가 되는 것

#### 배열 vs. 객체
- 배열은 0부터 연속된 숫자를 프로퍼티 키로 갖는, 그리고 length 프로퍼티를 갖는 객체이다. 
  - 순회의 목적성이 강하기 때문에 for문으로 순차적으로 참조하여 작업하기 위한 순서의 의미가 강하다.
- 객체는 열거를 할 때는 있지만 순서가 아니라 키에 의미가 있다. 데이터 뿐 아니라 행동(메서드)을 포함시킬 수 있다.
- 유사배열객체는 왜 있는 것일까? 배열에 무언가 더 동작을 시키기 위해?
  - 그냥 배열도 built-in 메서드가 있다. 그러나 유사배열객체는 이에 더하여 사용자가 메서드를 직접 추가하겠다는 의지표명의 객체.
  - 그러나 배열을 인수로 넘겨 호출할 수 있는 함수를 만들면 되지 굳이 객체를 만들 필욘 없다. 그래서 요새는 유사배열객체를 잘 안쓴다.
  - JS에서는 객체지향보다는 함수형이 더 의미있다고 볼 수 있다. 이는 React에서 class component보다 function component가 추구되는 것과도 맥락을 같이 한다.

#### 객체의 구조
- 객체는 프로퍼티로 이루어져있고, 프로퍼티는 키와 값으로 구성.
- 프로퍼티 키: 문자열이나 symbol만 올 수 있다
  - 식별자 네이밍 규칙을 따르는 프로퍼티 키는 따옴표 생략이 가능하다.
  - 엄밀히 말하면 식별자가 아니기 때문에 식별자 네이밍 규칙을 따르지 않아도 되지만, 그러면 대괄호 참조연산자로만 접근할 수 있다.
    - 식별자란 스코프 체인 안에, 즉 실행컨텍스트의 lexical 환경 안의 환경레코드에 등록된 것이다.
    - 프로퍼티 키는 프로토타입 체인에 등록되므로 엄밀히 말하면 식별자가 아니지만, 메모리 안에 있는 값을 구별할 수 있는 고유의 이름이라는 광의로 본다면 식별자의 의미를 갖는다고 할 수 있다.
  - 객체리터럴 안에 숫자로 프로퍼티 키를 만들면 예외적으로 따옴표가 생략된다. 하지만 여전히 참조는 대괄호로만 가능하다.
- 프로퍼티 값: JS가 값으로 인정하는 모든 데이터타입의 값이 다 올 수 있다.
  - JS에서 함수는 값이다. 함수도 프로퍼티 값으로 올 수 있으며 이 경우 메서드라고 부른다. 
- 메서드: 메서드는 대부분 this로 접근하여 프로퍼티를 조작하는 일을 한다. 
  - 프로퍼티 외의 독자적인 동작을 하는 메서드는 많지 않다.
  - 프로퍼티를 조작하는 것은 외부 환경에 의존하고 외부 변수를 바꾸는, 부수효과를 낳는다.
  - 메서드는 그래서 비순수함수인 경우가 많으며, 객체지향은 그래서 비순수함수와 뗄레야 뗄 수 없는 관계

#### 객체 생성 방식
- 객체 리터럴로 생성하는 방식과 클래스(Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스 (ES6)) 기반 생성방식이 있다.
  - 장단점을 알고 상황에 따라 유리한 방식을 선택할 줄 알아야 실력있는 개발자이다.
  - JS에서 class는 다른 언어들이 모두 가진 개념이므로 타 언어 프로그래머가 접근하기 용이하도록 제공한, 기존 생성자 함수의 문법적 설탕의 성격이 강한 문법이라고 볼 수 있다. 
- 객체 리터럴로 객체를 생성할 수 있다는 것은 JS의 엄청난 장점이다.

## 느낀 점
- 다시 들어서 기쁘다.