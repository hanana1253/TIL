# Javascript

## 배운 것들

### 히든 클래스
- 객체 릴터럴로 객체를 생성하는 방식은 프로토타입 기반 객체지향언어인 JS의 장점으로, 클래스 없이 객체를 생성할 수 있으며 프로퍼티의 동적 추가도 가능하다.
  - c.f. 클래스 기반 언어에서 객체를 한 번 만들고나면 인스턴스와 그 안의 프로퍼티가 메모리를 점유하는 사이즈가 고정되어 있으므로 프로퍼티를 추가하거나 삭제할 수 없다. 
- JS에서는 객체의 프로퍼티 동적 추가, 삭제가 가능하므로 크기가 고정되어있지 않아 비효율적으로 메모리를 관리할 수밖에 없다.
- JS에서도 프로퍼티를 추가/삭제하지 않는 경우에는 클래스기반의 언어처럼 동작하기 위해 히든 클래스를 구축해두고, 프로퍼티에 빠르게 접근할 수 있게 해두었다.
  - 그러나 프로퍼티 추가/삭제하는 순간 이 히든 클래스는 무용지물이 된다.
- 클래스 기반 언어에서 프로퍼티를 접근하는 속도와 JS에서의 속도는 체감할 수 있는 수준의 차이가 아니기 때문에, 굳이 히든클래스를 엄청나게 활용하려고 하기보다는 동적 추가/삭제라는 JS의 장점을 적극 활용하는 것이 더 좋다.

### 원시 vs. 객체 타입
- 원시 타입과 객체 타입의 근본적 차이는 값을 만들고 관리하는 방식에 있다.
  - 원시 타입은 메모리에 값이 직접 저장되고, 해당 메모리주소가 변수에 binding
  - 객체 타입은 메모리에 **참조값**이 저장&할당된다.
- 원시 타입은 메모리에 한 번 저장되면 변경되지 않는다. 재할당은 되지만.
  - 재할당하지 않는 이상은 절대 변하지 않는, 안정적인 값으로 기대할 수 있다.
- 객체는 그러나 주소값을 변수에 할당하면, 객체에 접근해서 프로퍼티를 추가하거나 삭제, 갱신하더라도 주소값은 바뀌지 않기 때문에 같은 메모리에 있는 객체가 변경된 것.
- 왜 값을 메모리에 저장하는 방식이 다를까?
  - 객체 타입은 보통 규모가 더 크고 복잡하다. 

### 값에 의한 전달과 참조에 의한 전달
- C언어에서 유래한 차이이지만, C언어의 것과는 개념이 다소 다르다.
  - JS에서는 원시값을 변경할 수 없지만 C언어에서는 원시값을 변경할 수 있다.
- 값에 의한 전달: 원시값을 가진 변수를 다른 변수에 할당하면 복사된 해당 값이 할당된다.
- 참조에 의한 전달: 참조값을 가진 변수(객체를 값으로 갖는 변수)를 복사하면 참조값을 복사하여 할당하기 때문에 객체 자체는 공유
  - 객체는 만들기도 복잡하고 메모리도 많이 차지한다: 복사할 때마다 새로 만드는 것이 부담!
  - 과거에는 메모리가 비싸고 성능 문제가 이슈였기 때문에 객체는 눈물을 머금고 다른 방식으로 저장해야만 했다.
  - 이제는 메모리가 싸기 때문에 객체도 원시값과 같이 immutable하게 사용하려는 움직임이 있다.
- 객체가 실제로 모든 프로퍼티 키와 값이 같은지 확인하는 함수를 만들어보자.


### 객체와 메서드
- 

### 얕은 복사와 깊은 복사
- 1 level만 복사하는 것을 얕은 복사, 모든 depth의 값을 참조값이 아닌 실체적인 값으로 갖도록 복사하는 것을 깊은 복사라고 한다.
- 원시값을 복사하는 경우 값 자체가 복사되므로 깊은 복사라고 한다.
```javascript
var obj1 = { a : 1 };
var obj2 = obj1; // 참조값을 공유한다.
var obj3 = Object.assign({}, obj1); // 빈 객체에 obj1을 덮어씌웠으므로 참조값을 공유하지는 않지만 obj1 안에 객체가 있어 depth가 하나 더 들어가면 해당 참조값은 공유된다.
var obj4 = { ... obj1 }; // obj3과 동일하지만 아직은 ECMAScript에 표준 스펙으로 발표되진 않음.
```


### 함수


## 느낀 점
