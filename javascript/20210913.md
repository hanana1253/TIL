# Javascript

## 배운 것들

### 히든 클래스
- 객체 릴터럴로 객체를 생성하는 방식은 프로토타입 기반 객체지향언어인 JS의 장점으로, 클래스 없이 객체를 생성할 수 있으며 프로퍼티의 동적 추가도 가능하다.
  - c.f. 클래스 기반 언어에서 객체를 한 번 만들고나면 인스턴스와 그 안의 프로퍼티가 메모리를 점유하는 사이즈가 고정되어 있으므로 프로퍼티를 추가하거나 삭제할 수 없다. 
- JS에서는 객체의 프로퍼티 동적 추가, 삭제가 가능하므로 크기가 고정되어있지 않아 비효율적으로 메모리를 관리할 수밖에 없다.
- JS에서도 프로퍼티를 추가/삭제하지 않는 경우에는 클래스기반의 언어처럼 동작하기 위해 히든 클래스를 구축해두고, 프로퍼티에 빠르게 접근할 수 있게 해두었다.
  - 그러나 프로퍼티 추가/삭제하는 순간 이 히든 클래스는 무용지물이 된다.
- 클래스 기반 언어에서 프로퍼티를 접근하는 속도와 JS에서의 속도는 체감할 수 있는 수준의 차이가 아니기 때문에, 굳이 히든클래스를 엄청나게 활용하려고 하기보다는 동적 추가/삭제라는 JS의 장점을 적극 활용하는 것이 더 좋다.

### 원시 vs. 객체 타입
- 원시 타입과 객체 타입의 근본적 차이는 값을 만들고 관리하는 방식에 있다.
  - 원시 타입은 메모리에 값이 직접 저장되고, 해당 메모리주소가 변수에 binding
  - 객체 타입은 메모리에 **참조값**이 저장&할당된다.
- 원시 타입은 메모리에 한 번 저장되면 변경되지 않는다. 재할당은 되지만.
  - 재할당하지 않는 이상은 절대 변하지 않는, 안정적인 값으로 기대할 수 있다.
- 객체는 그러나 주소값을 변수에 할당하면, 객체에 접근해서 프로퍼티를 추가하거나 삭제, 갱신하더라도 주소값은 바뀌지 않기 때문에 같은 메모리에 있는 객체가 변경된 것.
- 왜 값을 메모리에 저장하는 방식이 다를까?
  - 객체 타입은 보통 규모가 더 크고 복잡하다. 

### 값에 의한 전달과 참조에 의한 전달
- C언어에서 유래한 차이이지만, C언어의 것과는 개념이 다소 다르다.
  - JS에서는 원시값을 변경할 수 없지만 C언어에서는 원시값을 변경할 수 있다.
- 값에 의한 전달: 원시값을 가진 변수를 다른 변수에 할당하면 복사된 해당 값이 할당된다.
- 참조에 의한 전달: 참조값을 가진 변수(객체를 값으로 갖는 변수)를 복사하면 참조값을 복사하여 할당하기 때문에 객체 자체는 공유
  - 객체는 만들기도 복잡하고 메모리도 많이 차지한다: 복사할 때마다 새로 만드는 것이 부담!
  - 과거에는 메모리가 비싸고 성능 문제가 이슈였기 때문에 객체는 눈물을 머금고 다른 방식으로 저장해야만 했다.
  - 이제는 메모리가 싸기 때문에 객체도 원시값과 같이 immutable하게 사용하려는 움직임이 있다.
- 객체가 실제로 모든 프로퍼티 키와 값이 같은지 확인하는 함수를 만들어보자.


### 객체와 메서드
- 객체의 프로퍼티 값으로는 JS가 인정하는 모든 값이 올 수 있다.
- 함수도 올 수 있는데, 이 때 프로퍼티 값으로 오는 함수를 메서드라고 하지만 ES6부터는 메서드 축약표현으로 정의된 것만이 메서드
- 프로퍼티 값으로 온 함수와 메서드 축약표현으로 정의된 ES6 메서드가 다른 점
  - 프로퍼티값으로 온 함수는 객체를 만드는 생성자함수로써, 또는 일반함수로써 쓸 수 있다.
  ```javascript
  var obj = { 
      a: 0,
      sayHi: function sayHi() {
          console.log('Hi');
      }
  }
  new obj.sayHi(); // sayHi {} 를 만들어낸다.
  ```
  - this라는 미묘한 차이도 있지만 나중에 알아보자.
  - 메서드 축약표현으로 정의된 함수는 생성자함수나 일반함수로 쓸 수 없다.

### 얕은 복사와 깊은 복사
- 1 level만 복사하는 것을 얕은 복사, 모든 depth의 값을 참조값이 아닌 실체적인 값으로 갖도록 복사하는 것을 깊은 복사라고 한다.
- 원시값을 복사하는 경우 값 자체가 복사되므로 깊은 복사라고 한다.
```javascript
var obj1 = { a : 1 };
var obj2 = obj1; // 참조값을 공유한다.
var obj3 = Object.assign({}, obj1); // 빈 객체에 obj1을 덮어씌웠으므로 참조값을 공유하지는 않지만 obj1 안에 객체가 있어 depth가 하나 더 들어가면 해당 참조값은 공유된다.
var obj4 = { ... obj1 }; // obj3과 동일하지만 아직은 ECMAScript에 표준 스펙으로 발표되진 않음.
```

### 함수
```javascript
// 함수선언문은 add라는 식별자가 암묵적으로 생성되어 런타임 이전에 평가되면서 스코프에 등록된다.
function add(a, b) { // 매개변수
    return a + b; // 반환문
} // 중괄호 내부는 함수몸체

add(2, 3); // 인수를 전달하며 호출
```
- 반환문: 함수 외부로 연산 결과 값을 내보내주면서 함수를 종료한다.
- 매개변수와 인수에는 순서의 의미가 있으며 매개변수의 개수에 맞지 않는 인수가 들어와도 에러가 나지 않는다. 
  - 매개변수에 부합하는 인수가 들어오지 않는 경우 undefined라는 값이 해당 매개변수에 할당
  - 매개변수의 개수보다 많이 들어온 값은 모든 인수를 요소로 갖는 arguments라는 유사배열객체를 통해 확인할 수 있다.
  - 화살표함수는 arguments가 제공되지 않는다. 
- 함수에 인수로 객체를 넘길 때, 보기 귀찮다고 무턱대고 변수 할당 후 넣으면 안된다.
  - 변수를 만든다는 것은 재사용한다는 의미인데, 객체를 인수로 넘겨 함수 내에서 변경되는 경우 나중에 변수에 있는 객체의 상태를 짐작하기 어렵기 때문
  - copy해서 넘기는 방법도 있지만... 번거롭다.

#### 함수선언문 vs. 함수표현식
- 함수선언문은 함수이름을 생략할 수 없으며, 함수 호이스팅을 일으킨다. 
  - 함수호이스팅: 함수선언문으로 함수를 정의하는 경우, 런타임 이전에 선언문을 평가하면서 함수객체를 생성하고, 함수이름으로 식별자를 암묵적으로 생성하여 할당까지 완료한다. 이 때문에 함수를 정의하는 코드보다 먼저 함수를 호출할 수 있는데 이를 함수 호이스팅이라고 한다.
- 함수표현식은 함수리터럴을 변수에 할당하는 함수 정의 방식이며, var 키워드로 정의하는 경우 변수 호이스팅을 일으킨다.
  - 변수 할당문과 같이 변수 선언만 런타임 이전에 실행되고, 해당 변수에는 undefined로 초기화된다. 

#### 화살표함수
- this나 arguments 등을 제공하지 않기 때문에 몸집이 작고, 가독성이 좋다.
- ES6에서 도입

#### 즉시실행함수
- 두번 다시 호출하지 않을 때 사용하며, 정의하자마자 호출하는 것
- 전역변수를 피하기 위해 사용하지만 요즘은 모듈이라는 게 있어서 이 용도로 쓸 일이 없다.
- 이제는 클로저를 만들기 위한 용도로 쓰는 경우가 많다
- 호출연산자(`()`)의 위치는 즉시실행함수를 감싸는 그룹연산자의 안과 밖 둘다 상관없다.
  - 화살표 함수의 경우에는 그룹연산자 밖에서만 호출연산자를 사용할 수 있으므로 일관적으로 그룹연산자 밖에서 사용하는 것이 권장된다.
- 즉시실행함수도 인수를 전달하거나 리턴값을 받을 수 있다.

#### 재귀함수
- 함수이름으로 호출할 수도, 함수객체를 가리키는 식별자로 호출할 수도 있으며 체감되는 성능차이는 없을 것
  - 헷갈리지 않게 동일한 함수이름/식별자를 사용해라
- 반복문으로 대체가 가능하지만 재귀함수를 쓰는 이유?
  - 가독성이 더 좋은 선언형 프로그래밍
  - 단점은 메모리를 많이 쓴다는 점(호출할 때마다 실행컨텍스트가 만들어지기 때문)

#### 중첩함수
- 왜 중첩함수를 사용할까? 왜 굳이 로직을 함수 내부에 정의해 호출할까?
  - 그 함수 안에서만 호출하겠다는 의지! 그렇다면 왜 그냥 로직을 풀어쓰지 않고 함수로 묶었을까?
  - 로직을 함수 내에서 여러번 사용하는 경우
  - 로직이 너무 복잡해서 기능에 이름을 붙여 가독성을 높이기 위해
- 즉 외부함수의 일부 로직을 가독성 또는 재사용의 목적으로 내부에 정의한 것

#### 콜백함수
- '나중에 호출되는 함수'라는 의미를 가지고 있다.
- Higher Order Function(HOF, 고차 함수)에 인수로 전달되는 함수
- 중첩함수의 내부함수로 안 쓰고 왜 인수로 전달할까?
  - 내부함수는 바깥에서 바꿀 수 없다. 외부함수 코드를 아예 다 뜯어 고쳐야 한다.
  - 내부함수는 외부함수의 로직에 의존할 때에 사용한다.
- 콜백함수로는 외부에서 로직을 받아 동작시키기 때문에 다양한 함수를 전달할 수 있으며, 함수 외부에서 수정할 수도 있다.
  - 두 개의 함수를 더해준다고 생각하면 된다.
  - 콜백함수는 누가 호출하는가? 대부분의 경우 호출 주체는 HOF.
  - 콜백함수는 개발자가 호출하는 것이 아니라, 언제 호출해야하는지 정확히 아는 함수가 호출해줘야 하기 때문이다.

#### 순수함수와 비순수함수
- 순수함수는 재료만 받아서 일한다. 어떤 경우에도 같은 값을 넣으면 같은 값을 뱉어낸다.
- 이와 반대로 외부 상태에 의존하거나 외부상태를 변경하는 것이 비순수함수
- 함수형 프로그래밍은 순수함수로 만들기 위해 노력해야하는 프로그래밍 패러다임
- 테스트가 편하다: 외부 데이터를 의존하거나 변경하지 않기 때문
  - 비순수함수의 경우 외부 DB를 가져와 테스트 할 때 외부 데이터가 있는지 몇개인지 등을 알아야한다.
- JS는 함수형인 동시에 객체지향언어이기 때문에 객체 안에서 프로퍼티를 참조하는 메서드는 비순수함수이다.
- 함수형을 추구하더라도 객체지향형은 비순수함수를 내포하므로 함수형에 위배되는 상황이 발생할 수 있다.
```javascript
var counter = {
    num: 0,
    increase() {
        num++;
    }
}

counter.increase(); // num은 1이 된다.

counter.num = 100; // num이 100으로 외부에서 변경된다.
counter.increase(); // num은 101이 된다.
```
  - 이 경우에 클로저를 사용하여 객체 안에서도 안정적으로 외부 접근을 막으면서 참조할 수 있다.

## 느낀 점
- 이제는 개념 자체보다 why에도 신경쓸 수 있어야겠다.
