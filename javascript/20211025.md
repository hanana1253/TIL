# Javascript

## localStorage vs. sessionStorage vs. Cookies

### cookies
- 일반적으로 서버가 만들며, 모든 HTTP 요청과 응답에 따라다니는 데이터
- HTML5 이전에는 모든 웹어플리케이션의 데이터는 cookies에 저장될 수 밖에 없었다.
- 4KB의 크기로 헤더에 담긴다
- 갑론을박이 많지만, 여러가지 보안설정을 잘 해두기만 하면 쿠키도 보안성을 가진 storage로 기능한다.

### localStorage와 sessionStorage
- HTML5부터 제공되는 Web Storage API로, 서버로 보내지 않고도 정보를 저장할 수 있는 브라우저의 저장소
- localStorage는 사용자가 지우지 않는 이상은 영구적이며, sessionStorage는 한 세션(창이 열리고 닫히는 기간)에만 유효
- 5MB까지 수용 가능하며, 서버로 보내지지 않고 로컬에만 저장되기 때문에 HTTP 요청/응답 성능에는 영향을 미치지 않는다.

### sessionID
- 로그인 상태를 유지시키기 위해서, 서버는 로그인 성공 시 해당 클라이언트가 로그인된 상태임을 인증하는 토큰을 발급하여 암호화한 후 sessionID를 헤더에 담은(쿠키) 응답을 보내준다. 클라이언트는 매 요청마다 이를 같이 보낸다. 
- 그러나 만일 서버가 여러대라면? 다른 서버로 요청할 때 새로 로그인을 해야 한다.
- 이런 문제를 해결하기 위해 나온 게 JWT(JSON Web Token)으로, 세션ID 방식과 달리 서버와 관계 없이 로그인 상태를 인증할 수 있는 키를 갖는다.

## 비동기

### 타이머
- 타이머함수에 전달되는 콜백함수는 타이머함수가 아닌, 브라우저에 의해 호출된다.
- 타이머함수는 브라우저에게 특정 시간 이후 이 함수(참조값)를 태스크 큐에 넣어달라고 넘기는 역할만을 수행한다. 
- ECMAScript 사양에 정의되지 않은, 호스트객체이다. Web과 Node.js에서 각각 지원한다.
- 디바운스와 스로틀: 디바운스는 보통 input처럼 마지막 이벤트 발생 후 한 번 호출될 필요가 있는 input 자동완성기능과 같은 경우 마지막 한번만 처리, 스로틀은 스크롤 이벤트처럼 여러 번 발생하는 것을 첫 이벤트 발생 이후 어느 시점까지는 한 번의 호출로만 처리

### 비동기 함수
- 비동기함수는 콜백함수를 직접 호출하지 않고 브라우저에 위임하는 로직을 가지는 함수다.
  - c.f. map, filter, reduce 등 배열의 고차함수들은 콜백으로 넘긴 함수들을 직접 호출한다. 즉 동기함수이다.

### JS 엔진과 Web API
- JS 엔진 내부의 구성
  - 실행컨텍스트 스택(=콜스택)
    - 비는 순간 태스크 큐에서 대기하던 비동기 함수가 콜 스택에 push되고 실행된다.
    - LexicalEnvironment와 VariableEnvironment라는 두 개의 프로퍼티와, 각각의 참조값을 갖는 고정된 크기의 객체이므로 스택으로 관리될 수 있다. 
  - Heap 영역
    - stack처럼 차곡차곡 쌓지 못하는 데이터가 쌓인다. 
    - JS전용으로 싸용하는 메모리공간으로 배정된다.
  - (JAVA의 메모리 관리 방식 때문에 다 그렇게 동작한다고 오해하지만) 원시값은 무조건 스택, 힙에는 무조건 객체가 들어가는 건 아니다.
    - ES사양에 따로 기재되어 있지 않으므로 모르지만, V8은 JS 엔진에 heap이 있다고 기재되어있다.
    - JS에서 원시값은 어디에 저장될까? 객체의 프로퍼티로 존재하니까 큰 의미에서는 heap에 저장된다고 봐도 무방(그러나 확언하고 말고 할 본질적인 것이 아니므로 이정도로 넘어가도록 하자)
- Web API
  - 호스트 객체인 Web API는 JS엔진 내부에 존재하지 않는다. JS 엔진 밖에서 브라우저가 관리한다.
  - setTimeout으로 브라우저에 콜백을 넘기면, Web API의 타이머 tick이벤트를 걸어서 지정시관 경과시 태스크큐에 콜백함수객체의 참조값을 넘긴다.
  - 이벤트루프는 고속으로 무한루프를 돌고 있다가 콜스택이 비고 시간이 경과된 두 조건을 모두 만족시킬 때 태스크큐의 참조값을 가지고 함수를 호출한다. 해당 함수가 콜스택에 실행컨텍스트를 생성하며 push된다. 

### 비동기 방식으로 처리해야 하는 하는 작업은 뭐가 있을까?
- 시간이 많이 걸리는 일, 즉 서버 통신과 관련이 있는 작업이 일반적으로는 모두 비동기로 처리된다.
  - 클라이언트 사이드에서는 서버통신 요청: 랜선타고 다녀와야 하며 요청은 대부분 서버에서 DB까지 또 다녀와야 하므로
  - 서버사이드에서는 파일과 관련된 작업: 메모리에 들어있는 건 비교적 빠른 변경이 가능하지만 파일은 하드디스크(요새는 SSD라 그래도 빠른 편이라지만) 다녀와야 해서 오래 걸린다. DB도 파일로 관리되므로 DB 다녀오는 작업도 오래 걸리는 일.
- 이벤트 핸들러도 비동기 방식으로 동작한다.
  - 이벤트는 반드시 전역코드가 끝난(view) 상태에서만 발생한다.
  - **주의할 점** `$element.focus()` 등 메서드로 바로 호출되는 것은 비동기가 아닌 동기로 동작한다.
  - 즉, 브라우저를 통해 이벤트 핸들러를 등록하는 경우만 비동기이다.

