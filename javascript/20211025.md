# Javascript

## localStorage vs. sessionStorage vs. Cookies

### cookies
- 일반적으로 서버가 만들며, 모든 HTTP 요청과 응답에 따라다니는 데이터
- HTML5 이전에는 모든 웹어플리케이션의 데이터는 cookies에 저장될 수 밖에 없었다.
- 4KB의 크기로 헤더에 담긴다
- 갑론을박이 많지만, 여러가지 보안설정을 잘 해두기만 하면 쿠키도 보안성을 가진 storage로 기능한다.

### localStorage와 sessionStorage
- HTML5부터 제공되는 Web Storage API로, 서버로 보내지 않고도 정보를 저장할 수 있는 브라우저의 저장소
- localStorage는 사용자가 지우지 않는 이상은 영구적이며, sessionStorage는 한 세션(창이 열리고 닫히는 기간)에만 유효
- 5MB까지 수용 가능하며, 서버로 보내지지 않고 로컬에만 저장되기 때문에 HTTP 요청/응답 성능에는 영향을 미치지 않는다.

### sessionID
- 로그인 상태를 유지시키기 위해서, 서버는 로그인 성공 시 해당 클라이언트가 로그인된 상태임을 인증하는 토큰을 발급하여 암호화한 후 sessionID를 헤더에 담은(쿠키) 응답을 보내준다. 클라이언트는 매 요청마다 이를 같이 보낸다. 
- 그러나 만일 서버가 여러대라면? 다른 서버로 요청할 때 새로 로그인을 해야 한다.
- 이런 문제를 해결하기 위해 나온 게 JWT(JSON Web Token)으로, 세션ID 방식과 달리 서버와 관계 없이 로그인 상태를 인증할 수 있는 키를 갖는다.

## 비동기

### 타이머
- 타이머함수에 전달되는 콜백함수는 타이머함수가 아닌, 브라우저에 의해 호출된다.
- 타이머함수는 브라우저에게 특정 시간 이후 이 함수(참조값)를 태스크 큐에 넣어달라고 넘기는 역할만을 수행한다. 
- ECMAScript 사양에 정의되지 않은, 호스트객체이다. Web과 Node.js에서 각각 지원한다.
- 디바운스와 스로틀: 디바운스는 보통 input처럼 마지막 이벤트 발생 후 한 번 호출될 필요가 있는 input 자동완성기능과 같은 경우 마지막 한번만 처리, 스로틀은 스크롤 이벤트처럼 여러 번 발생하는 것을 첫 이벤트 발생 이후 어느 시점까지는 한 번의 호출로만 처리

### 비동기 함수
- 비동기함수는 콜백함수를 직접 호출하지 않고 브라우저에 위임하는 로직을 가지는 함수다.
  - c.f. map, filter, reduce 등 배열의 고차함수들은 콜백으로 넘긴 함수들을 직접 호출한다. 즉 동기함수이다.

### JS 엔진과 Web API
- JS 엔진 내부의 구성
  - 실행컨텍스트 스택(=콜스택)
    - 비는 순간 태스크 큐에서 대기하던 비동기 함수가 콜 스택에 push되고 실행된다.
    - LexicalEnvironment와 VariableEnvironment라는 두 개의 프로퍼티와, 각각의 참조값을 갖는 고정된 크기의 객체이므로 스택으로 관리될 수 있다. 
  - Heap 영역
    - stack처럼 차곡차곡 쌓지 못하는 데이터가 쌓인다. 
    - JS전용으로 싸용하는 메모리공간으로 배정된다.
  - (JAVA의 메모리 관리 방식 때문에 다 그렇게 동작한다고 오해하지만) 원시값은 무조건 스택, 힙에는 무조건 객체가 들어가는 건 아니다.
    - ES사양에 따로 기재되어 있지 않으므로 모르지만, V8은 JS 엔진에 heap이 있다고 기재되어있다.
    - JS에서 원시값은 어디에 저장될까? 객체의 프로퍼티로 존재하니까 큰 의미에서는 heap에 저장된다고 봐도 무방(그러나 확언하고 말고 할 본질적인 것이 아니므로 이정도로 넘어가도록 하자)
- Web API
  - 호스트 객체인 Web API는 JS엔진 내부에 존재하지 않는다. JS 엔진 밖에서 브라우저가 관리한다.
  - setTimeout으로 브라우저에 콜백을 넘기면, Web API의 타이머 tick이벤트를 걸어서 지정시관 경과시 태스크큐에 콜백함수객체의 참조값을 넘긴다.
  - 이벤트루프는 고속으로 무한루프를 돌고 있다가 콜스택이 비고 시간이 경과된 두 조건을 모두 만족시킬 때 태스크큐의 참조값을 가지고 함수를 호출한다. 해당 함수가 콜스택에 실행컨텍스트를 생성하며 push된다. 

### 비동기 방식으로 처리해야 하는 하는 작업은 뭐가 있을까?
- 시간이 많이 걸리는 일, 즉 서버 통신과 관련이 있는 작업이 일반적으로는 모두 비동기로 처리된다.
  - 클라이언트 사이드에서는 서버통신 요청: 랜선타고 다녀와야 하며 요청은 대부분 서버에서 DB까지 또 다녀와야 하므로
  - 서버사이드에서는 파일과 관련된 작업: 메모리에 들어있는 건 비교적 빠른 변경이 가능하지만 파일은 하드디스크(요새는 SSD라 그래도 빠른 편이라지만) 다녀와야 해서 오래 걸린다. DB도 파일로 관리되므로 DB 다녀오는 작업도 오래 걸리는 일.
- 이벤트 핸들러도 비동기 방식으로 동작한다.
  - 이벤트는 반드시 전역코드가 끝난(view) 상태에서만 발생한다.
  - **주의할 점** `$element.focus()` 등 메서드로 바로 호출되는 것은 비동기가 아닌 동기로 동작한다.
  - 즉, 브라우저를 통해 이벤트 핸들러를 등록하는 경우만 비동기이다.

## Node.js 로 서버 HTTP 통신 구현하기

### REST API
- HTTP 메서드와 endpoint(=URL, URI)로 API 소통방식에 대한 약속. 
- 동작은 메서드로 표현하고, 위치를 나타내는 명사만을 endpoint에 기재한다.

### 개발환경 구축 (with express)
- npm init 후 express 설치
  - node.js에서 백엔드 구축을 위해 가장 널리 사용되는 패키지로, 프론트엔드의 React와 같은 느낌
  - 배포 시에도 따라가야 하므로 `--save-dev`가 아니라 그냥 깔아야한다.
- server.js 파일 생성 및 express 패키지 import 
  - node.js에서는 module이라는 개념이 클라이언트 사이드보다 먼저 있어 다른 파일을 가져올 수 있었다. 
  - 다만 ESM처럼 export/import가 아니라 require라는 함수로 가져온다.
  - require함수는 npm을 통해 설치한 패키지의 경우 파일의 경로('./node_modules/express/index.js')가 아니라 패키지명('express')만 인수로 넘겨도 import한다.  
```javascript
const express = require('express');
```

- express를 import해 console에 찍어보면 함수 객체임을 알 수 있다.
  - 이를 호출한 결과물을 변수 app에 담자
  ```javascript
  const app = express();
  ```
  - app이라는 변수에 담긴, express 함수가 반환한 값은 `listen`이라는 메서드를 제공한다. 
  - listen: 클라이언트의 요청을 듣는 상태로 변경되며, port 번호를 첫 인수로, callback함수를 두 번째 인수로 받는다. 
    - callback은 성공적으로 서버가 가동되었을 때 호출되는 함수이므로, console에 성공메시지를 띄워주는 정도의 함수로 만들어 넘기자.
    - 어떻게 실행시킬까? terminal에서 `$node server.js`로 실행, node면 당연히 js파일일테니 확장자명은 생략.
    - 이 때, server.js 변경되면 매번 다시 서버를 내렸다가 재가동해야 하는데 실시간으로 server파일의 변화를 감지하여 재가동해주는 nodemon을 설치해주자.

- nodemon 설치 (--save-dev)
  - nodemon은 개발할 때만 쓰고, 배포할 때 같이가면 안된다. 서버로직에 문제가 생기면 서버가 다운되게 하기 때문이다. 
  - 그래서 그 때는 환경을 다시 갖춰주는 다른 패키지를 쓰는 것으로 하고 nodemon은 개발용으로만 쓰기로.

### server.js 코드짜기
- GET 방식으로 온 요청에 어떻게 대응할지 작업을 해두자
  - listen으로 서버를 열어두기 전에 `app.get('/', callback)`으로 루트요청이 왔을 때 callback을 호출한다.
  - 이 callback은 express가 호출하며, 호출 시 요청(req)과 응답(res) 객체를 인수로 넘긴다.
  - request는 client가 보낸 요청을 객체화한 것이며, response는 `send` 메서드를 통해 응답 body를 인수로 넘기며 보낼 수 있다.
    - 이 때 인수는 text, application, 파일 등 다양한 형태로 넘길 수 있다. 
    - express에서 MIME 타입 등이 다 처리된 response로 만들어 보내주기 때문이다.
```javascript
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('<h1>Hello</h1>');
});
```

- 이제 우리가 만들었던 todos 파일을 가져와 정적 파일을 제공해주자. 
  - 단순한 코드(문자열/데이터)가 아니라 파일을 응답으로 제공하려면 middleware를 통해야만 한다
  - 이는 `app.use`에 `express.static({파일 경로이름})`을 인수로 넘기며 호출하면 public을 루트로 한 정적파일을 제공한다.
  - 일반적으로 public이라는 디렉토리에 모든 정적파일을 넣고, 파일 경로이름에 'public'을 넣는다.
  - 루트요청에 대한 `get`과 `use`가 둘다 있는 경우 get은 무시된다.
```javascript
const express = require('express');
const app = express();

app.use(express.static('public'));
```
