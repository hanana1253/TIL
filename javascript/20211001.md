# Javascript

## 인상 깊은 조언
- 지금 당장 어떤 패러다임을 추구하는 코드를 짤 생각보다는, 회사에 들어가서 선배가 가르치는대로 하며 장단점을 고민해 볼 것

## 배운 것들

### 러버덕 Miscellany
- `globalThis`를 쓴다면 어떤 상황인 것일까?
  - Node.js와 브라우저 두 환경 모두에서 사용되는 코드를 짜는 경우. 그럴 일은 거의 없다.
- 클래스 기반의 OOP와 프로토타입 기반의 OOP(JS)는 엄연히 다른데, 왜 new를 붙여 생성자 함수처럼 쓰게 하는지 논란.
  - 같은 호출 방식을 취한다면, 다른 언어에서 넘어온 개발자들이 프로토타입 기반을 어려워하니 다 class 기반으로 코드를 짜려고 할 것이라는 우려의 목소리도 있다.
  - JS 메서드의 문제라고 한다면, this도 그렇고 instance를 참조하며 호출해야 한다는 것 등이 있다.
    - 객체 안의 응집성이라는 장점(연관성을 이해하기 쉽다.)이 있다 하더라도 함수형으로 짜는게 가장 좋다.
  - 클래스는 클래스(인스턴스)를 이해하기 쉽지만, 함수형(=선언형)은 로직을 이해하기 쉽다.
  - 함수는 하나의 일만 하고, 짧을 수록 좋은데 그러면 메서드를 작은 단위로 다 나누어 객체 안에 정의하면 오히려 활용도 떨어진다
- 인덱스 값에 접근할 때 맨 뒤에서 2번째 인덱스를 참조하고 싶으면 `arr.at(-1)`으로 접근이 가능하다.

### 배열의 고차함수
- 중간에 continue나 break 없이 모두 돈다. 그러면 중간에 걸러낼 수 없는 것일까?
  - 아예 걸러내고 나서 고차함수를 사용하면 된다.
- `forEach`: 콜백함수에서 반환하는 값은 고차함수에 전달되어 사용되는데, forEach는 반환값을 전혀 사용하지 않으므로 forEach에 넘기는 콜백에 반환값을 주는 행위는 아무 의미가 없다. 
- `map`: 모든 요소에 대한 리턴값이, 원본 배열과 length가 같은 새로운 배열로 반환된다.
- `filter`: 콜백함수의 결과로 true가 오는 요소들만 새로운 배열로 만들어 반환되며 이 때 length는 원본 배열과 같거나 적다.
- `reduce`: 무조건 하나의 값이 결과로 나온다.
- `sort`는 mutator이므로 배열에 대해 작업할 때 원본 배열을 바꾸고 싶더라도 `[ ... todos ].sort({작업내용})`으로 새로운 배열을 만들어 작업한 후 todos에 재할당해주자. 그래야 함수의 순수성이 유지되고 todos가 바뀐다는 것이 명확히 드러난다.

### Spread 문법
- 연산자라면 평가되어 하나의 값을 생성할텐데, spread 문법의 평가 결과는 값들의 목록이므로 연산자라고 할 수 없다.
- 이터러블에만 사용할 수 있다. 
  - 이터러블은 Symbol.iterator을 프로퍼티로 갖는 객체를 말하며, 배열, String, Map, Set 등과 DOM이 제공하는 유사배열객체가 있다. 
- 이터러블 객체를 copy할 때 직관적이고 명시적으로 표현식을 통해 shallow copy한다
  - `arr.slice()`는 slice의 앞에 배열의 인스턴스가 와야 한다는 것과, 호출 시 전달해야 할 인수의 형태와 갯수를 알아야 하지만 `[ ... arr ]`은 표현식이므로 사용법을 알고만 있으면 사용할 수 있다.

### 디스트럭처링 할당
- 인덱스는 디스트럭처링 받는 순서로, 객체는 디스트럭처링 객체 안에 기술한 프로퍼티 키로 할당이 가능하다.


## 느낀 점
- 점점 실무에 가까운 것들을 배우는 재미가 쏠쏠하다. (그래봤자 실무와 100만광년)