# Javascript

## Miscellany
### `JSON.stringify`는 언제 쓸까?
- HTTP 통신으로 서버로 보내거나 받는 것은 모두 아스키코드 형태이다. 
- 서버에 보내는 데이터는 키와 값의 쌍으로 이루어진 객체가 적절한 형태일진데, 객체 자체를 보낼 수 없기 때문에 문자열화하여 보내는 것
- 이렇게 문자열화된 데이터를 받아 `JSON.parse`로 파싱하여 쓰는 것
- 그러므로 deep copy에 본래의 의도와 달리 `JSON.stringify`를 쓰는 것은 바람직하지 않으며, 속도도 느리다.
- 함수는 해당하지 않는다. `JSON.stringify`는 함수를 가진 객체인 경우 함수를 값으로 갖는 키를 아예 무시하거나, 함수를 값으로 갖는 배열의 경우 null로 문자열화하여 배열의 요소로 넣는다.

### this는 쓰지 않는 게 좋다.
- this는 동적바인딩에서부터, 프로토타입에 this를 통해 참조하는 대상이 있는지까지 여러 가지를 고려해야 한다.
- this를 쓰는 것은 메서드를 객체 안에 정의하기 때문인데, 그 함수를 꼭 객체 안에 넣어야 하는 것인지부터 고민하자.
  - 실무에서는 객체 안에 데이터만 있는 경우가 대다수
- OOP에서 데이터와 behavior가 같이 있어야 할 이유는? **응집도**를 위해서!
  - 한 구석에 다 모여있으니 찾기 쉽고 연관시키기 쉽다.
- 응집도를 높이면서도 함수형을 추구할 수 있는 방법은 없는가?
  - 모듈을 클래스처럼 쓰면 된다. 모듈파일 안에 함수를 쓰고 export하기. 

## 클로저 (cont.)
- 정보 은닉의 차원에서 클로저를 사용하는 경우, 즉시실행함수로 감싸서 하나의 렉시컬 환경만을 생성해야.
- 두 번 호출하면 두 개의 렉시컬 환경이 생기므로 기대한 대로 동작하지 않는다.

### 캡슐화와 정보 은닉
- 캡슐화는 객체로 묶어둔 것 자체를 말하고, 정보 은닉은 캡슐화된 프로퍼티/메서드 중 일부는 공개, 일부는 감추는 것이다.
- 다른 언어에서는 프로퍼티 앞에 public, protected, private 등의 접근제한자 키워드를 붙여 은닉할 수 있다.
- JS에서는 그런 게 없고 클로저를 씀으로써 비슷하게 동작하게 만들 수 있다. 
  - 그러나 클로저를 통한 정보은닉은 완전하지 않다. 같은 생성자 함수에서 나온 인스턴스와 동일한 렉시컬 환경을 참조하고 있기 때문에 인스턴스가 모두 공유하기 때문이다. 이 때 인스턴스 생성 시 초기화한 값으로 기존 인스턴스의 은닉된 정보도 재할당된다.
  - JS는 캡슐화는 지원하지만 정보은닉은 완전하게 지원하지 않는다.

### 결합도와 응집도
- 결합도(coupling)는 낮을 수록, 응집도는 높을 수록 좋다.
- 결합도가 높다는 것은 한 객체가 다른 객체의 프로퍼티를 볼 수 있는지의 문제이다.(실제로 사용하는지는 별개)
  - 정보 은닉이 많이 될수록 결합도는 낮아진다. 외부에서의 참조나 변경이 불가능하기 때문.
- 생성자 함수에서 this로 만든 프로퍼티는 기본적으로 public이며, 인스턴스를 통해 변경이 가능하기에 안전한 상태유지가 불가능하다.
- 생성자 함수에서 지역변수로 선언하고 할당한 프로퍼티는 외부로 노출이나 변경이 불가능하다.

### 전역과 모듈
```javascript
let num = 0;

function increase () {
    num++;
}
```
- 위 전역함수 increase는 클로저인가? 
  - 전역에 선언된 변수 num을 조작하므로 클로저라고 볼 수 없다. 
- 그러나 `export increase` 하는 순간 클로저가 된다.
  - 모듈 코드는 실행컨텍스트를 생성하기 때문!
- 모듈을 쓰면 클로저 사용하기가 굉장히 편하다.
  - 같은 객체에 소속된 것이 아니기 때문에 결합도를 낮추면서도 같은 모듈 파일 안에 있으니 응집도는 높일 수 있다.

## 클래스
- 생성자 함수와 다른 점
  - new와 함께 호출하지 않으면 에러
  - 상속을 지원하는 extends, super 키워드
  - strict mode가 자동으로 지정된다(모듈과 eval 코드 내부와 같이)
- 클래스는 생성자 함수보다 더 엄격하게 객체를 생성하는 메커니즘이다.
  - 생성자 함수를 써야 한다면 class를 쓰는 게 더 좋다.
  - 일반 함수로도 호출되는 생성자 함수에 비해 문법적으로 더 완결성이 높기 때문

### 클래스의 구성과 동작
- 클래스도 내부적으로는 함수로 동작하며, `typeof` 연산자로 찍어보면 'function'이라고 나온다.
- 함수와 같이 호이스팅이 일어나지만, TDZ로 가서 호이스팅이 일어나지 않는 것과 같이 동작한다.
- 0개 이상의 메서드로 구성되어 있으며, 현재 제안된 바로는 클래스필드(인스턴스 프로퍼티)도 정의 가능
- `constructor()`는 엄밀히 말하면 클래스의 메서드가 아니라 함수 몸체의 코드처럼 동작한다.
  - 외부 변수를 받아 초기화하기 위해서는 constructor에서 매개변수를 받아야만 하며, 초기화할 게 없다면 생략도 가능
  - 지역변수의 선언과 할당도 가능하다.
- 인스턴스 메서드: constructor 안에 `this.{메서드이름} = {함수리터럴}`로 하거나 클래스필드에 함수표현식으로 정의
- 정적 메서드: static 키워드를 붙이면 정적 메서드가 된다.
- 프로토타입 메서드: 메서드 축약표현과 같이 정의

### 상속
- `extends`를 통해 간단히 상속 가능
- 생성자 함수도 상위 객체(프로토타입)으로 super class를 상속, 생성자함수의 prototype 프로퍼티에 바인딩된 프로토타입객체도 상위 객체(프로토타입)으로 super class의 prototype 프로퍼티에 바인딩된 프로토타입객체를 상속받는다.
- sub class의 constructor에 rest parameter을 쓰고, `super(...args)`를 호출하면 모든 super class의 인스턴스 프로퍼티를 상속받는다.
  - sub class에서 별도로 지정할 인스턴스 프로퍼티가 있다면, constructor의 매개변수의 개수를 필요한 만큼 더 많이 쓰고, super로 호출하여 받은 것 외의 변수들을 초기화해준다. 
- sub class를 통해 인스턴스를 만들면, 빈 객체의 인스턴스는 super class에서 만들어 super의 호출을 통해 초기화지만 생성자는 sub class라고 간주한다.
  - new와 함께 호출된 클래스가 해당 인스턴스의 생성자 함수라고 보면 된다.
- `super` 키워드는 호출도 되고 참조도 된다.
  - 호출: super class의 constructor()을 호출한다.
  - 참조: 자기 인스턴스의 상위 프로토타입에서 참조한다.

## ES6에 추가된 기능들
## 배열
