# Javascript

## 인상 깊은 조언
- 30분동안 일단 돌아가게끔만 코드를 만든 후 2시간동안 리팩토링하라. 더 나은 방법은 없는지 계속 생각할 것
- `isEqual` 함수 만들 때, 큰 것부터 쳐내면서 만들 것 (타입 확인, +0, -0, NaN, 원시값 및 기타 객체 쳐내기, 객체 length 비교 순으로)

## 배운 것

### strict mode
- 클래스 내부와 모듈 내부의 모든 코드는 기본적으로 strict mode
- ESLint를 사용하면 strict mode에서 문제되지 않을 코드로 잡아준다.
- 그러므로 우리는 별도로 strict mode를 지정하지 않아도 되게끔 모듈 및 ESLint를 사용하자.

### 빌트인 객체
- JS 객체의 분류
  - 표준 빌트인 객체: ECMAScript 사양에 정의된 빌트인 객체
  - 호스트 객체: 브라우저 또는 Node.js 등 실행환경에서 제공하는 객체
  - 사용자 정의 객체
- 호스트 객체는 ES 사양에 기재되어 있지 않으며, Client Side(브라우저)에서는 DOM, BOM, XMLHttpResponse 등의 객체를 제공한다. 
  - XMLHttpRequest는 Ajax의 실체로서, 서버통신할 수 있는 유일한 객체이다.
- 표준 빌트인 객체
  - 원시값과 래퍼객체: 문자열, 숫자, 불리언 등 생성자 함수가 있는 원시타입만 래퍼 객체를 갖는다.

### 전역객체
- window(브라우저 환경), self 등 환경마다 전역객체 이름이 다르다. 그래서 globalThis로 통일
  - 표준 빌트인 객체도 다 window의 프로퍼티인 동시에 식별자이다. 스코프체인에 있다.
- 전역객체는 스코프인가?
  - 전역 렉시컬 환경은 객체 환경 레코드와 선언적 환경 레코드로 구성
  - 전역에 선언된 식별자는 전역객체의 프로퍼티이다. and vice versa
  - 그 이유는 전역 렉시컬 환경의 객체환경레코드, 즉 스코프가 가리키는 것이 곧 전역객체이기 때문이다. 
  - ES6 이전, 곧 선언적 환경 레코드가 존재하지 않을 때 전역객체가 전역스코프 역할을 했다. 
    - 전역변수와 전역함수는 전역객체의 프로퍼티였다. 
    - 이것이 좋은 문법인지는 별개의 문제. var 키워드로 변수를 선언하면 전역객체의 프로퍼티가 된다는 게... 
- 전역객체는 언제 만들어질까? 어플리케이션을 가동하자마자 전역코드가 평가되면서 (런타임 이전) 만들어진다.
  - 각 브라우저의 창과 탭마다 전역객체는 다르다. 같다면 네이버와 Poiemaweb이 같은 전역객체를 공유하며 충돌 대파티일 것
  - app을 시작하며 생겨난 전역 객체는 아무도 참조하지 않는데, garbage collector의 대상이 되지 않을까? 전역객체만 예외.
- 전역 함수(`parseInt`나 `eval` 등)는 언제부터 존재했을까?
  - 전역 객체의 메서드로 존재하는 전역함수는 왜 Object에 속하지 않고 전역에 있을까? 많이 쓰니까... 그러나 요새는 많이 안쓴다.
  
### 암묵적 전역
- 함수 내부에서 변수선언문 없이 할당된 변수에 대해서 스코프 체인의 끝까지 찾다가 없으면 전역 객체의 프로퍼티로 만들어진다.
- 그러나 var로 선언한 전역변수와 달리 delete로 삭제할 수 있다. `delete window.x` 

### `this`
- `this`가 가리키는 것은 호출되는 경우마다 다르며 이를 this의 동적 바인딩이라 한다.
  - 일반함수로 호출되는 경우 함수 내부의 this는 전역 객체를 가리킨다
  - 메서드로 호출되는 경우 참조연산자 앞의 객체, 즉 메서드로 호출한 객체를 가리킨다.
  - 생성자 함수로 호출되는 경우 생성자 함수가 생성하는 인스턴스를 가리킨다.
  - `apply`, `call`, `bind`로 앞의 함수객체를 호출하는 경우 해당 함수 내의 this는 `apply`, `call`, `bind`의 인수로 들어가는 객체를 가리킨다. 
    - 이들은 `Function.prototype`에서 상속되는 메서드로, 교체할 this를 인수로 전달하며 호출한다. 
    - 2개 이상의 인수가 있는 경우 `call`은 2번째부터의 인수를 풀어서 콤마로 구분하여 전달하고, `apply`는 배열 안에 넣어 전달한다는 차이만 있다.
    - `bind`의 경우 this만 전달하고 호출은 별도로 해주어야 한다. 객체 메서드 내부에서 콜백함수를 사용하는 경우, 콜백함수가 일반함수로 호출되면 여전히 그 안의 this는 전역객체이므로 bind로 메서드 내부의 this, 즉 객체를 가리키는 this를 전달하며 호출한다. 그러나 이 모든 문제는 화살표함수 사용하면 끝난다.
 