# Javascript

## 인상 깊은 조언
- 안 되는 걸 되게만 하는 것이 다가 아니라, 문제의 발생원인을 찾아 앞으로 비슷한 문제가 생겼을 때 해결방법을 알아내는 것이 프로그래머이다.
- 실무에서는 상황에 따라 어떤 코드가 좋은 것인지 다르다. deep copy를 재귀 불러서 다 하게 하기보다 2 depth까지만 하는 것이 더 가볍고 좋을 때도 있다. 
- 되든 안 되든 자신의 철학이 들어간 코드를 짜야 한다. 맞든 틀리든 코드 한 줄에도 내 생각이 들어가야 한다.
  - 이게 좋다더라는 코드를 짜지 말고 나를 믿고 나의 코드를 짜고, 왜 그렇게 짰는지 설명할 수 있어야 한다.
  - 단 한 줄을 짜더라도 현학적으로 짜기보다 담담하게 짜야 한다. 

## 배운 것들

### 프로토타입(객체지향)을 신봉하지는 말자
- 생성자 함수에서 각 인스턴스에 this로 바인딩한 메서드를 만드는 대신, 프로토타입에 메서드를 넣는 이유는 무엇일까?
  - 재사용? 생성자 함수에 this로 바인딩해도 찍어낼 때마다 코드의 재사용은 일어난다.
  - 각 인스턴스마다 코드를 갖고 있지 않아도 된다는 메모리 상의 이점 외에는 큰 이점이 없다. 
- 오히려 인스턴스가 꼭 있어야만 호출할 수 있다는 단점이 있을 뿐이다.
  - 생성자 함수의 this는 반환할 인스턴스를 가리키므로 인스턴스 없이 접근하면 this가 가리키는 것이 없다.
  - 아래 코드에서 생성자 함수의 프로토타입 프로퍼티에 바인딩된 객체가 name이라는 프로퍼티를 따로 갖는 게 아니라면 `Person.prototype.sayHi()`로 호출된 함수몸체의 `this.name`은 undefined를 반환
- 이럴 때는 객체지향에 집착하지 말고 그냥 함수로 만들어서 갖다 써라
  - 프로토타입 메서드보다 그냥 함수가 name만 넣으면 되니 다른곳에서도 사용할 수 있고 더 재사용성 측면에서 좋을 수도 있다.
```javascript
// 인스턴스에 메서드를 각각 다는 생성자 함수
function Person(name) {
    this.name = name;
    this.sayHi = function () {
        console.log(`Hello, My name is ${this.name}.`)
    };
};

const me = new Person('Lee');

// 인스턴스 메서드로 호출
me.sayHi(); // Hello, My name is Lee.

// 위에서 this.sayHi 할당을 하지 않았다고 치고 아래 코드를 추가하여 프로토타입 메서드로 넣는다.
Person.prototype.sayHi = function () { 
    console.log(`Hello, My name is ${this.name}.`)
};

// 프로토타입 메서드로 호출
me.sayHi(); // Hello, My name is Lee.
```

- 프로토타입은 상속에 매우 유용하지만, 상속 자체가 좋은 것인지는 고민해보아야 한다.
- 상속이란 자기가 갖지 않지만 갖다 쓸 수 있는 것인데, 이는 혼란을 줄 수도 있다.
  - 상속받아서 쓸 수 있는 프로퍼티/메서드를 알아야만 유용하게 쓸 수 있다.
  - 부모(상위)객체가 가지고 있는 것이 전제되어야 한다. 상위객체에게 없는 메서드를 호출하면 타입에러가 난다.
  - 부모에게 없으면 쓸 수 없기에 강하게 의존하고 있다(tight coupling).
- 클래스가 아니라면 너무 장황해지는 까닭에 프로그래밍 패러다임도 객체지향으로 가다가 결국 함수형으로 회귀하는 추세이다.
  - e.g. `hasOwnProperty`라는 메서드는 누가 가지고 있을까? 
    - `Object.prototype`이 가지고 있어 모든 객체 인스턴스가 사용할 수 있다. 이는 우리가 알고 있기에 사용할 수 있지만...
    - 앞에 인스턴스가 와야 한다는 것을 모르거나, 프로토타입(상위객체)을 인위적으로 갈아끼운 상황에서는 제대로 호출하지 못한다.
    - `Object.hasOwn(instance, property_key)`로 메서드의 존재를 확실하게 아는 상태에서 인수로 인스턴스를 넘기는, experimental 단계의 함수가 제안되고 있다. 
    - 인스턴스를 가리킬 필요가 없이, 바로 인수로 넘겨진 인스턴스에서 작업하면 되기 때문에 this가 필요치 않다. 
    - 네임스페이스 용도로 Object에 관련한 함수들을 프로퍼티/메서드로 묶어둔 생성자 함수객체와 함께 쓰였을 뿐, `hasOwn`은 함수다.
  - `hasOwn`과 같은 함수를 전역에 두지 말고 어떻게 관리할 수 있을까? 
    - 생성자 함수에 Namespace 개념으로 달아둔다. 함수와 객체지향의 미묘한 짬뽕
    - 모듈로 싹 모아서 export해주고 필요할 때만 import로 꺼내서 쓴다. 

### 생성자 함수와 객체 리터럴
- 생성자 함수를 만든다는 것은 같은 구조의 객체를 여러번 만들 가능성이 높다는 것
  - 그러나 프로토타입 메서드가 없고 각 인스턴스의 프로퍼티만 있는 경우 그냥 함수리터럴을 반환하게 하는 함수를 사용하면 된다.
- 생성자 함수 객체는 JS 파일이 로드되자마자 만들어진다.
  - JS는 진입지점이 따로 없으니 서버로부터 JS파일이 로드되면 바로 실행되며, 함수선언문의 경우 전역객체가 만들어진 후 바로 평가되면서 함수객체가 만들어진다. 
  - 함수 객체 생성 시 해당 생성자 함수가 만들 인스턴스의 프로토타입 객체도 만들어지며, 생성자 함수와 이 프로토타입 객체는 각각 `prototype`과 `constructor` 프로퍼티에 서로를 참조하게끔 바인딩된다.
  - 프로토타입 객체를 가리키는 `prototype` 프로퍼티는 생성자 함수로 호출될 수 있는 함수객체라면 모두 가지며, 생성 시 프로토타입을 생성하며 바인딩된다.
    - `[[ Environment ]]`, `[[ Call ]]`, `[[ Construct ]]`등의 내부슬롯, 내부메서드도 함수 객체 생성 시 함께 가지고 있다.
    - c.f. `__proto__`로 참조하는 `[[ Prototype ]]` 내부슬롯은 모든 객체가 다 가지고 있다. 즉 모든 객체는 자신의 상위 객체인 프로토타입을 가진다. 
    - `__proto__` 접근자 프로퍼티는 `Object.prototype`으로부터 상속받는다. 
```javascript
function Person(name) {
    this.name = name;
};

const me = new Person('Lee');
```
- 위 코드 소스코드를 런타임 전 평가하면서 함수선언문과 변수선언문을 실행하여 함수 객체를 만들고 전역스코프에 바인딩한다. 
  - 런타임에는 식별자를 찾아 전역스코프에 들어가 함수 몸체 코드블록을 평가
  - 함수 몸체 코드블록 실행하며 가장 최상단에서 암묵적으로 객체를 하나 만든 후 this에 바인딩한다.
  - 이 때 this에 바인딩된 객체는 `Person.prototype`을 `[[ Prototype ]]` 내부슬롯의 값으로 갖는다.
  - name을 this에 초기화시키고 만들어진 인스턴스 this를 암묵적 반환한다. 

### 프로토타입 객체와 `__proto__` 접근자 프로퍼티
- 프로토타입 객체는 일반 객체이며, 모든 객체는 Object가 생성한 것처럼 가상적인 생성자 함수를 Object로 여긴다.
- 프로토타입의 프로토타입은 `Object.prototype`이며, 이는 프로토타입의 종점이다. 
- `Object.prototype`의 `__proto__`는 null을 반환한다.
- 인스턴스가 갖지 않은 프로퍼티 키를 참조하는 경우, 해당 인스턴스의 상위객체(프로토타입)로 올라가 찾는다.
- `Array`, `Function` 등도 함수객체를 가리키는 식별자이기 때문에 함수이자 객체이다. 
  - `[[ Prototype ]]` 내부슬롯을 가지며, 이 값은 `Function.prototype`이다. 
  - `Function.prototype`의 프로토타입은 `Object.prototype`이다.
- `__proto__` 접근자 프로퍼티는 원래 비표준이었다가 브라우저들이 다들 구현하니까 표준으로 올라왔다.
  - 하지만 쓰지 않는 것이 권장되며, 대체 문법을 사용할 것
  - `Object.getPrototypeOf(instance)`와 `Object.setPrototypeOf(instance, 프로토타입객체)`로 `__proto__` 접근자 프로퍼티의 getter, setter 함수를 대체할 수 있다.
- 프로토타입 객체를 교체하면 생성자 함수와 프로토타입 객체 사이의 연결이 깨져 따로 이어줘야 하는 번거로움
  - 교체할 거면 차라리 처음부터 `Object.create(프로토타입객체)`로 반환하는 객체를 갖다 써라.

### instanceof 연산자
- `instanceof` 연산자는 좌변에 오는 객체의 프로토타입 체인에 우변에 오는 생성자 함수객체의 프로토타입 프로퍼티에 바인딩된 프로토타입 객체가 있는지 확인한다.
- 그러므로 자기 자신의 생성자 함수 뿐 아니라 조상 생성자 함수에 있는 것도 모두 true 리턴한다.

### 직접상속
- `Object.create(프로토타입 객체)`로 직접 상속을 구현할 수 있으나 프로토타입 종점에 있는 인스턴스를 인위적으로 만들 수 있으니 유의할 것
- 객체 리터럴 안에 `__proto__` 프로퍼티 값으로 프로토타입 객체를 넣어줄 수도 있다.

### 정적 프로퍼티와 정적 메서드
- 메서드를 어디에 넣어주어야 할까?
  - 생성자 함수에 넣으면 정적 메서드이며, this가 필요 없는 메서드의 경우 인스턴스를 생성하지 않아도 전혀 문제 없이 사용할 수 있도록 정적 메서드로 만든다.
  - 각 인스턴스 자체의 프로퍼티를 this로 참조해야 할 때는 생성자 함수의 프로토타입 프로퍼티로 접근하여 프로토타입 메서드를 동적 추가한다. 
  - 굳이 인스턴스에 메서드를 만드는 사람과는 상종을 하지 말아야 한다.

### `in` 연산자와 `for ... in`문
- `in` 연산자는 자기 고유의 프로퍼티 키 및 상속된 프로퍼티 키를 확인할 수 있으며, `for ... in`문은 상속된 프로퍼티 키들을 모두 열거한다. 
  - 이 때 `[[ Enumerable ]]` 내부슬롯 값이 true여야 열거된다.
- 상속된 프로퍼티는 열거에서 제외하고자 한다면 `hasOwnProperty` 메서드를 쓸 수도 있지만 굳이 이런 로직을 추가할 필요 없이 `Object.keys`나 `Object.entries`를 사용하면 된다.
- `for ... in`문은 상속을 고려해야 하며, 순서가 의미 없어 무작위로 열거되기 때문에 쓰지 않는 것이 좋다.
  - 배열을 다룰 때에는 순서가 중요한 만큼 키로 접근할 이유가 없으니 더더욱 쓰지 말 것

### `call` 메서드
- `me.hasOwnProperty(key)`와 `Person.prototype.hasOwnProperty.call(me, key)`는 동일하게 동작
- call 메서드는 두 인수를 전달하며 두가지 일을 한다.
  - call 메서드의 this로 온 함수객체를 호출한다. (여기선 `Person.prototype.hasOwnProperty`) 
  - 호출하는 함수객체의 this에 바인딩할 객체를 첫 번째 인수로, 함수객체가 받을 인수를 두 번째 이후의 인수로 전달한다.
- 왜 이렇게 할까? me 객체에 `hasOwnProperty`라는 메서드가 있는지 미지수이므로. 

## 느낀 점
- 이 상황에서 이 것을 왜 쓰는지 아는 것은 중요하지만 어렵구나.