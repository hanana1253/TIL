# JavaScript

## 인상 깊은 조언
- 자꾸 문제를 풀거나 무언가 만들고 싶겠지만 먼저 이론을 잘 다지고 문제를 풀 것
- 공부하는 게 괴로운 건 정상이다. 하루하루가 힘들어 죽을 것만 같아야 한다.
- 알고리즘은 문제를 제대로 이해하는 능력부터 길러야 하는데, 사실 암기의 영역이기 때문에 문제 150개를 달달 외워라. 졸업 후 1년동안 매일 3개씩 외우며 하루 4시간 정도는 투자해야 할 것.

## 함수 (Function)
- 함수는 JS 뿐 아니라 다른 언어에서도 다른 개념의 기초가 된다.
- 함수 속 x, y는 미지수이다. 외부에서 변수의 값을 받아오기 전까지는 무엇이 들어올 지 모르기 때문이다. 
- 동일한 이유로 함수를 만드는 시점에는 결과값을 모른다. 호출할 떄에서야 x, y의 값과 결과값을 알 수 있다.


```javascript
function add(x, y){
  return x + y;		
}

add(2, 3)	// 5			
```
- 함수의 코드블럭은 0개 이상의 문으로 이루어져있다.
- parameter, 매개변수, 인자: 위 함수에서의 x, y
  - `var` 키워드는 없지만 매개변수 또한 엄연히 선언되는 변수이다. 이름을 잘 지어주어야 한다. 
  - 0개 이상이 올 수 있다.
- return: 뒤에 오는 표현식의 값을 평가해 함수 바깥으로 던지며, 함수코드블록을 끝낸다.
- `add(2, 3)`: 반환값을 함수 밖에서 활용할 수 있는 표현식이며, 변수에 할당도 가능하다.
  - 인수(argument): 함수 바깥에 있는 값으로, 매개변수에 할당되는 재료이다. parameter 순서와 동일하므로 순서의 의미가 있다.
 
### 함수 정의
- 함수는 왜 선언이 아니라 정의라고 부를까? JS에서는 둘 사이의 구분이 모호하지만 ES에서 구분하라고 하니 구분하자. 
- 변수 이름은 명사, 함수 이름은 동사로 짓는다.
- 함수는 정의할 떄가 아닌, 호출할 때 실행된다. 
  - 정의는 기계를 만드는 것으로, 런타임 이전에 실행된다.
  - 호출은 런타임에 기계를 사용하는 것, 호출하지 않으면 재료가 없으므로 작업을 할 수 없다.

#### 함수선언문
```javascript
function add(a, b){
  return a + b;
}
```
- 단점: 런타임 이전에 정의되기 떄문에 호출하는 코드의 위치와 상관없이 실행되는 함수 호이스팅 발생.
- 변수호이스팅은 선언 전 undefined로 참조되는 것이고, 함수호이스팅은 아예 선언 전 위치에서도 실행이 된다.

#### 함수표현식
```javascript
var add = function add(a, b){
  return a + b;
}
```
- 함수 선언 전 add를 참조하면 undefined 값이 나오고, add(1, 2)를 호출하면 함수가 아니기 때문에 타입에러가 뜬다.
- 즉, 함수호이스팅이 아니라 변수호이스팅이 일어나며 함수 정의 전에 호출할 수 없다.

```javascript
var add = function foo(a, b){ ... };
```
- function 이후 부분인 함수리터럴은 함수를 생성하는 표기법이다.
- foo는 함수이름으로, 함수 내부(몸체)에서만 유효하며 디버깅 또는 재귀함수를 위해 쓸 수 있다.
- add는 식별자로, 함수 외부에서 호출할 때 쓰인다. 식별자와 함수 이름을 동일하게 쓰기 위해, 함수 표현식의 함수 이름을 생략하면 혼란을 줄일 수 있다.

#### 함수선언문과 함수표현식
- 함수선언문은 런타임 전에 함수가 만들어진다.
- 함수표현식은 선언 및 초기화만 되고 런타임에 할당문 실행될 때 함수가 만들어진다.
- 원초적으로 따지면 작업을 최대한 미루는 lazy한 함수표현식을 사용하는 게 낫다. 하지만 함수호이스팅만 조심한다면 아무거나 쓰되 일관성있게 쓸 것. 그러나 둘다 쓰지마라. 화살표함수 쓸거니까.

#### 일반객체와 함수객체 비교
- 일반객체와 함수객체의 차이는 호출 가능 여부. 일반객체는 호출을 못한다.

### 함수 호출
- 함수 정의만으로는 실행이 되지 않는다. 코드블록을 실행하려면 호출이라는 행위가 있어야 한다. 
- 함수도 제어문의 일종이다. 호출을 만나면 함수 안으로 들어가면서 자연스러운 흐름에서 벗어나 코드흐름 순서가 바뀐다. (함수를 subroutine으로 표현하기도 한다?)
- 호출은 곧 코드블록을 실행하는 타이밍을 개발자가 제어한다는 의미이기도.
- 외부에 있는 값을 내부로 밀어넣어준다. 인수를 넣어서!
  - 매개변수의 개수만큼 인수를 줘야하는데 인수 type을 뭐로 넣어야하는지 모른다는 게 JS의 특징.
  - 인수를 덜 넣으면 y라는 매개변수는 선언만 되고 할당을 되지 않는다. 그래서 undefined로 초기화된다.
```javascript
function add(x, y){
  return x + y;
}
console.log(add(2));	// NaN
```
  - 위의 코드의 결과는 y가 undefined인데 산술연산자인 +를 만났기 때문에 NaN.
- 누군가 잘못 입력하는 상황까지 계산해서 코드를 짜야 한다. 
  - Solution 1. 에러 발생시키기. 제대로 호출하지 않았다는 걸 알려준다.
  - Solution 2. 초기값을 준다. (그러나 인수 안 넣었는데 문제없이 작동되는 게 과연 바람직한 건지 고민해보아야.)
- 매개변수의 개수보다 넘치는 인수는 무시되는 것처럼 보이지만, 사실은 함수 안에서 arguments라는 유사배열객체가 자동생성되어 그 안에 담긴다.
  - 아예 parameter 없이 들어오는 인수가 담긴 arguments 객체를 가지고 작업하는 것도 방법이다. 이를 가변인자함수라고 부른다.
  - arguments는 해당 함수 안에서만 유효하다.
- 들어오는 임의의 개수의 인수를 모두 더하는 함수를 만들어보자.
```javascript
const add = function(){
  let result = 0;
  for (let i = 0; i < arguments.length; i++){
    result += arguments[i];
  }
}
```
- 유사배열객체: 배열로 쓸 수 있도록 아래와 같은 특징을 갖는 객체.
  - property key가 숫자로 되어 있다.
  - length라는 property를 갖는다. for문을 돌려야 하니까 총 갯수를 알아야 함
- 나머지 매개변수(rest parameter): arguments 객체를 쓰지 않고도, parameter 부분에 `(... args)`로 인수를 받는 ES6 이후의 모던 방법. (나머지 매개변수 args  앞에 ...을 선언해주면 모두 args라는 식별자의 배열로 들어온다)
- 매개변수의 최대 개수는 ES에 명시되어 있지 않다. 
  - 매개변수는 적을수록 좋다. 인수를 제대로 전달하지 않으면 실행되지 않으니까.
  - 함수는 사용법을 알아야 호출할 수 있는데, 호출만 하면 될 수 있게끔 하는 것이 가장 좋은 함수이다. 
  - 3개까지는 참아주겠지만 매개변수가 늘어날수록 죄책감이 느껴져야 한다.
  - 4개 이상인 경우 객체로 전달하는 게 훨씬 좋다. 함수의 인수로 객체를 전달하면 순서와 상관없이 값을 전달하면서, 전달하는 값의 의미도 알 수 있기 때문.
    - 단점: 전달된 객체에 대한 부수효과 리스크가 생긴다. 함수의 매개변수에 객체의 참조값이 할당되었는데 함수 실행으로 인해 객체내용이 바뀌면, 함수 내에서 작업한 내용이기 때문에 `console.log` 찍기 전에는 바뀐지 알길이 없다. 
    - 이를 막기 위해서는 object를 동결시키거나 매개변수에 할당될 객체 인수를 카피본으로 주어야한다.
    - react 등의 framework에서는 불변으로 쓰게끔 세팅되어있다.

### return문
- return의 두가지 의미: 뒤의 표현식의 값을 평가하여 함수 밖으로 던지고, 함수몸체의 코드블록을 종료한다.
- 함수에서 return이 생략되면 JS엔진은 암묵적으로 return이 있는 것처럼 실행(return 뒤에 아무것도 없으면 undefined를 return)
- 함수의 코드블록이 끝내기 때문에 맨 마지막에 써주는 것이 정석
- return 키워드는 함수 내에서만 사용한다.

### 즉시실행함수(IIFE, Immediately Invoked Function Expression)
- 함수 정의와 동시에 즉시 호출되는 함수로, 한 번만 호출되며 다시 호출할 수 없다.
- 함수리터럴이기 때문에 바로 `()`로 실행가능하지만 JS엔진이 함수선언문으로 해석하지 않도록 그룹연산자로 묶어주어야 한다. (그룹연산자 안에는 값, 즉 표현식만 올 수 있으므로)
```javascript
(function (){ ... }());
```
- 함수실행을 위한 소괄호 `()`는 화살표함수와의 일관성을 위해 그룹연산자 밖에 써주는 것이 요즘은 정석으로 여겨지고 있다.
```javascript
(function (){ ... })();
```

### 재귀함수(recursive function)
- 자기 자신을 호출하는,  재귀호출을 수행하는 함수. 
- return문과 탈출조건을 써주지 않으면 무한호출된다.
- 실수할 확률이 높기 때문에 알고리즘 문제가 아닌 이상은 쓰지 않도록 하자.

### 중첩함수(nested function)
- 함수 내부에서 선언한 함수로, 중첩은 곧 부모자식 상속이 이루어짐을 의미한다.
- 왜 함수 내부에서 굳이 함수를 만들까? 
  - 외부함수만 쓰고 다른 애들은 못 쓰게 하려고. 코드 전체에서 사용할 수 있는 함수가 되려면 전역에서 만들어야 한다. 
  - 정보 은닉 차원에서, 컴퓨터가 처리하고 사람이 굳이 사용법을 몰라도 되는 경우
  - 그냥 코드가 아닌 함수를 만드는 이유는 로직의 재사용이 가능하므로 한 번 이상 사용할 경우에 유용하기 때문인데, 이 때 중첩함수의 이름을 잘 지어야 무슨 작업이 이루어지는지 알 수 있다(=가독성이 좋다).

### 콜백함수(callback function)
- 함수의 인수로 들어가는 함수. 아래 예시와 같이 0부터 n까지 특정 작업을 n번 반복하게 하려면, n을 첫 번째 함수로, 특정 작업을 하는 함수 f를 두 번째 인수로 주어 반복실행을 시킬 수 있다.
- 중첩함수를 외부에서 받아와서 실행하는 것이다.
- 이 때 인수로 콜백함수를 전달받는 외부 함수를 고차함수라고 부른다. 또한 반환값이 함수인 경우에도 고차함수라고 부른다.
```javascript
function repeat(n, f){
  for (var i = 0; i < n; i++){
    f(i);
  }
}
```

### 순수함수(pure function)와 비순수함수(impure function)
- 순수함수는 수학적 의미의 함수와 같이 언제 넣어도 똑같은 인수를 전달하기만 하면 같은 리턴값을 반환하는 함수이다. 
- 비순수함수는 오늘 날짜나 시간을 리턴값으로 내는 함수처럼 똑같은 인수를 전달해도 결과값이 다른 함수이다.
- 함수형 프로그래밍에서는 순수함수가 더 심플하고 이해와 사용, 테스트가 쉽기 때문에 순수함수를 지향한다. 또한 이런 장점들 때문에 순수함수는 테스트 주도 개발에 적합하다.

## 스코프(Scope)
- 식별자가 등록되는 곳으로, 식별자를 찾을 떄 JS엔진은 먼저 지역스코프에서 찾고, 없으면 전역 스코프로 올라간다. 지역스코프와 전역스코프의 관계가 규명되어있어야 하므로, 단방향 linked list 형태인 스코프체인이 존재한다고 할 수 있다.
- 전역은 함수 내부가 아닌 모든 곳으로, 전역에 선언된 변수는 어디서나 참조가 가능하다. 
- 소스코드는 크게 4가지로 구분: 전역코드, 함수코드, Eval 코드, Module 코드
  - 전역코드가 실행되면 Scope라는 실체가 만들어지고 이를 Lexical Environment라고 부른다. 식별자 이름과 값이 관리되는 스코프라는 객체가 만들어진다고 생각하면 된다.
  - 함수코드가 호출되면 지역스코프가 만들어지고 지역변수와 매개변수, arguments 객체가 생성된다.
  - Eval 코드와 Module 코드는 현재로썬 몰라도 ok.

### 함수레벨 스코프
- `var` 키워드로 선언한 변수에 대해 함수만을 스코프로 인정하는 JS의 특성
- 함수가 아닌 다른 코드블럭(블록문, if문, for문 등의 제어문)에서 `var` 키워드로 선언되는 변수는 전역 변수로 생성되며, 중복 선언이 허용된다는 JS의 약점.
- 이를 피하기 위해 `let`과 `const` 키워드를 사용할 것

### 렉시컬 스코프(Lexical Scope)
- 함수가 정의될 때의 위치를 기준으로 상위 scope를 결정한다. (호출될 때가 아니라 정의되로 때 결정된다)
- JS 및 대부분의 프로그래밍 언어가 lexical scope를 지원
- c.f. 동적 스코프: 함수가 호출될 때의 위치를 기준으로 상위스코프 결정하며, Pearl이라는 언어에서 지원한다.

### 전역변수
- 사용금지. 그 이유는 ...
  - 전역변수는 브라우저를 켜놓는 동안 계속 살아있다: 변수가 확보된 메모리 공간은 브라우저가 켜있는 동안은 release되지 않는다.
  - 암묵적 결합: 어디서든지 재할당이 일어나 변수값이 바뀔 가능성이 높아지며 변수 값 추정이 어렵다.
  - 스코프체인 상 최종점에 위치하여 차이는 미미할지라도 식별자 탐색에 더 오랜 시간이 걸린다.
  - 네임스페이스 오염: 식별자로 쓸 수 있는 이름이 재할당을 피하려면 점점 줄어든다.
- 변수는 scope의 생애주기와 동일하기 때문에 지역변수는 함수 호출 시 태어나 함수실행이 종료되면 죽는다.
- 전역변수를 사용하지 않기 위해 즉시실행함수로 모든 코드를 감싸는 것...은 오래된 방식
  - ES6 이후는 module 스코프에서 관리하도록 module을 쓰는 것이 modern한 방법
- 이상적인 함수는 하나의 일만 하는 함수이다. 곧, 명확하게 하나로 떨어지는 이름을 가진 함수가 좋다. 이런 함수의 지역변수는 짧은 시간만 메모리를 확보하고 해제한다.

## `let`과 `const` 키워드
- `var`의 치명적 단점
  - 중복선언 허용: 이미 선언된 변수에 대해 또 선언해도 ok. `let`이나 `const`는 얄짤없이 에러를 내준다. 
  - 함수레벨 스코프만 지원: `let`, `const`는 블록레벨 스코프 지원
  - 변수 호이스팅: `let`과 `const`도 호이스팅이 일어나긴 하지만 undefined로 초기화 된 후에 할당문을 만나기 전까지 `TDZ(Temporary Dead Zone)`이라는 메모리 공간을 가리킴으로써 값에 접근이 되지 않도록 하며 호이스팅이 발생하지 않는 것처럼 동작한다. 
- 언제 `let`을, 언제 `const`를 써야 할까? 
  - `let`은 재할당이 가능하기 때문에 선언만 하고 나중에 초기화가 가능하다. 
  - `const`는 재할당이 불가능하며 선언할 때 반드시 할당문으로 초기화해줘야 한다. 
  - `const`로 객체가 할당된 변수의 경우, 객체를 가리키는 참조값을 값으로 할당받았기 때문에 객체 실체의 변경은 가능하다.
  - 그러니까 무조건 `const` 쓰되 재할당이 필요한 원시값에 한해서만 `let`을 쓰고, `let` 쓸 때도 꼭 재할당이 필요한건지 한번 더 고민할 것
- 변수와 상수의 개념이 수학과는 다르다. 상수는 재할당이 불가능한 변수를 말하며, 변수는 하나의 값을 저장하기 위한 메모리 공간 또는 이를 가리키는 이름이다.

## 오늘의 결론
- `var` 키워드 절대 쓰지마라
- 전역변수 쓰지마라
- 함수는 하나의 일만 하도록 작게 만들어라. 그럼 이름도 짓기 쉽다.

## 느낀 점
- 함수도 그렇고 상수도 그렇고 가장 간단하고 변화의 여지 없이 명확한 것이 가장 좋은 것이다.
- 모던한 방법들로 진화해온 건 좋은데 하위호환 때문에 아직 남아있는 것까지 배우려니 조금 억울하다.

