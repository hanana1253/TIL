# JavaScript

## 인상 깊은 조언
- 나름 좀 알고 있다고 생각하고, 더 배울 필요가 없으면 굳이 공부하지 않게 된다. 그러니 어디에 적을 두고 있는지가 중요하다. 취업에 조급해하지 말고 좋은 곳에서 성장하는 것을 목표로 직장을 잡아라.
- 천편일률적인 포트폴리오에 목숨걸 필요 없다. 코드 한 줄 한 줄이 더 중요하고 그 코드를 왜 짰는지 설명할 수 있는 능력이 더 중요하다. 프로젝트 또한 결과를 만드는게 중요한 게 아니라 학습했던 것들을 실제로 구현하면서 내가 무엇을 아는지, 무엇을 모르는지 확인하는 것이 중요하다.

## 러버덕 부가설명
- `...` 뒤에는 무엇이 올 수 있을까? 상황에 따라 다르다.
  - rest parameter로 쓰이는 경우: 식별자가 온다
  - spread 문법으로 쓰이는 경우: iterable(배열, 문자열, DOM 콜렉션 등)이 온다
- spread는 연산자인가? 
  - `const arr = [1, 2, 3];`에서 `... arr`는 `1, 2, 3`이다. 값으로 평가될 수 없기 때문에 피연산자를 갖는 연산자의 의미에 부합한다고 말할 수 없다.
  - spread는 그래서 그냥 문법이라고 부른다. 표기방법일 뿐이다.

## 배열 메서드 (cont.) 
- `splice()`: 첫번째 인수인 인덱스값부터 두 번째 인수인 요소 개수만큼 잘라내 리턴한다.
- `slice()`: 인덱스값인 인수로 지정된 범위의 요소들을 가진 배열을 복사해서 리턴한다. 인수를 넣지 않으면 통으로 복사하는데, 이 때 얕은 복사가 일어난다.
- `join()`: 인수로 넣은 구분자로 각 요소를 모두 이어붙인 문자열을 반환하는데, 인수를 넣지 않으면 `,`를 구분자의 초기값으로 갖는다.
  - 반대로 하나의 문자열을 쪼개려면 `split()`을 사용하며, 인수로는 구분의 기준(공백 등)을 넣어준다.
- `reverse()`: 배열 요소들의 순서를 뒤집는 mutator 메서드로, 원본도 변경하면서 반환값으로 변경된 배열을 리턴한다.
  - 문자열을 순서 뒤집으려면? `split('')`, `reverse()`, `join('')`을 차례로 사용하되, 한번에 `str.split('').reverse().join('');`으로도 가능하다. 이 때 원본 문자열은 변경되지 않는다. 왜냐면 문자열은 원시값이기 때문이다!
- `fill()`: 인수로 넣은 요소로 배열을 채운다. ES6에서 도입되었지만 이례적으로 mutator인 메서드이다.
- `includes()`: 인수로 넣은 요소를 배열이 가지고 있는지 확인하여 boolean값을 리턴한다. `indexOf()`와 동작원리는 비슷하지만 요소 보유 여부만 파악할 때 사용한다.
- `flat()`: 배열의 요소로써 배열이 존재할 때 안에 있는 배열을 푼다. 인수로 넣은 depth만큼 풀며, 인수를 넣지 않으면 1개만, 인수를 `Infinity`로 넣으면 모든 depth의 배열을 푼다.

## 배열의 고차함수
### 함수형 프로그래밍
- 객체를 인수로 주어 함수 내에서 객체에 작업하는 경우, 밖에 있는 객체의 실체까지도 변경되는데 이를 외부 상태의 변경이라고 한다. 이렇게 변경하는 것들은 사전에 파악되어 공유되어야 하는데, 이런 상황을 애초에 피하기 위해 불변성을 지향하는 것이 함수형 프로그래밍이다.
- 모든 함수를 순수함수로 만들고, 외부상태를 변경하지 않게끔 같은 인수에 대해 같은 결과값을 항상 기대할 수 있게 하는 것
- 함수형 프로그래밍에서는 코드의 흐름을 뒤죽박죽으로 만들어 읽기 어렵게 하는 제어문을 극히 싫어한다.
- 함수형 프로그래밍은 코드의 예측이 가능하고 테스트가 편하다는 장점을 갖는다.
- 그러나 개발자 입장에서 공부하기가 어렵기 때문에 learning curve가 가팔라 많은 이들이 함수형 프로그래밍 자체를 잘 모른다.
  - 요새는 JS와 react도 함수형 프로그래밍에 관심을 가지고 도입하려는 추세
- 클래스 기반 객체지향 언어들은 본래 함수형 프로그래밍 패러다임을 차용하지 않는 편이었고, JS만 함수형을 표방해왔다.
  - 그러나 요즘은 Java나 Python도 함수형을 표방하는 멀티패러다임 언어로 가는 추세이다.
  - 함수형 프로그래밍이 어려운 이유는 언어마다 엄격성이 다르기 때문이다. (e.g. 하스켈은 모든 변수에 재할당을 금지할 정도로 엄격하다)
- 절차지향, 객체지향 언어에서 발생한 어려움에서 시작된 반성으로 함수형 프로그래밍 패러다임이 주목받았다. 절차/객체지향의 가변성은 데이터가 변한다는 본질적 측면에서 버그의 온상이 되었다. 
  - 변수로 할당한 식별자에 누군가 다른 타입의 값을 할당하여 버그가 발생하는 문제 등이 가변성으로 인해 생기는 버그의 대표적인 예.

### 배열의 고차함수 
- 배열의 고차함수는 함수형 프로그래밍 패러다임에 기반하여 만들어진 메서드이다.
- 함수형 프로그래밍은 조건문과 반복문을 안 쓰는게 아니라 함수 내부로 감추는 것이다. 인수를 주면 어떤 결과가 나올지 내부로직을 굳이 알지 못해도 기능하게끔 숨겨둔다. 
  - 매개변수와 리턴 값을 받기 위한 변수 외에는 변수를 사용하지 말고, 변수를 사용할 때는 정말 필요한지 더 고민할 것.

#### `sort()`
- mutator인 동시에 결과값을 반환하는 메서드로, 기본이 오름차순이라서 내림차순을 원하면 `sort()` 후 `reverse()`를 실행한다.
- 정렬에 대한 알고리즘은 6-7가지로 다양한데, `sort()`는 teamsort 방식을 사용하는 것으로 알려져 있지만, 브라우저마다 다르다.
- 유니코드 기준으로 문자열로 치환 후 정렬하기 때문에 숫자의 정렬에서 숫자 크기와 정렬순서가 일치하지 않는다. 이 때 배열의 고차함수를 사용해서 해결할 수 있다.
- 인수로 `(a, b) => a - b`를 넣어주면, 양수일 경우 오름차순, 음수일 경우 내림차순으로 정렬한다. 역순으로 정렬하고자 할 때는 `(a, b) => b - a`를 인수로 넣는다.

#### `forEach()`
- for문은 대표적인 절차지향으로, 다음과 같은 문제를 갖는다.
  - for문을 돌기 위한 변수인 i를 선언해야만 한다. 거기다가 `var` 키워드로 선언하면 전역변수이기 때문에 완전 안티패턴
  - 가독성 안 좋은 안티패턴인 증감식을 써야 한다.
  - 예측을 위해 i값을 계산해야 하며, 인덱스로 배열인스턴스에 `[]`를 통해 접근해야만 한다.
- 각 요소를 제곱한 배열을 만들어내기 위한 `forEach()`를 구현해보자.
```javascript
const numbers = [1, 2, 3, 4];
const pows = [];

numbers.forEach((v, i, arr) => {
  pows.push(v ** 2);
}
```
- 고차함수이기 때문에 인수로 함수(콜백함수)를 넣어주어야만 하며, 고차함수는 콜백함수에게 자동적으로 요소값, 인덱스값, 배열 자신을 인수로 넘겨준다.
- `배열인스턴스.[i]`로 접근하지 않고 바로 값으로 접근해 작업을 수행할 수 있다. 
- 두 번째, 세 번째 인수인 i와 arr을 쓰지 않는 경우 생략할 수 있다. 
- 콜백함수는 `forEach()`에서 요소의 개수만큼 호출되어진다. 호출 주체는 forEach이며 i는 무조건 0부터 하나씩 증가한다. 그러므로 i가 하나씩 증가하지 않는 작업(i가 큰값에서 하나씩 감소하거나, 띄엄띄엄 증가하는 등)을 하려면 처음부터 배열을 가공해서 넣는 수밖에.
- `forEach()` 메서드는 언제나 undefined를 반환한다. for문이기 때문이다.
- 아래와 같이 배열프로토타입의 `forEach()`를 직접 구현할 수 있다.
```javascript
```
 
## 느낀 점
