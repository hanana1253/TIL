# JavaScript

## 인상 깊은 조언
- 개발 중 선후배 갈등의 대부분은 네이밍 지적하다가 생기는 issue이다. 선배는 제대로된 naming 및 convention 따르기를 여러번 반복해서 요구하다보면 화를 내게 된다. 후배는 나중에 고치려고 했다며 선배가 감정적으로 작은 것에 화낸다고 생각한다. 그냥 처음부터 이름을 잘 짓자.

## Todos-List 웹페이지 업그레이드 버전 실습
### HTML 마크업
```html
<!DOCTYPE html>
<html>
  <head>
   <!-- 메타태그와 CSS, JS 링크 태그는 편의상 생략-->
  </head>
  <body>
    <div class="container">
      <h1 class="title">Todos</h1>
      <div class="ver">3.0</div>
      <input class="input-todo" placeholder="What needs to be done?" autofocus />
      <ul class="nav">
        <li id="all" class="active">All</li>
        <li id="active">Active</li>
        <li id="completed">Completed</li>
      </ul>
      <ul class="todos">
        <!-- <li id="1" class="todo-item">
        <input id="ck-1" class="checkbox" type="checkbox">
        <label for="ck-1">HTML</label>
        <i class="remove-todo far fa-times-circle"></i>
      </li> -->
      </ul>
      <footer>
        <div class="complete-all">
          <input class="checkbox" type="checkbox" id="ck-complete-all" />
          <label for="ck-complete-all">Mark all as complete</label>
        </div>
        <div class="clear-completed">
          <button class="btn">Clear completed (<span class="completed-todos">0</span>)</button>
          <strong class="active-todos">0</strong> items left
        </div>
      </footer>
    </div>
  </body>
</html>
```

### `render` 함수

- 우리의 로직은 todos를 재할당하며 작업하여 ul태그 안에 넣어주는 것이니 자바스크립트에서는 전역변수로 todos를 선언하고 빈 배열을 초기화해준다.
  - 재할당할거니까 `const` 말고 `let`으로 해줘야 한다.
- `<ul class="todos">...</ul>`, 즉 todos라는 클래스명을 가진 요소노드객체도 자주 쓸테니까 `$todos`로 할당해준다.
```javascript
let todos = [];
const $todos = document.querySelector('.todos');
```

- 받은 todos 데이터를 HTML 마크업으로 리턴하여 DOM에 넣는 `render` 함수를 다음과 같이 만들 수 있다.
- todos의 각 요소를 객체 디스트럭쳐링 할당으로 풀어 간편하게 HTML 문자열에 들어갈 템플릿 리터럴 속에 넣어준다.
  - 객체 디스트럭쳐링 할당 시 그냥 중괄호(`{}`)로 넣으면 객체인지 함수인지 JS엔진이 혼란을 겪으므로 소괄호를 씌워준다.
  - 데이터가 들어갈 HTML 마크업은 친절하게 마크업 개발자가 주석으로 달아 준것을 활용하면 된다.

```javascript
const render = () => {
  $todos.innerHTML = todos.map(({ id, content, completed }) => {
    return `<li id="${id}" class="todo-item">
        <input id="ck-${id}" class="checkbox" type="checkbox" ${completed? 'checked':''}>
        <label for="ck-${id}">${content}</label>
        <i class="remove-todo far fa-times-circle"></i>
      </li>`
    }).join('');
};
```
- 매번 todos가 어떻게 바뀌는지 console로 확인할 수 있도록 `console.log(todos)`를 찍어주면 좋다.

### `getTodos` 함수
- 아직 서버 관련 코드를 배우지 않았으니 `getTodos` 함수 안에서 todos 데이터를 할당해주고, `render()`로 렌더링한다.
- DOM 콘텐츠가 다 로드되는 이벤트 `DOMContentLoaded`에 동작하는 이벤트핸들러로 등록해준다.
  - `DOMContentLoaded`는 `addEventListener`로만 등록할 수 있다.

```javascript
const getTodos = () => {
  todos = [
  { id: 3, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'HTML', completed: false }
  ];
  render();
};

document.addEventListener('DOMContentLoaded', getTodos);
```

### `addTodo` 함수
- input을 입력하고 엔터를 치면 todos 데이터에 반영하는 함수로 만들어주자. 
- HTML 마크업 상 `input-todo`라는 클래스를 가진 요소노드객체를 취득하여 변수 할당(`$inputTodo`)해준다.
- `$inputTodo`에 `keypress` 이벤트를 등록하되, 엔터키가 아닌 다른 키가 눌리거나, input 입력칸에 아무 것도 입력되지 않은 경우는 무시(`return`)한다.
- 엔터키가 눌렸을 때 해당 내용을 content 인수로 주면, 새 객체로 만들어 todos 데이터에 반영하는 `addTodo` 함수를 호출한다. 
  - `id`: todos id들을 map으로 뽑아내 만든 배열 속 요소들 중 가장 큰 값보다 1 큰 수를 만들어내는 `generateNextId`함수로 집어넣는다.
  - `content`: 엔터키 눌리기 전까지 입력된 input 칸 속 내용, 즉 `$inputTodo.value`
  - `completed`: 기본적으로 false
  - 새 객체는 todos를 스프레드문법으로 푼 배열 속에 첫 요소로 들어간다.
- 엔터키를 누르고 데이터에 반영이 되고나면 input칸이 빈칸으로 초기화되게 한다.
- 엔터키 누르고 나면 또한 focus가 잡히도록 해준다.

```javascript
const $inputTodo = document.querySelector('.input-todo');

const generateNextId = () => {
  return Math.max( ... todos.map( todo => todo.id ), 0) + 1;
};

const addTodo = content => {
  todos = [ { id: generateNextId(), content, completed: false }, ... todos ];
  render();
};

$inputTodo.onkeypress = e => {
  const content = e.target.value;
  if (e.key !== 'Enter' || !content) return;
  $inputTodo.value = '';
  $inputTodo.focus();
  addTodo(content);
};
```
- key 관련 이벤트는 한글을 조합하는 경우 때문에 엔터 두번 눌린 것처럼 되는데, `keypress`를 쓰면 회피할 수 있다. 
  - `keypress`는 곧 deprecated 될거라 쓰지 않는게 좋다고도 하지만, 한글 입력시의 버그를 피하려면 어쩔 수 없고, deprecate 되려면 멀었다는 썰도.
  - key 이벤트 객체가 가진 여러가지 키 정보 (key, keycode, code) 중 무엇을 쓸지 MDN에 검색해보면 key를 쓰라고 되어있다. 

### `toggleTodo` 함수
- 체크박스나 todo 부분을 누르면 바뀌는 것은 우리가 만들어 렌더링한 HTML 부분이므로 직접 이벤트를 등록할 수 없다. 또한 각 요소에 등록하는 것은 번거로운 일이다.
- 상위 요소노드에서 아래로부터 전파된 이벤트를 캐치하도록 이벤트 위임을 통해 todos 데이터의 completed 값을 바꿔보자.
- 아까 `$todos`에 취득해둔 ul에 checkbox input 태그가 있으므로 `onchange`이벤트를 걸어준다.  
- change 이벤트가 발생한 객체의 부모요소의 id를 `toggleTodo` 함수의 인수로 넣어주며, 해당 `toggleTodo` 함수는 map함수를 통해 todos를 순회하면서 인수로 들어온 id를 비교하며 해당 객체의 completed 값을 반대로 바꿔주고 id가 다른 요소들은 그냥 그대로 둔다.  
  - 이 때, 취득한 id는 문자열 타입을 가지므로 넘겨줄 때 숫자로의 타입캐스팅을 해주어야한다. 
```javascript
const toggleTodo = id => {
  todos = todos.map( todo => todo.id === id ? { ... todo, completed: !todo.completed } : todo );
  render();
};

$todos.onchange = e => {
  const id = e.target.parentNode.id;
  toggleTodo(+id);
};
```

### `removeTodo` 함수
```javascript
```

#### 리팩토링
```javascript
```

### 새로운 할일 입력 시 DOM과 데이터에 반영
```html
```
```javascript
```

#### 리팩토링
```javascript
```

## 느낀 점
