# JavaScript

## 인상 깊은 조언
- 개발 중 선후배 갈등의 대부분은 네이밍 지적하다가 생기는 issue이다. 선배는 제대로된 naming 및 convention 따르기를 여러번 반복해서 요구하다보면 화를 내게 된다. 후배는 나중에 고치려고 했다며 선배가 감정적으로 작은 것에 화낸다고 생각한다. 그냥 처음부터 이름을 잘 짓자.

## Todos-List 웹페이지 업그레이드 버전 실습
### HTML 마크업
```html
<!DOCTYPE html>
<html>
  <head>
   <!-- 메타태그와 CSS, JS 링크 태그는 편의상 생략-->
  </head>
  <body>
    <div class="container">
      <h1 class="title">Todos</h1>
      <div class="ver">3.0</div>
      <input class="input-todo" placeholder="What needs to be done?" autofocus />
      <ul class="nav">
        <li id="all" class="active">All</li>
        <li id="active">Active</li>
        <li id="completed">Completed</li>
      </ul>
      <ul class="todos">
        <!-- <li id="1" class="todo-item">
        <input id="ck-1" class="checkbox" type="checkbox">
        <label for="ck-1">HTML</label>
        <i class="remove-todo far fa-times-circle"></i>
      </li> -->
      </ul>
      <footer>
        <div class="complete-all">
          <input class="checkbox" type="checkbox" id="ck-complete-all" />
          <label for="ck-complete-all">Mark all as complete</label>
        </div>
        <div class="clear-completed">
          <button class="btn">Clear completed (<span class="completed-todos">0</span>)</button>
          <strong class="active-todos">0</strong> items left
        </div>
      </footer>
    </div>
  </body>
</html>
```

### `render` 함수

- 우리의 로직은 todos를 재할당하며 작업하여 ul태그 안에 넣어주는 것이니 자바스크립트에서는 전역변수로 todos를 선언하고 빈 배열을 초기화해준다.
  - 재할당할거니까 `const` 말고 `let`으로 해줘야 한다.
- `<ul class="todos">...</ul>`, 즉 todos라는 클래스명을 가진 요소노드객체도 자주 쓸테니까 `$todos`로 할당해준다.
```javascript
let todos = [];
const $todos = document.querySelector('.todos');
```

- 받은 todos 데이터를 HTML 마크업으로 리턴하여 DOM에 넣는 `render` 함수를 다음과 같이 만들 수 있다.
- todos의 각 요소를 객체 디스트럭쳐링 할당으로 풀어 간편하게 HTML 문자열에 들어갈 템플릿 리터럴 속에 넣어준다.
  - 객체 디스트럭쳐링 할당 시 그냥 중괄호(`{}`)로 넣으면 객체인지 함수인지 JS엔진이 혼란을 겪으므로 소괄호를 씌워준다.
  - 데이터가 들어갈 HTML 마크업은 친절하게 마크업 개발자가 주석으로 달아 준것을 활용하면 된다.

```javascript
const render = () => {
  $todos.innerHTML = todos.map(({ id, content, completed }) => {
    return `<li id="${id}" class="todo-item">
        <input id="ck-${id}" class="checkbox" type="checkbox" ${completed? 'checked':''}>
        <label for="ck-${id}">${content}</label>
        <i class="remove-todo far fa-times-circle"></i>
      </li>`
    }).join('');
};
```
- 매번 todos가 어떻게 바뀌는지 console로 확인할 수 있도록 `console.log(todos)`를 찍어주면 좋다.

### `getTodos` 함수
- 아직 서버 관련 코드를 배우지 않았으니 `getTodos` 함수 안에서 todos 데이터를 할당해주고, `render()`로 렌더링한다.
- DOM 콘텐츠가 다 로드되는 이벤트 `DOMContentLoaded`에 동작하는 이벤트핸들러로 등록해준다.
  - `DOMContentLoaded`는 `addEventListener`로만 등록할 수 있다.

```javascript
const getTodos = () => {
  todos = [
  { id: 3, content: 'Javascript', completed: false },
  { id: 2, content: 'CSS', completed: true },
  { id: 1, content: 'HTML', completed: false }
  ];
  render();
};

document.addEventListener('DOMContentLoaded', getTodos);
```

### `addTodo` 함수
- input을 입력하고 엔터를 치면 todos 데이터에 반영하는 함수로 만들어주자. 
- HTML 마크업 상 `input-todo`라는 클래스를 가진 요소노드객체를 취득하여 변수 할당(`$inputTodo`)해준다.
- `$inputTodo`에 `keypress` 이벤트를 등록하되, 엔터키가 아닌 다른 키가 눌리거나, input 입력칸에 아무 것도 입력되지 않은 경우는 무시(`return`)한다.
- 엔터키가 눌렸을 때 해당 내용을 content 인수로 주면, 새 객체로 만들어 todos 데이터에 반영하는 `addTodo` 함수를 호출한다. 
  - `id`: todos id들을 map으로 뽑아내 만든 배열 속 요소들 중 가장 큰 값보다 1 큰 수를 만들어내는 `generateNextId`함수로 집어넣는다.
  - `content`: 엔터키 눌리기 전까지 입력된 input 칸 속 내용, 즉 `$inputTodo.value`
  - `completed`: 기본적으로 false
  - 새 객체는 todos를 스프레드문법으로 푼 배열 속에 첫 요소로 들어간다.
- 엔터키를 누르고 데이터에 반영이 되고나면 input칸이 빈칸으로 초기화되게 한다.
- 엔터키 누르고 나면 또한 focus가 잡히도록 해준다.

```javascript
const $inputTodo = document.querySelector('.input-todo');

const generateNextId = () => {
  return Math.max( ... todos.map( todo => todo.id ), 0) + 1;
};

const addTodo = content => {
  todos = [ { id: generateNextId(), content, completed: false }, ... todos ];
  render();
};

$inputTodo.onkeypress = e => {
  const content = e.target.value;
  if (e.key !== 'Enter' || !content) return;
  $inputTodo.value = '';
  $inputTodo.focus();
  addTodo(content);
};
```
- key 관련 이벤트는 한글을 조합하는 경우 때문에 엔터 두번 눌린 것처럼 되는데, `keypress`를 쓰면 회피할 수 있다. 
  - `keypress`는 곧 deprecated 될거라 쓰지 않는게 좋다고도 하지만, 한글 입력시의 버그를 피하려면 어쩔 수 없고, deprecate 되려면 멀었다는 썰도.
  - key 이벤트 객체가 가진 여러가지 키 정보 (key, keycode, code) 중 무엇을 쓸지 MDN에 검색해보면 key를 쓰라고 되어있다. 

### `toggleTodo` 함수
- 체크박스나 todo 부분은 우리가 만들어 렌더링한 HTML 부분이므로 아직 DOM 트리에 있지 않다. 즉 직접 이벤트를 등록하기가 번거롭다.(등록하려면 `render` 함수 속에 중첩되어야만 한다. 설령 이미 DOM 트리에 있는 것이라 할지라도 각 li 요소에 이벤트를 하나하나 등록하는 것은 번거로운 일이다.
- 그러므로 상위 요소노드에서 아래로부터 전파되어 올라오는 이벤트를 캐치하도록 이벤트 위임을 하여, todos 데이터의 completed 값을 바꿔보자.
- 아까 `$todos`에 취득해둔 ul에 checkbox input 태그가 있으므로 `onchange`이벤트를 걸어준다.  
- change 이벤트가 발생한 객체의 부모요소의 id를 `toggleTodo` 함수의 인수로 넣어주며, 해당 `toggleTodo` 함수는 map함수를 통해 todos를 순회하면서 인수로 들어온 id를 비교하며 해당 객체의 completed 값을 반대로 바꿔주고 id가 다른 요소들은 그냥 그대로 둔다.  
  - 이 때, 취득한 id는 문자열 타입을 가지므로 넘겨줄 때 숫자로의 타입캐스팅을 해주어야한다. 
```javascript
const toggleTodo = id => {
  todos = todos.map( todo => todo.id === id ? { ... todo, completed: !todo.completed } : todo );
  render();
};

$todos.onchange = e => {
  const id = e.target.parentNode.id;
  toggleTodo(+id);
};
```

### `removeTodo` 함수
- 해당 todo를 지우기 위한 버튼도 `toogleTodo`와 비슷하게  우리가 만들어 렌더링하는 HTML요소에 작업해야 하며 여러 목록요소를 한번에 작업하기 때문에 상위 요소인 todos에 이벤트 위임을 한다.
- `toggleTodo`에서는 input type이 checkbox였기 때문에 change와 click을 둘다 이벤트로 캐치할 수 있지만 동일하지 않게 하기 위해 toggle은 change 이벤트에 이벤트핸들러로 걸어두고, delete는 click이벤트에 걸어준다.
- button은 `remove-todo`라는 클래스명을 가진 i 태그이며 클릭한 요소노드객체의 상위 요소 id와 id값이 동일한 요소를 todos 데이터에서 빼준다. 
- `e.target`이 버튼인 경우에만 클릭이벤트를 발생시켜야 하므로, 버튼 외의 다른 부분을 클릭한 경우에는 무시한다. 
  - `e.target`이 버튼인지 비교하기 위해 버튼 요소를 취득하고자 할 때, 버튼은 같은 클래스명(`remove-todo`)을 가진 여러 개의 요소이기 때문에 `querySelector`로 하면 맨 첫 번째만 취득하고, `querySelectorAll`로 하면 여러 요소를 순회를 돌며 상위요소노드의 id값과 같은지 하나하나 확인해야 한다. 그냥 간편하게 클릭한 요소노드객체가 `classList.contains('remove-todo')`인지를 확인하면 된다.
- HTML 요소노드객체에서 취득한 id값은 문자열형식이므로 타입캐스팅 해주는 것을 잊지 말아야 한다.

```javascript
const removeTodo = id => {
  todos = todos.filter( todo => todo.id !== id );
  render();
};

$todos.onclick = e => {
  if (!e.target.classList.contains('remove-todo')) return;
  const id = e.target.parentNode.id;
  removeTodo(+id);
};
```

### `completeAll` 함수
- 이번에는 footer 부분에서 mark all as complete 버튼의 체크 표시 상황에 따라 모든 todo 데이터의 completed 값을 true 또는 false로 만드는 이벤트 핸들러를 만들어 등록해보자.
- HTML 마크업을 보면 type이 checkbox인 input 요소이며, id값을 가지고 있으니 `getElementById`로 취득해와서 change이벤트를 건다.
- checkbox인 input요소는 checked라는 프로퍼티 값을 불리언으로 갖는다. change이벤트가 발생하는 target의 checked 값이나, 그냥 취득한 input 요소노드의 checked 값을 `completedAll` 함수의 인수로 넣어준다.
- `completedAll` 함수는 모든 todos 속 요소의 completed 값을 인수로 받은 불리언 값으로 바꿔주는데 이 때 todos를 돌면서 객체를 스프레드 문법으로 풀어서 작업해주면 된다.

```javascript
const $completeAll = document.getElementById('ck-complete-all');

const completeAll = completed => {
  todos = todos.map( todo => { ... todo, completed }
};

$completeAll.onchange = () => {
  const completed = $completeAll.checked;
  completeAll(completed);
};
```

###
```html
```
```javascript
```

#### 리팩토링
```javascript
```

## 느낀 점
