# Javascript

## 배운 것들

### 내부 슬롯과 내부 메서드
- `[[ Environment ]]`라는 내부 슬롯은 함수객체만 갖는, 상위스코프에 대한 참조다.
  - 함수 객체가 '생성'될 때 함께 생성된다. 즉 상위 스코프에 대한 참조를 갖는 내부슬롯은 렉시컬 스코프인만큼 정의 시점에 생성!
- 내부 슬롯을 숨겨진 프로퍼티라고 하기도 하지만, 이렇게 설명하면 접근자 프로퍼티를 설명하기에 또 어려움을 겪는다.
- 그렇다면 내부슬롯이란 무엇일까? 
  - JS엔진이 코드를 평가하려면 소스코드 텍스트파일을 읽어 객체를 만들어내는 것인데, 이 때 프로퍼티를 객체로 관리한다. 
  - 프로퍼티는 객체이며, 이 객체는 내부 슬롯을 갖는다. 
- 다른 객체지향 언어에서는 private, public, protected 등의 접근제한자가 존재하지만, JS에서는 기본적으로 다 public
  - JS도 private이 생기기는 했다. 그러나 클로저를 적절히 쓰면 정보은닉이 되기 때문에 private이 필요치 않다.
- 모든 객체는 `[[ Prototype ]]` 내부 슬롯을 가지며, 자신의 prototype 객체 참조값을 갖는다. 
  - 이를 확인하려면 `obj.__proto__` 또는 `Object.getPrototypeOf(obj)`로 확인한다.

### 프로퍼티 어트리뷰트
- JS 엔진은 객체 속 프로퍼티를 4개의 내부슬롯을 갖는 객체로 평가/해석한다.
  - `[[ Value ]]`: 프로퍼티 값
  - `[[ Writable ]]`: 갱신 가능 여부
  - `[[ Enumerable ]]`: `for ... in`이나 `Object.keys`로 열거 가능 여부
  - `[[ Configurable ]]`: 어트리뷰트 재정의 가능 여부
- 객체 리터럴로 생성하면 Boolean의 값을 갖는 프로퍼티 어트리뷰트의 기본값은 true
- 내부슬롯을 프로퍼티로 갖는 디스크립터 객체를 통해 프로퍼티 어트리뷰트를 확인할 수 있다.
  - `Object.getPropertyDescriptor(obj, propertykey)`

### `for ... in`문과 `Object.keys`
- `in` 연산자는 객체에 해당 프로퍼티를 참조할 수 있는지 여부를 반환하는데, 상속받은 프로퍼티도 모두 true
- `Object.keys`는 상속받는 애들은 반환하지 않고 자신의 프로퍼티만 반환한다.
- `for ... in`문에서는 상속받는 enumerable한 프로퍼티도 모두 열거한다.
  - 그러나 보통 Object에서 상속받는 메서드 등은 enumerable이 false라서 `for ... in`문에서도 안보이니까 강제로 `__proto__`에 상속 객체를 넣어보자.
```javascript
const obj = {
    a: 1,
    b: 2,
    c: 3,
    __proto__: {
        x: 4
        }
}

for (const elem in obj) {
    console.log(elem);
} // a, b, c, x
// enumerable이기만 하면 상속되는 프로퍼티까지 모두 가져온다.

for (const key of Object.keys(obj)){ 
    // 배열에 담았으니 for ... of로 돌 것
    console.log(key);
} // a, b, c
// 자기 자신의 property만 가져온다.
```
- 상속받은 걸 `for ... in`문에서 빼려면 아래와 같이 로직을 추가해줘야 한다.
  - `hasOwnProperty`는 객체가 해당 프로퍼티를 상속이 아닌 자기 고유의 것으로 갖는지 boolean 값 반환
  - `instance.hasOwnProperty(key)`: 인스턴스로 바로 호출해도 되지만, 해당 instance에 이 메서드가 있는지 보장되지 않으며, 그런 경우 undefined를 호출하니까 에러가 난다.
  - `Object.hasOwnProperty.call(obj, key)`로 하자.
```javascript
for (const key in obj){
    if (obj.hasOwnProperty(key)){
        // Object.hasOwnProperty.call(obj, key)와 동일
        console.log(key)
    }
} // a, b, c
```
- 결론: 귀찮게 `for ... in` 후 validation 하지말고 `Object.keys`로 해라

### 데이터 프로퍼티 vs. 접근자 프로퍼티
- 차이: `[[ Value ]]` 내부슬롯의 유무 (접근자 프로퍼티는 자체적으로 값을 갖지 않기 때문)
- 접근자 프로퍼티는 다른 프로퍼티를 조작, 참조하기 위한 내부 메서드 `[[ Get ]]`, `[[ Set ]]`을 갖는다.
  - 참조연산자로 참조하면 자동으로 호출되며 호출연산자를 굳이 쓰지 않아도 된다. 
  - getter 함수에는 return문이 있어야 한다.
  - getter, setter 함수는 메서드처럼 생겼지만 프로퍼티라고 봐야 한다.
  ```javascript
  const obj = {
      firstName: 'Hangyul',
      lastName: 'Lee',

      get fullName () {
          return `${this.firstName} ${this.lastName}`;
      },

      set fullName(value) {
          [ this.firstName, this.lastName ] = value.split(' ');
      }
  };
  ```
- 접근자 프로퍼티는, 객체 내의 다른 프로퍼티를 참조하겠다는 의지가 들어간 요소이므로 다른 고정값이나 외부 값이 아닌 `this`로 참조할 수 있는 객체 내의 다른 프로퍼티를 넣어야 의미가 있다.
- `__proto__`는 왜 메서드가 아니라 프로퍼티로 만들었을까? 
  - 만약 메서드로 하려면 `getPrototypeOf` 등으로 만들었을 것. 함수가 아닌 것을 이름에서부터 알 수 있다.

### 프로퍼티 정의
- `Object.defineProperty(obj, key, descriptor)` 함수를 통해 만들 수 있다. 
- 왜 동적생성 안하고 (객체 리터럴로 안 만들고) 함수를 사용할까? 
  - 프로퍼티 어트리뷰트를 설정할 일이 있을 때
  - 동적생성하면 자동으로 writable, enumerable, configurable 모두 true

### 객체 변경 방지
- `preventExtensions`, `seal`, `freeze` 등으로 객체의 프로퍼티 추가/삭제/갱신/어트리뷰트 조작 등의 가능여부를 설정할 수 있다.
  - 내부적으로 `defineProperty`를 조작하는 로직이다.
- 객체 동결(freeze)은 해당 객체를 ReadOnly로 만들고, 상수처럼 쓰는 것이다.
  - 여전히 내부의 중첩객체는 mutable하므로, deep freeze하려면 재귀로 해줘야 한다.
  - 모든 depth가 다 동결된 객체를 불변객체라고 한다.
- 리액트에서는 상태의 불변성을 추구한다.
  - 내부적으로 모두 불변객체를 가지진 않지만 불변객체처럼 사용하도록 가이드하고 있다.

### 생성자 함수
- JS에서는 함수가 new 연산자를 붙일 때와 안 붙일 때 다르게 동작한다는 것이 포인트
  - 이 떄문에 OOP에서 나온 개념을 JS에 가져와 어설프게 객체지향을 흉내냈다는 비판을 받기도 한다.
  - ES6 이후 생성자함수로 호출할 수 있는 함수가 구분되었고, Class도 도입되었다. 
  - Class 생성 시 반드시 new를 붙여야 한다. 생성자 함수와 거의 비슷하여 문법적 설탕이라는 이야기도.
    - 그럼 Class는 언제 써야 하는가? Namespace로 사용하는 경우?
    - 그러나 carousel 만드는 경우 등 이벤트 처리 들어가는 순간 this가 꼬이며 문제가 생긴다.
    - 일반 객체를 만들기에는 유용하지만 로직을 가진 객체를 만드려 하면 불편해진다
    - 그래서 리액트에서도 처음에는 class component로 하다가 이제는 function component를 추구
    - function으로 하려면 클로저를 잘 알아야 하고, class로 하려면 this 이슈를 해결해야 한다.
- 객체를 만드는 방법은 대표적으로는 3가지가 있다. (클래스와 `Object.create` 메서드 제외)
  - 객체 리터럴로 만드는 방법, Object 생성자 함수로 만든 후 동적 프로퍼티 추가하는 방법, 그리고 생성자 함수로 만드는 방법
  - 언제 어떤 방식을 사용할까? 
    - 같은 프로퍼티 구조를 갖는 인스턴스를 여러번 만들어야 할 때, 리터럴로 만드려면 동일한 코드를 여러번 써야 하므로 생성자 함수를 만들어 instance를 찍어낸다.
    - JS에서 객체가 아니라 인스턴스라고 말할 때는 생성자 함수나 클래스로 찍어낸 것이라는 의미
- 생성자 함수로 찍어낼 때의 문제: 같은 동작을 하는 메서드가 각 인스턴스의 고유하게 있는 경우 메모리 낭비
  - 인스턴스마다 프로퍼티는 다른 게 일반적이다. 그러나 메서드는 같은 동작을 하는 경우가 많다.
  - 프로토타입을 통해 상속받도록 하여 메모리를 낭비하지 않게 한다.
- 생성자 함수가 호출되면, 런타임 이전에 암묵적으로 빈 객체를 생성하여 this에 바인딩하며 모든 코드를 실행한 후 마지막에 암묵적으로 this를 return한다. 
  - 그러나 생성자 함수에 객체를 반환하는 return문이 있는 경우 해당 객체가 반환되고, 원시값을 반환하는 return문이 있으면 무시된다.
- 생성자 함수를 new 없이 실수로 호출하는 경우
  - this는 전역객체를 가리키기 때문에 전역객체에 해당 함수 안에 정의한 프로퍼티와 메서드가 동적 추가 된다.
  - 이를 방지하고 new와 함께 호출한 것과 동일하게 인스턴스 생성 및 반환하도록 안전장치를 해줄 수 있다.
    - 고전적인 방법은 `instanceOf` 연산자를 통해 this가 생성자 함수의 인스턴스인지 확인
    - 모던 방법은 `new.target`이라는 키워드를 통해, 생성자 함수로써 호출되면 인스턴스를, 아니면 undefined를 반환받아 처리
  - 그러나 String, Number 등의 생성자 함수가 new 없이 호출되는 경우에는 타입변환을 해준다. 
    - 일관적이지 않은 동작... 그래서 이걸 써서 타입변환하는 것은 바람직하지 않다는 의견.

### 일반 함수 vs. 생성자 함수
- 모든 함수객체는 내부 메서드 `[[ Call ]]`을 가지며, 이 내부메서드를 갖는 객체는 호출연산자 `()`로 호출이 가능하다.
- new 연산자와 함께 생성자 함수로써 호출이 가능한 함수객체는 `[[ Construct ]]`라는 내부메서드를 가지며, `new ()`로 호출되면 이 내부 메서드가 호출된다. 
  - `[[ Construct ]]` 내부메서드를 갖는 함수객체를 생성자 함수라고 한다.

### `this` 바인딩
- 타 OOP 언어에서는 객체 만드는 방법이 Class 하나라서 간단, this는 클래스가 만들어내는 인스턴스이다.
- 그러나 JS에서는 객체를 만들어내는 방법이 여러가지이기 때문에 this가 동적으로 결정된다.
1. 일반함수로써 호출하는 경우 this는 전역객체(브라우저에서는 window, node.js에서는 global)
2. 생성자 함수로써 호출하는 경우 this는 생성자 함수가 만들어낼 인스턴스를 가리킨다.
3. 메서드로써 호출하는 경우 this는 객체를 가리킨다.

### 함수와 일급객체
- JS에서 함수가 일급객체라는 것은 함수형 프로그래밍을 가능케한다는 중요한 의미이다.
- 객체랑 동일하므로 프로퍼티의 동적 추가도 가능하며, 변수에 할당하는 등 식별자에 바인딩할 수 있는 '값'이다. 
- 무명의 리터럴로 생성이 가능하며, 이는 런타임에 만들어질 수 있고 함수에 인수로 넘길 수 있음을 의미한다.
  - 다른 언어에서는 함수가 런타임 이전, 컴파일 단계에서 만들어진다.

#### 함수 객체의 프로퍼티
- `arguments`(폐지): 함수의 인수로 들어온 값들을 저장하는 유사배열객체 arguments를 값으로 갖는 프로퍼티인데, 함수 외부에서 굳이 이들을 사용할 일이 없으므로 폐지
- `caller`: 호출한 함수
- `length`: 매개변수 개수
- `name`: 함수의 이름 (모던JS에서는 함수를 가리키는 식별자로 자동 지정된다)
- `__proto__`: `[[ Prototype ]]` 내부슬롯을 참조하는 접근자 프로퍼티
  - 객체는 자신의 상위 객체인 프로토타입을 찾아가기 위한 내부슬롯 `[[ Prototype ]]`을 갖는다.
  - 그러므로 `__proto__`는 함수객체의 프로퍼티인 동시에 함수를 포함한 모든 일반객체도 다 가지고 있다. 
- `prototype`: 함수 객체만 갖는 프로퍼티로, 생성자함수로 호출될 때 만들어낼 인스턴스의 프로토타입 객체
  - 함수 객체 자신이 만들어질 때, 즉 함수 정의가 실행되는 런타임 이전에 만들어진다.
  - new로 호출되어 인스턴스를 만들때 태어날 인스턴스의 프로토타입 객체를 미리 만들어놓는다.
  - prototype 객체도 일반 객체이다. 즉 `[[ Prototype ]]`라는 내부슬롯으로 상위 객체를 참조한다.

#### 함수객체와 프로토타입 정리
- 객체는 태어날 때 `[[ Prototype ]]`이라는 내부슬롯을 가지고 태어난다.
  - 이 내부슬롯은 자신을 생성한 생성자함수의 프로토타입을 정보로 갖는다.
  - 자신을 생성한 생성자함수가 `Circle`인 경우, 이 인스턴스의 `[[ Prototype ]]` 값은 `Circle.prototype`과 동일하다.
- 각 인스턴스가 아니라 프로토타입에 메서드를 정의하려면 `Circle.prototype.getDiameter()`에 할당하여 정의한다.
  - `instance.getDiameter()`로 호출하면 상속되었기 떄문에 상위 프로토타입 객체를 찾아서 해당 메서드를 호출한다.    

## 느낀 점
- 프로토타입 자꾸 헷갈리는데 이번에 제대로 끝내놔야지.