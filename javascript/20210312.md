# JavaScript

## 인상 깊은 조언
- 입사 후 3년까지는 입사 전에 공부했던 걸로 먹고살지만, 그 이후 평생은 입사 1~3년차에 공부했던 걸로 먹고산다. 

## 제어문 (Control Flow Statement)

### 블록문
- 0개 이상의 문으로 이루어진 문들의 집합으로, 하나의 실행의 덩어리
- 중괄호 안에 넣는 게 C family의 특징 
- 문의 종료를 의미하는 자체종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다.

### if문
- 표현식이 아닌 문이므로 값이 와야 하는 맥락에 올 수 없다.

```javascript
if () {
...
} else if () {
...
} else {
...
}
```
- Boolean 타입의 값으로 평가될 수 있는 표현식이 if 뒤의 괄호 안에 온다.
  - true/false가 아닌 다른 값이 오면 내부적 타입변환이 일어난다.  
- true로 평가되는 표현식인 경우 코드블록이 실행되며, 하나의 문만 있을 경우 중괄호 생략하고 if문과 같은 줄에 위치시킬 수 있다.
- `else if () {...}`와 `else {...}`문을 추가해서 쓸 수 있다(optional).

### 반복문

```javascript
for ( a ; b ; c ){
...
}
```
- a에는 반복을 위한 변수 선언과 할당이, b에는 변수가 충족해야 할 조건식이, c에는 변수의 증감문이 온다.
- 비어있는 문으로 구성된 `for (;;){...}`도 문법상 문제가 없는 무한루프.
- for문은 여러가지 논란(for문만을 위한 변수 선언과 할당, 증감을 직접 명령해야 하는 것 등)이 있지만 무엇보다도 실행순서가 좌에서 우로 일관되게 흘러가지 않기 때문에 가독성이 좋지 않다. 쓰지 않는 것이 좋다.
- 언제 for문을 쓰고 언제 while문을 쓸지는 직접 해보면서 익힐 수 있다. 
  - 몇번 반복해야 할지를 우리가 확실히 안다면 for문, 확실히 알 수 없으면 while문

### break문과 continue문
- break문은 코드블록을 탈출한다. 
- continue문은 블록문을 탈출하지 않고 이어나간다.

## 타입 변환
타입 변환에는 명시적 타입변환과 암묵적 타입변환이 있다.
- 타입을 변환하는 이유? 숫자는 산술연산을 위한 리터럴이고 문자열은 사람에게 보여주기 위한 리터럴이기 때문에 목적에 따른 타입으로의 변환이 필요.
- 정적 타입 언어는 명시적 타입변환만 제공한다.
- 동적 타입 언어는 암묵적 타입변화를 해주는데, JS의 경우 그 정도가 심하다.


```javascript
var x = 10;
var str = x + '';
console.log(typeof x, x) 	//number 10
console.log(typeof str, str) 	//string 10
```
- `+`은 두 피연산자 모두 숫자일 경우 산술연산자로 기능하지만, 둘 중 하나라도 문자열일 경우 문자열 연결 연산자가 된다.
- `+`이 문자열 연결 연산자로 기능할 때 한 쪽이 숫자라면 보통 다른 언어는 에러를 발생시키지만 JS는 숫자인 피연산자를 암묵적으로 문자열로 타입변환해준다.
- 암묵적 타입 변환이 일어나도 변수에 할당되어 있는 변수 값의 타입은 변하지 않는다(=부수효과가 발생하지 않는다).
- 벡틱 속에 삽입되어 들어가는 표현식의 평가 결과인 값도 숫자일 때 문자열로 치환된다.
```javascript
console.log(`1 + 1 = ${1+1}`) // 1 + 1 = 2
```

- `-`, `*`, `/` 등 산술연산자나 `>`, `<` 등의 비교연산자는 양쪽 항의 피연산자가 모두 숫자여야 하므로 그렇지 않은 값을 암묵적 타입변환한다. 
  - `null`값을 숫자로 타입변환하면 0이지만, `undefined`를 타입변환하면 `NaN`이 된다는 것에 유의.
- 단항연산자 `+`는 뒤에 오는 값을 숫자로 타입변환한다.

### 명시적 타입변환
1. 문자열로의 명시적 타입변환
  - String 생성자함수에 new를 넣지 않고 만들기: 원래 취지와 맞지 않는 사용이므로 추천하지 않는다.
  - `.toString();` 메서드 사용: 너무 길고 귀찮으니 비추
  - `+ ''`으로 문자열 연결 연산자의 암묵적 타입변환을 이용하는 방법 추천
2. 숫자로의 명시적 타입변환
  - 단항연산자 `+`를 값 앞에 넣기
3. boolean 타입으로의 명시적 타입 변환
  - 논리연산자 `!`를 이용하되 한번만 넣으면 not의 의미이니 `!!` 두번 넣는다.
  - 단축평가: 논리연산자 `||`와 `&&`에서 뒤의 값까지 볼 필요가 없을 때 바로 평가결과를 값으로 생성
    - 타입변환된 boolean 값이 아니라 평가한 표현식을 그대로 리턴하는 것.
    - if문 대신 사용이 가능하며 변수에 할당도 가능하다.
4. null 병합 연산자 라는 게 있다.

## 객체 리터럴

### 객체 지향 톺아보기
- 객체 지향이란, 프로그램 속에서 객체들이 서로 interaction하며 우리가 필요한 바를 수행하게 하는 것
  - 객체를 만드는 템플릿이 클래스이며, 클래스로 뽑아내 메모리에 들어있는 실체를 instance라고 한다.
  - 객체 지향 외에도 절차 지향 등 여러가지 방법론이 존재
- 프로젝트에서의 객체 지향 방법은 클래스를 다 만들어두고 application이 이런 모습일거라는 것을 instance를 통해 쫙 보여주는 것으로, 대규모 프로젝트에 유용하지만 클래스의 설계대로만 instance가 만들어질 수 있는 상황에서 현실세계 속 요청되는 수많은 변경사항에 대처하기가 어렵다. 
- 클래스 기반 객체 지향 언어(C++, Java, C#)들은 클래스가 있어야 객체를 생성할 수 있는 반면, 프로토타입 기반 객체지향 언어인 JS는 클래스 없이도 바로 리터럴로 객체를 생성할 수 있다. 이것은 클래스 기반 객체지향 프로그래밍보다 훨씬 좋다.
- 문자열과 더불어 객체리터럴은 JS의 엄청난 장점이다. 
  - JS는 또한 멀티패러다임 언어라서 일부분은 객체지향, 일부는 절차지향, 전체적으로는 선언형이면서 로직은 함수형으로 만들 수도 있다는 장점이 있다(c.f. Java나 C#은 only 객체지향).

### 객체(Object)
- 개발자가 subject로서 만든 프로그램이라는 세상 속의 요소가 바로 객체.
- 객체의 속성(property)을 정의하는 것이 추상화이며, 필요하고 관심있는 속성만으로 객체를 정의할 수 있다.

#### Property
- property는 property key와 property 값으로 나뉘는데, 중괄호 안에 0개 이상의 프로퍼티가 올 수 있다.
- 서로 관련 있는 것들을 하나로 묶어 값으로 사용할 수 있기 때문에 객체를 만든다.
- property 접근: `object.property_key`처럼 마침표 연산자를 사용한 표현식은 property값으로 평가된다(=property 값을 참조한다).
- property 값에는 JS가 가진 모든 값이 올 수 있다. 객체도 올 수가 있지만 너무 많은 중첩은 지양하는 게 좋다.
- instance가 만들어진 이후에도 property는 변경 또는 동적 추가가 가능하다.
  - 이미 존재하는 property의 key와 값에 대해 새로 값을 할당함으로써 property 값을 바꿀 수 있는데, 이것은 재할당이 아니라 갱신한다고 표현한다.
  - 존재하지 않는 property의 key에 값을 할당하면 새로 property가 추가된다. 
- 선언한 적 없는 변수를 불렀을 때 reference error가 나는 것과 달리, 존재하지 않는 property value를 `console.log()`로 부르면 undefined가 나온다. 이처럼 변수와 property는 차원적으로 다르다.
- property key에는 빈 문자열을 비롯한 모든 문자열과 symbol 값이 올 수 있다.
  - 숫자는 예외적으로 따옴표 없이 property key가 될 수 있다. index처럼 기능하는 유사배열객체가 된다.
  - property key는 식별자와 같은 의미로 기능하지만 엄밀히 말하면 문법적으론 식별자가 아니기 때문에 식별자 네이밍을 꼭 따르지 않아도 에러가 발생하진 않는다. 
  - 그러나 식별자 네이밍 규칙을 따르지 않는 경우 번거롭게 꼭 따옴표를 붙여주어야 하고, 값에 접근하여 호출할 때 마침표연산자가 아닌 대괄호로만 접근이 가능하므로 웬만해선 식별자 네이밍 규칙을 따르자.
- property 삭제는 `delete`로 가능하지만 굳이 삭제까지 하지 말고 그냥 안쓰면 된다.
- property 축약 표현: 변수(즉 변수 값)가 property 값으로 오면서 변수 이름이 property key와 같으면 그냥 변수 이름만 나열한 중괄호로 객체를 생성할 수 있다. 

#### Method
- JS에서는 함수가 일급객체이기 때문에 값으로 올 수가 있는데, 함수를 값으로 가진 property는 메서드라고 부른다. 객체의 함수를 호출할 때는 마침표연산자를 사용한다.
  - method는 같은 객체 내의 property를 조작하는 행위를 하는 것이 일반적이기 때문에, 같은 객체 내의 property에 접근하기 위해 this라는 키워드를 써준다.

## 데이터 타입
프로그래밍은 메모리를 덜 쓰고 빨리 처리하는 것을 주안점으로 두어 만드는데, 이를 위해 원시값은 변경 불가능하여 read-only이게끔 만든다. 
반면 객체는 변경 가능한 값으로, 어떻게 작동하는지 알아보자.

- 객체는 변수처럼 원시값을 가리키는 것이 아니라 객체의 실체가 들어있는 메모리 주소 값, 즉 참조값을 가진 메모리 공간을 가리킨다. 참조값은 순수한 숫자(원시값)이다.
- 객체 property key에 값을 새로 할당(갱신)하면 참조값인 메모리 주소에는 변화가 없고 객체의 실체가 들어있는 메모리 공간의 내용이 바뀐다. 

### 값에 의한 전달 (pass by value)
```javascript
var score = 80;
var copy = score;
```
- 위와 같이 copy라는 변수에 식별자 표현식이 할당될 경우 식별자 score이 가지고 있는 80이라는 값은 새로 복사되어 생기고 그 주소를 copy에게 준다. 그러므로 score와 copy가 가리키는 값은 서로 독립적이며 영향을 주지 않는다.


### 참조에 의한 전달 (pass by reference)
- 객체를 또다른 변수에 할당할 경우 객체가 가리키는 참조값을 그대로 주기 때문에 객체를 공유하며, 서로 영향을 주고받는다.
- 참조값이 가리키는 실체가 변경(동적 프로퍼티 추가 등)되었을 때 해당 참조값을 가리키고 있는 여러 식별자 또한 변경된 객체를 가지게 된다. 
- 객체는 차지하는 메모리 공간이 클 것을 대비하여 heap 영역에 저장된다. (c.f. 원시값처럼 메모리사이즈가 절대 변경되지 않을 값들은 stack이라는 곳에 다닥다닥 저장)
- 왜 이런 시스템인가? 객체는 매번 copy하기엔 너무 용량이 클 수가 있다. 원시값은 크지 않으니 괜찮지만 메모리가 작았던 옛날 객체를 copy값으로 전달하는 것은 좋은 선택이 아니었다.
- 그러나 여러 식별자가 한 객체 값을 가리킬 경우 굉장한 복잡도가 발생한다는 부작용이 있다.
- 모던한 개발에서는 이런 객체의 특성이 짐이기 때문에, 객체를 원시값처럼 쓰려는 움직임이 있다. 예컨대 객체도 copy 후에 주거나 객체를 변경할 때 copy하고 고치는 등의 해결책.

## 느낀 점
- 모든 방법론이나 프로그래밍 언어의 특성에는 다 이유와 장단이 있다는 것을, 그리고 모든 문제를 해결하는 은탄환은 없다는 것을 배웠다. 
- 파이썬에서 다소 모호했던 것들이 자바스크립트 배우면서 많이 해결되고 있어서 재미있다.
