# Javascript

## 배운 것들
### 메모리 셀 하나가 1 Byte인 이유
- 최초 컴퓨터의 목적은 군사적인 목적, 암호해독/계산을 위한 단일목적을 가짐
- 범용적인 목적을 가지기 시작하며 다양한 데이터를 다뤄야 하는데, 통일되지 않은 단위로 데이터를 관리하면 어려우니 영문 대소문자와 특수기호 등을 포함한 아스키코드를 기준으로 8 bit를 1 Byte로 데이터 저장의 최소 단위를 삼고, 숫자를 통해 문자를 표현하게끔 했다.
- 이후 다른 언어까지 다룰 수 있도록 유니코드로 인코딩 방식이 바뀌었다.

### 인터프리터 언어로서의 자바스크립트
- 인터프리터 언어에서도 바이트코드를 기계어로 컴파일하는 과정이 있다.
  - 함수 body 등 자주 재사용하는 건 기계어로 만들어두고 사용한다.
- 모던한 인터프리터 언어는 컴파일도 일부 수행하므로 컴파일 기능을 내장한다고 보면 된다.
- 그러나 실행파일을 생성해내지 않는다는 점은 변함이 없다.
- 더더군다나 자바스크립트는 전문개발자를 위해 만들어진 언어가 아니기 때문에 컴파일을 따로 하지 않도록 만들어졌다.
- 인터프리트 과정도 두 단계를 거친다. 소스코드 평가 과정과 실행(런타임) 과정이다. 
  - 변수 선언문은 인터프리트 중 런타임 전 평가 단계에서 실행된다.

### Desktop app vs. Web app
- 웹브라우저는 가상머신이라 생각하면 편하다. OS 위에서 돌아가는 app이며 렌더링엔진과 JS 엔진이 있다.
- 브라우저가 OS가 사용할 수 있는 모든 영역의 메모리를 다 사용하는지 아니면 일정 영역만 할당받아 사용하는지는 케바케
- 데스크탑 앱이라고 해서 모든 자원을 다 제공받지는 않으므로 큰 차이는 없겠지만 그래도 웹이 조금이나마 더 제약이 있을 것

### 완료값 `undefined`와 `console.log`
- ECMAScript에서는 표현식이 아닌 문을 실행한 결과의 완료값을 구현하도록 요구한다. 
  - 그래서 콘솔에서 표현식이 아닌 문을 실행하면 undefined가 완료값으로 나온다.
  - 그러나 Node.js에서는 완료값을 보여주는 기능을 제공하지는 않는다.
- `console.log`는 ECMAScript에 올라가있지 않다. 
  - 코어 외에 비표준으로 제공되는 부가기능이라 브라우저랑 Node.js의 출력 내용이 다를 수 있다.
  - Node.js보다 브라우저가 보통 더 많은 내용을 보여준다.

### 데이터 타입
- 원래 다른 언어에서는 정수는 4 Byte로 저장하지만 JS에서는 정수도 사실 실수로 관리, 8 Byte를 사용하는 메모리 낭비를 감수.
- JS에서 문자열은 하나의 데이터타입으로 제공된다. (c.f. C에서는 문자열을 배열로, Java에서는 객체로 관리)
  - 원시타입이지만 `.length` 등으로 참조연산자를 동작시키는 순간 JS는 앞의 값을 객체로 만들어버린다(래퍼객체).
- 문자열을 표현할 때 홀따옴표, 쌍따옴표, 벡틱을 쓸 수 있다.
  - 따옴표는 컨벤션에 맞게 사용하고, 템플릿 리터럴로 표현식을 삽입할 게 아니라면 벡틱은 사용하지 말것 
  - 벡틱은 개행이나 표현식 삽입 등의 기능이 구현되어있으므로 미미한 차이라 할지라도 성능 이슈가 있다.
  - 따옴표에서는 개행하는 순간 문이 종료된 것으로 판단. 

### 동적 타이핑
- 같은 변수에 타입이 다른 값을 재할당 할 수 있다. 
  - 변수에 값을 할당할 떄 해당 변수가 갖는 값의 데이터 타입이 동적으로 결정된다.
  - 편리하고 유연하지만, 체계가 없고 안정적이지 않다.
  - c.f. 정적 타입언어는 변수에 할당될 수 있는 데이터타입이 선언시 결정되며 바뀌지 않는다.
- Typescript를 통해 동적타이핑으로 인한 불안정성을 줄일 수 있다.

### 연산자
- 부수효과가 있는 연산자
  - 증가/감소 연산자(`++`, `--`)는 쓰지 않는 것이 좋다. 위치에 따라 동작이 다르고, 암묵적 재할당이 일어나기 때문
  - 할당연산자: 증가/감소 연산자는 할당연산자로 바꿔서 쓸 것 (`a++` (X), `a += 1` (O))
  - delete 연산자: 프로퍼티를 삭제할 때 쓰는데, 삭제할 프로퍼티는 애초에 안만드는게 좋으니 `delete` 연산자도 쓰지마라.

### 일치비교연산자
- `NaN === NaN`을 false로 평가한다. 
  - `Number.isNaN(NaN)`으로 확인해야 true로 평가된다.
  - 또는 `Object.is(NaN, NaN)`으로 비교해야.
- 0과 -0도 일치비교연산자는 true로 평가하게 만드므로 `Object.is`로 비교해야 한다.

### 같은 동작이라면 연산자가 함수호출보다 더 바람직
- 함수 호출하려면 어떤 인수를 몇개나, 어떤 순서로 넣어야 하는지 알아야 하고, 실수가 일어난다.
- `a.toString()`보다 `a + ''`이 낫다.

## 느낀 점
- 코드에도 좋은 것과 나쁜 것이 있고, 장단점이 있으며 거기엔 이유가 다 있다.
