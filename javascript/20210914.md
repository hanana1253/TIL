# Javascript

## 배운 것들

### Miscellany
```javascript
function add ( x, ... y ) { ... }; // x는 무조건 써야하고 y부터는 선택
```
- 위와 같이 함수의 원형에 명시되는 매개변수 리스트는 이런식으로 입출력을 하라고 표기하는 함수 시그니처이다.
  - x는 꼭 넣고, y는 선택적으로 할 것
- 함수를 실제로 정의할 때 위와 같이 쓰면 y라는 변수에 x 이후의 인수를 담는 나머지 매개변수(rest parameter)이다. 

### Jest와 모듈
- Jest 패키지를 이용해서 js 파일을 모듈로 불러와 테스트하는 환경을 만들어보자.
- ES6 모듈이 생기기 전에는, `<script src="자바스크립트 파일">`을 따로 따로 불러와 로드했다. 
  - 로드하면 바로 실행되어버리며, 파일이 구분되어 있어도 하나의 전역을 공유했다.
  - 전역변수를 만들었을 때 중복선언이 되며, var 키워드에서는 중복 허용 때문에 재할당이 일어나 카오스
- 모듈은 파일을 구분하였을 때 각 파일이 스코프를 갖게 되어, 파일의 전역에 선언한 것도 스코프로 구분된 지역변수가 된다.
  - 다른 파일에 있는 변수를 갖다 쓰고 싶을 때를 위해 export, import를 제공한다.
- 본 파일에서 테스트 안하고 왜 굳이 test 파일을 만들어 import할까? 
  - 배포할 때 테스트 코드까지 다 넣어서 배포하면 안되니까.
- ES6 모듈의 export, import 키워드는 아직 브라우저에 적용되지 않는 경우도 있어서 babel로 트랜스파일링 거쳐야 한다.
- [패키지 설치 방법](https://poiemaweb.com/jest-esm)을 따라 설치하고, babel.config.json와 jest.config.json에 환경설정을 마친 후 테스트하자.
- Jest 공식 도큐먼트를 통해 테스트 방법을 확인할 것

### 스코프
- 다른 언어는 main 함수 밖에서 선언해야 전역변수인 반면 JS는 그냥 top level에 선언하는 모든 변수나 함수가 전역 스코프를 갖는다.
- 스코프 체인으로 상위스코프를 찾아가다가 끝까지 가면 전역객체로 가서 찾는다.
  - 전역에 var 키워드로 선언한 것은 window 객체의 프로퍼티가, 함수선언문으로 선언한 것은 window 객체의 메서드가 된다.
- 스코프는 식별자의 유효범위이며, 그 범위는 생애주기를 갖기에 식별자를 데리고 소멸한다.
- 호이스팅은 스코프의 최상단으로 끌어올려진 것처럼 동작하는 행위를 말하며, 선언문이 런타임 전에 먼저 실행되기 때문에 일어나는 상황이다.
- 스코프라는 자료구조(lexical environment)가 실제로 존재한다고 생각하면 된다.
- 식별자는 자신이 선언된 위치에 따라 유효범위가 결정
- var 키워드는 함수레벨스코프로, 블록문이라 할지라도 함수몸체가 아니면 유효범위가 블록문이 아니다. 
- let/const 키워드는 블록레벨스코프로, if문, for문 등의 블록문을 유효한 스코프로 인정한다.

### 함수 선언과 호출 시 코드 실행 순서
- 코드는 text일 뿐이다. JS 엔진은 이 text에 있는 정보를 취합하여 평가해서 AST라는 자료구조를 만든다.
- var 키워드로 선언된 변수를 scope에 등록하고, 함수선언문을 만나면 함수 내부코드는 호출되기 전까지는 text로 갖고 있다.
  - 함수선언문은 런타임 이전에 평가되어 함수 객체를 생성, 할당하지만 껍데기만 생성한다.
  - 함수 객체가 있는 식별자가 호출되면 해당 함수 몸체로 들어가 함수 코드 런타임 전에 텍스트로 되어있는 함수객체의 코드를 평가한다.
```javascript
var x = 'global x';
var y = 'global y';

function outer() {
    var z = 'outer local z';
    console.log(x); // 'global x'
    console.log(y); // 'global y'
    console.log(z); // 'outer local z'

    function inner() {
        var x = 'inner local x';

        console.log(x); // 'inner local x'
        console.log(y); // 'global y'
        console.log(z); // 'outer local z'
    }

    inner();
}

outer();
console.log(x); // 'global x'
console.log(z); // ReferenceError
```
- 변수나 함수가 참조/호출될 때, 가장 가까운 내부 스코프에서부터 식별자를 찾는다. 
  - 찾지 못하는 경우 스코프 체인을 따라 상위 스코프로 올라가 찾는다.
  - 식별자를 찾은 경우에는 탐색을 멈추는데 이를 identifier resolution이라 한다.
  - 스코프체인은 단방향 연결 리스트이다. 

### 렉시컬 스코프
- 상위 스코프를 어떻게 결정할지에 대한 메커니즘 중 하나로, 함수가 어디에 정의되어있는지에 따라 상위스코프를 결정하는 경우를 렉시컬 스코프라고 한다.
  - c.f. 함수가 어디에서 호출되었는지에 따라 결정할 때에는 동적스코프라고 하며, 이는 호출 위치가 어디가 될지 모르므로 혼란을 유발할 수 있다. 
  - 함수의 선언위치는 바뀌지 않으므로 안전하다. 대부분의 프로그래밍언어는 렉시컬 스코프를 메커니즘으로 취한다.
- 일반 객체와 함수 객체의 차이는 호출가능여부!
  - 함수 객체는 `[[ Call ]]`이라는 내부슬롯을 갖는다. `console.dir`로 확인할 수 있다.
  - 함수 객체만이 갖는 고유한 프로퍼티 (내부슬롯) 중 `[[ Environment ]]`는 상위 스코프의 참조값을 갖는다. 
    - 이를 통해 함수가 어디서 호출되든지 상관없이 상위 스코프는 고정되어있는 것

### 전역변수와 모듈
- 전역변수는 쓰면 안되기도 하지만 모듈이 들어선 모던 JS에서는 쓸래야 쓸 수도 없다.
- 파일을 쪼개고 나서 export를 쓰면 모듈이 되는 것이고 안 쓰면 그냥 파일인 것
  - 모듈파일에는 top level에 변수를 선언해도 모듈 스코프 안의 지역변수가 된다.
- 전역변수를 쓰면 안되는 이유: 전역을 비롯한 하위 블록 어디에서나 참조, 변경, 할당이 가능하기 때문에 코드 품질이 안좋아진다.
- 전역변수 사용 억제: 전통적으로는 즉시실행함수를 통해 억제하였지만, 이제는 모듈로!

#### 변수의 생명주기
- 전역변수의 생명주기는 어플리케이션의 생명주기와 같다. 켜져있는 동안 계속 메모리를 점유
  - desktop app에서는 앱 종료 시, web app에서는 브라우저 탭을 닫거나 다른 url로 이동 시 소멸된다.
- 함수 안에 선언된 지역변수는 함수 호출로 런타임 전에 선언되며 생성되고 함수의 종료와 함께 소멸한다.
  - 함수코드가 종료되면 stack에 있던 해당 함수의 실행 컨텍스트가 pop되면서 실행컨텍스트가 가리키던 lexical environment가 어떤 식별자도 참조하고 있지 않기 때문에 reference count가 0이 되면서 garbage collector로 인해 메모리 해제 대상이 된다.
  - 클로저를 활용하는 상황에서는 여전히 lexical environment를 `[[ Environment ]]`가 참조하고 있으므로 변수가 살아있다.

#### let과 const
- var로 선언한 변수는 window 객체의 프로퍼티가 되지만 let, const로 선언한 변수는 보이지 않는 개념적인 블록 안에 존재
- const는 선언과 동시에 초기화하지 않으면 에러가 난다. 재할당을 못하기 때문에!
- 상수도 변수이며, 재할당이 금지된 변수일 뿐이다. constant variable는 신뢰성과 동일성을 보장한다.
- 결론: 무조건 const로 변수를 선언하고 나중에 재할당이 불가피하다고 판단되는 경우에만 let으로 바꾸자.

## 느낀 점
- 하나하나는 기억이 나는데 수업만 들으면 왜 이렇게 처음 배우는 것 같지