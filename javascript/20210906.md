# Javascript

## 인상 깊은 조언
- 좋은 개발자란, 경력의 경우 팀을 잘 리딩하여 팀원들 수준의 상향평준화를 이루는 리더, 신입의 경우 성장가능성이 높은 사람.
  - 첫 3년의 성장곡선의 기울기가 나머지 인생에서의 성장곡선과 일치한다.
- 피드백을 받았을 때 겸손하게 내가 왜 그런 지적을 받았는지 받아들이고 성장의 밑거름으로 삼을 것

## 배운 것들

### Javascript의 특징
#### 탄생 배경과 성장
- 프로그래밍 언어의 대부분은 범용적인 App을 만들 목적으로 태어났지만, JS는 그렇지 않다.
  - 넷스케이프 네비게이터 2라는 웹브라우저에서 보조기능을 처리하기 위해 'Mocha'라는 이름으로 태어났다.
  - 웹 상에서 간단한 프로그래밍이 동작하게 하기 위해 만들어진 경량화된 프로그래밍 언어
- JS를 사용하는 대상은 전문적인 프로그래머가 아니라 웹사이트를 만드는 사람들
  - 웬만한 경우 에러 없이 실행되도록 암묵적 처리를 해준다.
- 구글에서 Ajax(Asynchronous Javascript And XML)을 선보이며 JS의 활용도와 입지가 상승
  - 서버는 file로 관리하기 때문에 데이터를 가져오는 게 느리다. 바쁘면 3초도 걸릴 수 있다.
  - 비동기란 이렇게 서버에서 데이터를 가져오는 동안 view를 보여줄 수 있도록 다른 것을 해놓는 것. 
  - JS가 싱글스레드 엔진이기 때문에 가능하다. (이벤트 루프와 테스크 큐)
  
#### Desktop App vs. Web App
- Desktop(Standalone) App은 보안에 강하다는 장점이 있지만, 설치와 업데이트를 사용자가 해주어야 한다. 
  - 옛날처럼 CD로 설치하고 업데이트 해줘야하는 불편함
- Web app은 설치나 업데이트 과정이 별도로 필요하지 않다. 불법복제를 할 수도 없다.
  - 그러나 웹 환경에서 app을 구동하려면 어마어마하게 엔진이 빨라야 한다. 
  - 구글이 Ajax로 동작하는 구글맵스를 선보이며 획기적 성능의 js엔진인 크롬의 V8을 함께 공개한것도 이 이유 때문이다.

#### Node.js
- 원래 V8 엔진은 오픈소스인 크로미움을 탑재한 것인데, 이를 브라우저에서 떼어내 브라우저 밖의 환경에서도 JS를 동작시킬 수 있다.
- 서버에서도, 즉 백엔드에서도 사용할 수 있는 범용적인 프로그래밍 언어로 거듭났다.
- node.js 이전에는 C#, Java, Python 등의 백엔드 언어를 알고있더라도 브라우저에서 동작하는 언어로는 js를 무조건 배워야 했다.
  - 지금은 JS를 알고있다면 백엔드를 JS로 작업할 수 있으니 다른 언어를 배우는 추가적인 수고가 들지 않는다.

#### SPA(Single Page Application)
- SSR(Server Side Rendering, 서버에서 html을 만들어 client에 보내주는 것)을 더 하려는 추세
  - 대표적인 SPA 라이브러리인 리액트에서도 Next.js 프레임워크를 통해 SSR을 구현하려고 한다.
- CBD(Component Based Development): 뷰를 만들기 위해 필요한 html/css/js를 하나로 뭉쳐둔 부품을 만든다.
  - 뷰를 재사용하기 위한 목적

#### 동적 타입 언어
- JS는 변수선언시 따로 타입을 지정하지 않고 할당되는 시점에 해당 변수가 갖는 값의 데이터타입이 정해진다.
- Type Casting에도 3가지 방법이 있다.
  - c.f. number에 할당된 숫자타입의 값을 문자열로 바꿀 때 `number.toString()`, `String(number)`, `number + ''`
  - number은 객체나 배열이 아닌데 `.`으로 접근해도 되는지도 논란의 여지
  - 이 세가지 방법 각각의 장단점을 생각하며 사용하자.

#### ECMAScript
- 브라우저마다 파편화되지 않도록 넷스케이프가 ECMA International에 의뢰(IE의 JScript의 독주를 막기 위해...)
  - 표준 사양을 지칭할 때 ES로 부르고, Web API등을 포함한 일상적인 호칭은 JS
- 2015년 발표된 ES6를 기점으로 많은 변화가 있었다.
  - 암묵적으로 처리해주던 것들에 이제는 런타임 이전에 소스코드를 평가하여 에러를 적극적으로 내기 시작
  - 사용자가 실제로 사용할 때 에러가 나지 않으려면 미리 에러를 내줘야 한다.
- 현재는 2021년 ES12가 발표되었으며 매년 버전업하여 6-7월에 발표
- 발표되기 1년도 더 전에 대략적인 명세(ES Next)가 나오며, 브라우저의 JS엔진이 아직 표준화되기 전부터 미리 대응하기도. 

#### 선언형 추구
- 조건문, 반복문 등의 제어문은 과연 좋은 것일까?
- 알고리즘 풀 때야 잘 쓰지만 가독성 측면에서 if문과 for문은 '악'이다.
  - 이를 절차형(Procedural), 명령형(Imperative) 프로그래밍이라고 부른다.
  - 위에서 아래로 한 줄씩 순서대로 읽을 수 있는 코드가 제일 좋은 코드이다.
- 선언형(Declarative) 프로그래밍을 추구하자 
  - 선언형의 대표주자가 리액트. 
  - HTML 또한 (프로그래밍 언어인지에 대해서는 논란이 많지만) 선언형 언어라고 할 수 있다.

### 변수
- 하나의 값을 저장하기 위해 확보한 메모리 공간 자체

#### 메모리
- 값들을 저장하기 위한 물리적 공간
- 메모리셀 한 칸은 1Byte(=8bit): 왜일까? 조사과제
- CPU 안에도 메모리가 있다. (캐시메모리, 레지스터라고 불린다.) 
  - 연산을 위해 메모리에서 꺼내와 고속으로 저장하는 비싼 메모리

#### 변수 선언
- JS 엔진에게 변수가 생성되었음을 알린다. 
  - 메모리 공간을 확보하기 위해
- 정적타입 언어는 변수가 선언될 때 몇 바이트를 사용할지 알 수 있으나 동적 타입 언어인 JS는 undefined라는 값을 저장한 메모리 주소를 매핑하고 나중에 할당시점에 타입에 따라 확보된 메모리 주소를 매핑한다.
- 변수 이름은, 메묄 공간 안에 있는 주소를 식별해내기 위한 식별자이다. 
  - 스코프 안에서 unique(유일)해야 한다.
- 변수 선언시 JS 엔진이 비워진 메모리공간이 아니라 undefined로 암묵적 초기화된 메모리 주소를 매핑하며, 메모리 주소는 OS가 배정.
  - 이미 그 자리에 있는 쓰레기 값을 참조하지 못하게 하기 위해.
  - c.f. C언어는 메모리 할당과 해제를 개발자가 명시적으로 하지만, JS는 어떤 식별자도 가리키지 않는 메모리 공간은 garbage collector에 의해 해제된다. 해제 시점은 알 수 없다.

## 조사할 것들
- 인터프리터 언어와 컴파일러 언어의 차이
- 메모리셀 최소 단위가 1Byte인 이유(아스키코드와 유니코드)
- garbage collector

## 느낀 점
- 자바스크립트는 여전히 재미있다. 
- 6개월 전 배웠을 때는 와닿지 않던 것들이 조금 더 이해되어 다행이다.