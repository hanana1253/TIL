# Chapter 3. Functions and Records

## Simple Types
- 세 가지 원시타입(`Number`, `String`, `Boolean`)은 `Prim` 모듈 안에 정의되어있으며 모든 모듈에서 암묵적으로 import된다.
  - 소수점 없는 `Number`는 `Int`, 홑따옴표로 구분된 한 개의 문자는 `Char`
- `Array`: 하나의 타입으로만 원소를 가질 수 있다.
- `Record`: JS의 객체에 상응, 문법은 같다. 마침표 연산자로 필드 참조가 가능하다.
- `Function`: JS의 함수에 상응

## Quantified Types
- `forall`: universally quantified type으로 모든 타입이 각 인자로 올 수 있다.
- 예제 이해 못함
```
> :type flip
forall a b c. (a -> b -> c) -> b -> a -> c

> flip (\n s -> show n <> s) "Ten" 10

"10Ten"
```

## Notes On Indentation
- Indentation DOES matter.
- 같은 코드블록이면 같은 indent

## Defining Our Types
- 레코드 타입 정의에서 타입 중첩도 가능하다.

## Type Constructors and Kinds
- `Type constructor`는 타입 a를 인자로 받아 새로운 타입 (`List a`와 같은) 생성
- 혼자서는 타입으로 올 수 없으며, 일반 타입처럼 작성되면 `Kind Error` 발생
- type이 value를 구분짓듯 kind는 type을 구분짓는다
- `Type`이라는 kind는 값을 갖는 모든 타입을 통칭한다.

## AddressBook 만들기
- AddressBook은 immutable data structure로 유지한다.
- mutation은 부수효과로, 동작을 효과적으로 추론하기 어렵게 한다.
- 코드 이해 실패!
```
insertEntry entry book = Cons entry book
```
- 함수는 한 개의 인자만 받는다. 
```
// 위의 insertEntry 함수 시그니처
Entry -> (AddressBook -> AddressBook)
```
- `insertEntry`는 함수를 반환하는 함수로, `Entry`라는 하나의 인자를 받아, `AddressBook`을 받아 `AddressBook`을 반환하는 함수를 리턴한다.
  - 첫 인자만 전달하며 호출하면 함수를 반환하게 하여 일부만 적용할 수 있다. 
  - 인자가 여러 개인 경우 왼쪽부터 평가되어 반환한 함수를 그 다음 인자를 전달받아 호출하는 식으로 실행
- `->` 연산자는 함수를 만드는 `Type Constructor`
- `eta conversion`: 이해 실패



