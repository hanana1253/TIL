# Chapter 8. The Effect Monad

## Chapter goals & Project Setup
- 더 expressive한 방식으로 side effect를 다루는 추상화 : monads
- do notation과의 관계

## Monads and Do Notation
- In general, a monad for some type constructor `m` provides a way to use do notation with values of type `m a`
- Since pure is defined as Just for the Maybe applicative functor, it would be equally valid to change the last line to Just city.

## The Monad Type Class
- Bind on arrays
```
instance bindArray :: Bind Array where
  bind xs f = concatMap f xs
```
- Bind for the Maybe type constructor
```
instance bindMaybe :: Bind Maybe where
  bind Nothing  _ = Nothing
  bind (Just a) f = f a
```
- writing binds explicitly using `>>=` can often lead to opportunities to write code in point-free form 

## Monad Laws
- what we can expect from sensible implementations of the Monad type class (do notation에서)
  - right-identity law : 마지막 표현식 pure 에 대한 호출 제거 가능
  - left-identity law : 첫 표현식 pure 호출 제거 가능 
  - associativity law: 중첩된 do notation 을 간단히 flatten 가능

## Folding With Monads
- `foldM` generalizes `foldl` to a monadic context
```
foldM :: forall m a b. Monad m => (a -> b -> m a) -> a -> List b -> m a
foldl :: forall   a b.            (a -> b ->   a) -> a -> List b ->   a
```
- m 이 `Maybe` : every step returns an optional result
- m 이 `Array` : every step of the fold would be allowed to return zero or more results, and the fold would proceed to the next step independently for each result
- To write foldM, we can simply break the input list into cases.
  - if list is empty 
  ```
  foldM _ a Nil = pure a
  ```
  - recurse on tail
  ```
  foldM f a (b : bs) = do
    a' <- f a b
    foldM f a' bs
  ```

## Monads and Applicatives
- If instance of Monad type class ? Then instance of Apply type class !
- If every monad is also an applicative functor, then we should be able to apply our intuition for applicative functors to every monad. But monads allow us to do more than we could do with just applicative functors
  - Applicative functors only allow us to lift function arguments which are independent of each other, but monads allow us to write computations which involve more interesting data dependencies.
  - Monad type class allows computations to depend on the results of previous computations

## Native Effects
- `Effect` monad: native side effect 관리
- non-native
  - Optional values, as represented by the Maybe data type
  - Errors, as represented by the Either data type
  - Multi-functions, as represented by arrays or lists

## Side-Effects and Purity
- `pure` computations are distinguished from computations with side-effects in the type system. 
- Values with side-effects have different types from pure values
- `Effect` monad manage side effects with a computation of type `Effect a` from JavaScript ?

## The Effect Monad
## 
## 
## 
## Conclusion

## 소감
- 모:슨 말인지 잘 모르겠지만 열심히는 읽어봤거든요
- 나:는 발표가 많이 짧을 것 같은데
- 드:ㄷ기라도 열심히 해보겠습니다

## 질문 & 참고자료
- [3분 모나드](https://overcurried.com/3%EB%B6%84%20%EB%AA%A8%EB%82%98%EB%93%9C/)
- Side-Effects and Purity 파트 내가 이해한 게 맞나? 

## 스터디 (2022.08.03)에서 나온 내용
