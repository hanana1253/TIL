# Chapter 6. Type Classes

## Chapter goals
- 퓨어스크립트의 타입 시스템을 통해 추상화의 형태인 타입 클래스를 배워보자
- 복잡한 데이터 구조 자체를 생각하지 않고도 데이터구조 hash를 할 수 있다 ?
  - hash complex data structures without having to think directly about the structure of the data itself.
- PureScript code leans heavily on the power of type classes

## Show Me!
- 값을 받아 문자열로 반환하는 `show` 함수
```
class Show a where
  show :: a -> String
```
  - Show라는 새로운 타입클래스를 선언: 타입 변수 a라는 파라미터를 받음
  - 타입클래스의 인스턴스는 타입 클래스에서 정의된 함수의 실행을 포함, 특정 타입에 대해 specialized 
    - A type class instance contains implementations of the functions defined in a type class, specialized to a particular type.
```
instance showBoolean :: Show Boolean where
  show true = "true"
  show false = "false"
```
- 여기서 showBoolean은 선언된 타입 클래스 인스턴스, Boolean 타입은 Show 타입클래스에 속한다고 할 수 있다.
- `Data.Either` 타입의 값을 `show` 함수에 전달하면 에러가 난다.
  - PSCi가 타입추론에 실패했기 때문. 추론된 타입에서의 unknown type a 때문(?)
  - 타입 어노테이션을 사용해주어야 한다.
- 타입 클래스 인스턴스는 두 개의 위치에서 정의될 수 있다. 
  - 타입 클래스가 있는 모듈
  - 타입이 속한 타입 클래스가 정의된 모듈 
  - 이 외의 위치에서 정의된 인스턴스는 `orphan instance`이며, 컴파일되지 않는다.

## Common Type Classes 
- Prelude 및 standard libraries에 정의된 표준 타입클래스들 소개
- `Eq`: `eq` 함수를 정의, 두 개의 값의 동치를 테스트하며 `==`라는 alias가 있으며 두 인자는 같은 타입이어야 한다.
```
class Eq a where
  eq :: a -> a -> Boolean
```
- `Ord`: `compare` 함수를 정의하며 order가 있는 타입들에 대하여 두 개의 값을 비교할 때 쓰인다. `>`, `<`, `>=`, `<=` 등의 비교연산자로 정의될 수 있다. 
```
data Ordering = LT | EQ | GT

class Eq a <= Ord a where
  compare :: a -> a -> Ordering
```
- `Field`: 덧셈, 뺄셈, 곱셈, 나눗셈 등의 숫자 연산이 되는 타입들을 정의 
  - 더 제너럴한 superclasses들로부터 만들어졌기 때문에 `Field` 연산자의 일부를 지원하는 타입들에 대해 추상화할 수 있게 한다. (e.g. 자연수 타입이 덧셈과 곱셈에 대해 닫혀있지만 뺄셈에는 닫혀있지 않아 `Semiring` 클래스(`Num`의 superclass)의 인스턴스이지만 `Ring`, `Field`의 인스턴스는 아닌 것처럼)


## Semigroups and Monoids
- `Semigroup` 타입 클래스는 두 값을 조합하는 `append` 연산을 지원하는 타입들을 정의한다.
```
class Semigroup a where
  append :: a -> a -> a
```
  - 일반적인 문자열 concat의 경우 문자열이 Semigroup을 이루며, array도 마찬가지다.
  - `<>`: `append`의 alias인 concat 연산자: 
- `Monoid` 타입 클래스는 Semigroup 타입클래스를 `mempty`라 불리는 빈 값의 개념까지 확장
  - 문자열과 배열은 monoids의 대표적 예시
- A Monoid type class instance for a type describes how to accumulate a result with that type, by starting with an "empty" value, and combining new results. For example, we can write a function which concatenates an array of values in some monoid by using a fold. In PSCi: (모르겠음)
```
> import Prelude
> import Data.Monoid
> import Data.Foldable

> foldl append mempty ["Hello", " ", "World"]
"Hello World"

> foldl append mempty [[1, 2, 3], [4, 5], [6]]
[1,2,3,4,5,6]
```


## 
- 

## 
- 

## 
- 

## Conclusion
- 타입 클래스는 코드 재사용의 강력한 형태 powerful forms of code reuse
- 등식 추론의 일환인 type class laws: 프로그래밍 언어의 프로퍼티들과 타입시스템은 이 프로그램의 논리적 추론을 가능하게 하는 데에 쓰인다
- 

## 소감
- 

## 질문

## 스터디 (2022.07.20)에서 나온 내용
- 