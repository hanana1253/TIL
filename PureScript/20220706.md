# Chapter 5. Pattern Matching

## Chapter goals
- 두 개의 새로운 개념을 소개할 것
  - 대수형 자료 구조(algebraic data types): 타입 언어가 비슷한 수준의 표현성을 가지도록 함 (?)
  - 패턴 매칭: FP에서 흔하게 사용되는 기술이며 복잡한 아이디어가 될 수 있는 것들을 잘게 나누어 간결한 함수로 표현하게 함 
- 퓨어스크립트 타입 시스템의 흥미로운 특징인 row polymorphism도.
- 

## Project Setup
- `Data.Picture` 모듈
  - `Shape`과 `Picture`라는 타입을 정의
  - `Data.Foldable`, `Data.Number` 모듈을 import
  - `import Data.Number as Number`로 namespace 주면서 import하면 `Number`라는 이름을 붙여서만 타입과 함수를 사용할 수 있다. 중복된 이름을 가진 모듈 함수 import를 피할 수 있고 더 명료하게 어떤 모듈 출신인지 알 수 있다.  

## Simple Pattern Matching
- 두 정수의 가장 큰 공약수를 패턴 매칭으로 찾아내는 함수
```coffee
gcd :: Int -> Int -> Int
gcd n 0 = n
gcd 0 m = m
gcd n m = if n > m
            then gcd (n - m) m
            else gcd n (m - n)
```
  - 유클리드 호제법... 이름 신기
   

- 패턴 매칭의 장점: 수학적 함수의 spec처럼 보이는 간단하고 선언적인 코드로 각 경우에 대한 코드를 작성할 수 있다.
  - 코드의 각 줄은 `alternative`나 `case`
  - `=`의 좌항에 위치한 표현식은 `patterns`, 각 `case`는 공백으로 분리된 하나 이상의 패턴을 갖는다.
  - `case`는 인자가 어떤 조건을 만족시켜야 `=` 우항의 표현식이 평가 및 반환되어야 하는지 나타낸다.
  - 각 `case`는 순서대로 실행이 시도되며 패턴 매칭이 되는 첫 `case`가 반환값을 결정한다.
- 위의 `gcd` 함수는 다음과 같은 순서로 평가된다.
  - 첫 번째 `case` 시도: 두 번째 인자가 0 이면 n을 반환
  - 아니라면 두 번째 `case` 시도: 첫 번째 인자가 0이면 m을 반환
  - 그렇지 않다면 마지막 줄의 표현식을 평가 후 반환

## Simple Patterns
- 위 예제는 두 가지 타입의 패턴을 보여준다.
  - `Int` 타입의 어떤 값에 반드시 정확하게 일치해야만 하는 Integer literal 패턴
  - 인자에 이름을 바인딩시키는 `Variable` 패턴
- 다른 형태의 simple pattern도 있다
  - `Number`, `String`, `Char`, `Boolean` 리터럴
  - wildcard 패턴 (`_`): 어떤 인자도 다 매칭되며 이름을 바인딩하지 않는다.
- 

##  
## 

## 

## 
## 소감
- 스크롤바가 비교적 키가 커서 좋았다.
- 지난 시간 Fold를 스킵했는데 다시 봐야겠다.
