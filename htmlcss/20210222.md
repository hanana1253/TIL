# HTML5 and CSS

감명깊게 휘몰아친 첫 수업에서 했던 내용들 리뷰

## 개발환경설정

1. Web Browser인 `Chrome`, `Firefox` 설치
2. Web Browswer Extensions - `Web Developer`(css 효과 제거 등), `HeadingsMap`, `OpenWAX`, `totl11y` 설치 (크롬)
3. 에디터 `VS Code` 설치
4. VS Code Extensions - `Live Server`, `Auto Complete Tag`, `Auto Rename Tag`, `vscode-icons`(확장자명에 따라 파일들을 다른 아이콘으로 표시해주어 편리), `Monokai-Contrast Theme` (글자색으로 메소드 등 구분 편리)
  - 요새는 vscode-icons, monokai보다는 `material theme`을 많이 쓴다고 함
5. `nodejs`(자바스크립트 런타임 환경)을 버전관리해주는 nvm을 설치 (하려 했으나 우리는 hexo 하느라 이미 깔았기 때문에 nvm으로 관리하는 건 나중에 하는 걸로.)

## 학습예제 클로닝
- VS Code에 들어가면 view - terminal (단축키 `ctrl+₩`)
- root 위치로 가서(`cd`) fss 라는 디렉토리 생성하고 이동(`cd fss`)
- 슬비님 디렉토리에서 exHTML5 레포 주소 복사, `$ git clone {레포주소}`
- VS Code에서 open folder로 fss 속 EXHTML5 디렉토리 열고 index.html을 live server로 확인하여 우리가 만들 예제를 확인

### Sass(Syntactically Awesome Stylesheet 에 대하여...
- CSS의 전처리기(Preprocessor)로써, Sass로 만든 건 브라우저가 이해하지 못하므로 CSS로 변환해주어야 하는데, node Sass로 변환이 가능하지만 요새는 deprecate 되었고, 우리는 이제 dart sass를 공부해서 써야 한다.

## 학습예제를 내 레포로 옮기기
- github에서 레포 하나 새로 파기 (README.md 자동생성하면 내 최종 저장소 이름이 main이 되는데, 이왕이면 원래의 master라는 이름을 쓰기 위해 자동생성하지 말자)
- 위 클로닝한 fss 폴더에서 `rm -rf .git`으로 git을 지워주며 원래 레포와의 연결을 끊어버린다.
- `$ git remote add origin {내 레포주소}`를 넣고 `$ git status`로 확인해보면, fss 디렉토리 내의 수많은 파일들이 unstage되어 있다는 경고가 나온다. 
- `$ git add .`으로 현 폴더의 파일을 모두 stage에 올려준다.
- `$ git commit -m "HTML5&CSS3 학습예제 초안"`이라고 커밋 작성
- `$ git log --oneline`으로 확인해보면 (HEAD-master)로 뜨는데, 이건 아직 내 master branch까지만 갔고 remote repo까지는 안갔다는 얘기이다. 
- `$ git push origin master`으로 내 master branch에 있는 내용을 origin(remote repo)로 푸시한다. 
- `$ git log --oneline`으로 확인하면 이번엔 (HEAD-master, origin/master)로 뜬다.
- 내 remote repo를 확인하려면 `$ git remote -v`

## HTML과 CSS의 표준이야기

### 새로운 표준, HTML5

- Mark-up Language의 어떤 버전이 옳거나 그르다고 할 수 없다. 내가 결정하여 선택하는 것 뿐.
HTML 이전에 XML(Extensible Mark-up Language)가 있었다.  
기업간 정보를 주고받을 때 그냥 'red, 10000, 100g'라고만 하면 무엇을 나타내는 정보인지 모르니까 '<product> <pc>red</pc> <pp>10000</pp> <pw>100g</pw> </product>'로 정보의 종류와 처음/끝을 알려주었다. 이 방식을 HTML이 데려와서 태그로 활용.

- HTML(HyperText Mark-up Language)의 표준 3가지
HTML 처음에는 무조건 DTD(Document Type Definition)로 문서형식 정의를 선언하며, 이를 선언하지 않으면 브라우저는 quirks mode로 웹페이지를 해서갛여 보내준다. 그러나 웹브라우저마다 호환모드가 다르므로 DTD 선언이 없으면 호환성을 확보하기 힘들다. 
  1. `XHTML 1.0`: HTML 본연의 목적인 structure 짜는 것에서 벗어나 온갖 꾸미기용 비주얼적 태그(e.g. <center> <hr> <font> 등)가 등장하면서 HTML3.2에서 폭망  
  2. `HTML 4.0`: 이를 보완하기 위해 HTML4.0이 탄생하였는데 너무 느슨한 ruleset 때문에 문제가 되었다. 대소문자 구분도 안하고(코드일관성 상실), 종료태그 생략도 가능하며, class 명명시 string처럼 따옴표를 붙여주지 않아도 작동하게끔 했다. XHTML1.0과 HTML4.0은 문법 통일을 하되 XTML의 Strict ruleset을 사용하게 하는 식으로 대응. (e.g. 태그 종료를 따로 안해줘도 되는 img 등의 태그는 시작 태그의 끝을 '/>'로 하는 식으로 self-closing을 해야만 한다.)
  3. `HTML 5`: 이런 HTML 표준의 변화에 따라 자사의 browser 기준에 맞게 rendering해야 하는 browser vendor(Chrome 벤더 Google, IE의 MS, Firefox의 Mozilla, Safari의 Apple 등)들이 HTML 스펙 제정 기구인 `W3C(World Wide Web Consortium)` 의 답답하고 느린 일처리 때문에 자기들이 먼저 working group을 만들어 호환되는 표준기술을 만들어버렸다. W3C는 권고안일 뿐 강제성이 없기 때문에 벤더들이 만든 자체 기준이 공식 표준을 끌고가는 형국이 되어버렸다. 결국 W3C 또한 자기들이 만든 XHTML의 실패를 인정하고 working group으로 합류하여 HTML5를 만들어냈다. 
    - HTML5는browser vendor들이 application 개발 위주로 만들었기 때문에 API가 주요 파트이며 mark-up language는 API 업그레이드에 딸려온 형국이다. HTML4까지는 mark-up과 API를 구분하지 않았는데 HTML5부터는 차이를 구분하며 아예 새로운 판을 만들어냈다.

- 그렇다면 새로운 표준 HTML5는 무엇이 다를까?
  1. `새로운 컨텐츠 모델 등장`: 이전에는 기능에 따라 block인지 inline인지만 구분하고 inline은 block보다 무조건 작기 때문에 block 태그 안에 포함될 수만 있었다. (e.g. block 태그인 <div> 안에 <span>, vice versa는 불가능)
    - 그러나 HTML5에서는 다양한 기능적 category인 컨텐츠 모델의 기준에 따라 포함되는 경우가 결정되지 block인지 inline인지는 중요치 않다. (contents model은 validator로 체크하면서 기준을 익힐 수 있다.)
  2. `Outline Algorithm`: (공식적으로 쓰이고 있진 않지만 짚고 넘어가기) 레이아웃과는 다르다. 배치할 때의 구분이 아니라 구조적으로 어떤 태그가 어디까지 영향을 주는지 outline을 파악할 수 있다. `div` 태그로 그냥 묶어두던 것이 전부였던 과거와 달리 이제는 `section`, `aside`, `nav`, `article` 등의 태그를 기능적으로 잘 묶어 활용할 수 있다.
  3. `API`: JavaScript를 이용하여 특정한 데이터를 편하게 쓸 수 있는 함수 덩어리. (e.g. 오프라인에서도 미리 온라인일 때 캐시를 저장하여 둔 결과물을 출력해두는 application cache라거나) 

## 느낀 점
파이썬이 끝나서 아쉬울 새도 없이 재미있다... 뭔가 대단히 즐거울 것 같은 예감이 든다.
